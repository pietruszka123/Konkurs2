(function(e, a) { for(var i in a) e[i] = a[i]; }(exports, /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 91);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

module.exports = _defineProperty;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),
/* 1 */
/***/ (function(module, exports) {

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

module.exports = _assertThisInitialized;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),
/* 2 */
/***/ (function(module, exports) {

function _getPrototypeOf(o) {
  module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  module.exports["default"] = module.exports, module.exports.__esModule = true;
  return _getPrototypeOf(o);
}

module.exports = _getPrototypeOf;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),
/* 3 */
/***/ (function(module, exports) {

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

module.exports = _classCallCheck;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),
/* 4 */
/***/ (function(module, exports) {

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

module.exports = _createClass;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

var _typeof = __webpack_require__(19)["default"];

var assertThisInitialized = __webpack_require__(1);

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }

  return assertThisInitialized(self);
}

module.exports = _possibleConstructorReturn;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

var setPrototypeOf = __webpack_require__(42);

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) setPrototypeOf(subClass, superClass);
}

module.exports = _inherits;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {
  EPSILON: __webpack_require__(63),
  create: __webpack_require__(64),
  clone: __webpack_require__(158),
  fromValues: __webpack_require__(159),
  copy: __webpack_require__(160),
  set: __webpack_require__(161),
  equals: __webpack_require__(162),
  exactEquals: __webpack_require__(163),
  add: __webpack_require__(164),
  subtract: __webpack_require__(65),
  sub: __webpack_require__(165),
  multiply: __webpack_require__(66),
  mul: __webpack_require__(166),
  divide: __webpack_require__(67),
  div: __webpack_require__(167),
  inverse: __webpack_require__(168),
  min: __webpack_require__(169),
  max: __webpack_require__(170),
  rotate: __webpack_require__(171),
  floor: __webpack_require__(172),
  ceil: __webpack_require__(173),
  round: __webpack_require__(174),
  scale: __webpack_require__(175),
  scaleAndAdd: __webpack_require__(176),
  distance: __webpack_require__(68),
  dist: __webpack_require__(177),
  squaredDistance: __webpack_require__(69),
  sqrDist: __webpack_require__(178),
  length: __webpack_require__(70),
  len: __webpack_require__(179),
  squaredLength: __webpack_require__(71),
  sqrLen: __webpack_require__(180),
  negate: __webpack_require__(181),
  normalize: __webpack_require__(182),
  dot: __webpack_require__(183),
  cross: __webpack_require__(184),
  lerp: __webpack_require__(185),
  random: __webpack_require__(186),
  transformMat2: __webpack_require__(187),
  transformMat2d: __webpack_require__(188),
  transformMat3: __webpack_require__(189),
  transformMat4: __webpack_require__(190),
  forEach: __webpack_require__(191),
  limit: __webpack_require__(192)
};

/***/ }),
/* 8 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ({
  init: function init(arr, val) {
    // arr.fill(val);
    var l = arr.length;

    while (l--) {
      arr[l] = val;
    }
  },

  /**
   * Shuffles the content of an array
   */
  shuffle: function shuffle(arr) {
    var i = arr.length - 1;

    for (i; i >= 0; i--) {
      var j = Math.floor(Math.random() * i);
      var x = arr[i];
      arr[i] = arr[j];
      arr[j] = x;
    }

    return arr;
  },
  toPointList: function toPointList(arr) {
    var rows = arr.reduce(function (p, n) {
      var row = "[".concat(n.join(','), "]");
      p.push(row);
      return p;
    }, []);
    return "[".concat(rows.join(',\r\n'), "]");
  },

  /**
   * returns the elements which's score is bigger than the threshold
   */
  threshold: function threshold(arr, _threshold, scoreFunc) {
    var queue = arr.reduce(function (prev, next) {
      if (scoreFunc.apply(arr, [next]) >= _threshold) {
        prev.push(next);
      }

      return prev;
    }, []);
    return queue;
  },
  maxIndex: function maxIndex(arr) {
    var max = 0;

    for (var i = 0; i < arr.length; i++) {
      if (arr[i] > arr[max]) {
        max = i;
      }
    }

    return max;
  },
  max: function max(arr) {
    var max = 0;

    for (var i = 0; i < arr.length; i++) {
      if (arr[i] > max) {
        max = arr[i];
      }
    }

    return max;
  },
  sum: function sum(arr) {
    var length = arr.length;
    var sum = 0;

    while (length--) {
      sum += arr[length];
    }

    return sum;
  }
});

/***/ }),
/* 9 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(33);
/* harmony import */ var _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(4);
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(0);
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var gl_vec2__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(7);
/* harmony import */ var gl_vec2__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(gl_vec2__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _cv_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(10);
/* harmony import */ var _array_helper__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(8);







var vec2 = {
  clone: gl_vec2__WEBPACK_IMPORTED_MODULE_4__["clone"]
};

function assertNumberPositive(val) {
  if (val < 0) {
    throw new Error("expected positive number, received ".concat(val));
  }
}

var ImageWrapper = /*#__PURE__*/function () {
  // Represents a basic image combining the data and size. In addition, some methods for
  // manipulation are contained within.
  function ImageWrapper(size, data) {
    var ArrayType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Uint8Array;
    var initialize = arguments.length > 3 ? arguments[3] : undefined;

    _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, ImageWrapper);

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3___default()(this, "data", void 0);

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3___default()(this, "size", void 0);

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3___default()(this, "indexMapping", void 0);

    if (!data) {
      this.data = new ArrayType(size.x * size.y);

      if (initialize) {
        _array_helper__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"].init(this.data, 0);
      }
    } else {
      this.data = data;
    }

    this.size = size;
  } // tests if a position is within the image, extended out by a border on each side


  _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(ImageWrapper, [{
    key: "inImageWithBorder",
    value: function inImageWithBorder(imgRef) {
      var border = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      assertNumberPositive(border); // TODO: code_128 starts failing miserably when i only allow imgRef to contain positive numbers.
      // TODO: this doesn't make much sense to me, why does it go negative?  Tests are not affected by
      // returning false, but the whole code_128 reader blows up when i throw on negative imgRef.
      // assertNumberPositive(imgRef.x);
      // assertNumberPositive(imgRef.y);

      return imgRef.x >= 0 && imgRef.y >= 0 && imgRef.x < this.size.x + border * 2 && imgRef.y < this.size.y + border * 2;
    } // Copy from THIS ImageWrapper to the new imageWrapper parameter, starting at from, stopping at
    // end of new imageWrapper size.

  }, {
    key: "subImageAsCopy",
    value: function subImageAsCopy(imageWrapper, from) {
      assertNumberPositive(from.x);
      assertNumberPositive(from.y);
      var _imageWrapper$size = imageWrapper.size,
          sizeX = _imageWrapper$size.x,
          sizeY = _imageWrapper$size.y;

      for (var x = 0; x < sizeX; x++) {
        for (var y = 0; y < sizeY; y++) {
          // eslint-disable-next-line no-param-reassign
          imageWrapper.data[y * sizeX + x] = this.data[(from.y + y) * this.size.x + from.x + x];
        }
      }

      return imageWrapper; // TODO: this function really probably should call into ImageWrapper somewhere to make
      // sure that all of it's parameters are set properly, something like
      // ImageWrapper.UpdateFrom()
      // that might take a provided data and size, and make sure there's no invalid indexMapping
      // hanging around, and such.
    } // Retrieve a grayscale value at the given pixel position of the image

  }, {
    key: "get",
    value: function get(x, y) {
      return this.data[y * this.size.x + x];
    } // Retrieve a grayscale value at the given pixel position of the image (safe, whatever that
    // means)

  }, {
    key: "getSafe",
    value: function getSafe(x, y) {
      // cache indexMapping because if we're using it once, we'll probably need it a bunch more
      // too
      if (!this.indexMapping) {
        this.indexMapping = {
          x: [],
          y: []
        };

        for (var i = 0; i < this.size.x; i++) {
          this.indexMapping.x[i] = i;
          this.indexMapping.x[i + this.size.x] = i;
        }

        for (var _i = 0; _i < this.size.y; _i++) {
          this.indexMapping.y[_i] = _i;
          this.indexMapping.y[_i + this.size.y] = _i;
        }
      }

      return this.data[this.indexMapping.y[y + this.size.y] * this.size.x + this.indexMapping.x[x + this.size.x]];
    } // Sets a given pixel position in the image to the given grayscale value

  }, {
    key: "set",
    value: function set(x, y, value) {
      this.data[y * this.size.x + x] = value;
      delete this.indexMapping;
      return this;
    } // Sets the border of the image (1 pixel) to zero

  }, {
    key: "zeroBorder",
    value: function zeroBorder() {
      var _this$size = this.size,
          width = _this$size.x,
          height = _this$size.y;

      for (var i = 0; i < width; i++) {
        // eslint-disable-next-line no-multi-assign
        this.data[i] = this.data[(height - 1) * width + i] = 0;
      }

      for (var _i2 = 1; _i2 < height - 1; _i2++) {
        // eslint-disable-next-line no-multi-assign
        this.data[_i2 * width] = this.data[_i2 * width + (width - 1)] = 0;
      }

      delete this.indexMapping;
      return this;
    } // TODO: this function is entirely too large for me to reason out right at this moment that i'm handling
    // all the rest of it, so this is a verbatim copy of the javascript source, with only tweaks
    // necessary to get it to run, no thought put into it yet.

  }, {
    key: "moments",
    value: function moments(labelCount) {
      var data = this.data;
      var x;
      var y;
      var height = this.size.y;
      var width = this.size.x;
      var val;
      var ysq;
      var labelSum = [];
      var i;
      var label;
      var mu11;
      var mu02;
      var mu20;
      var x_;
      var y_;
      var tmp;
      var result = [];
      var PI = Math.PI;
      var PI_4 = PI / 4;

      if (labelCount <= 0) {
        return result;
      }

      for (i = 0; i < labelCount; i++) {
        labelSum[i] = {
          m00: 0,
          m01: 0,
          m10: 0,
          m11: 0,
          m02: 0,
          m20: 0,
          theta: 0,
          rad: 0
        };
      }

      for (y = 0; y < height; y++) {
        ysq = y * y;

        for (x = 0; x < width; x++) {
          val = data[y * width + x];

          if (val > 0) {
            label = labelSum[val - 1];
            label.m00 += 1;
            label.m01 += y;
            label.m10 += x;
            label.m11 += x * y;
            label.m02 += ysq;
            label.m20 += x * x;
          }
        }
      }

      for (i = 0; i < labelCount; i++) {
        label = labelSum[i]; // eslint-disable-next-line no-restricted-globals

        if (!isNaN(label.m00) && label.m00 !== 0) {
          x_ = label.m10 / label.m00;
          y_ = label.m01 / label.m00;
          mu11 = label.m11 / label.m00 - x_ * y_;
          mu02 = label.m02 / label.m00 - y_ * y_;
          mu20 = label.m20 / label.m00 - x_ * x_;
          tmp = (mu02 - mu20) / (2 * mu11);
          tmp = 0.5 * Math.atan(tmp) + (mu11 >= 0 ? PI_4 : -PI_4) + PI; // eslint-disable-next-line no-mixed-operators

          label.theta = (tmp * 180 / PI + 90) % 180 - 90;

          if (label.theta < 0) {
            label.theta += 180;
          }

          label.rad = tmp > PI ? tmp - PI : tmp;
          label.vec = vec2.clone([Math.cos(tmp), Math.sin(tmp)]);
          result.push(label);
        }
      }

      return result;
    } // return a Uint8ClampedArray containing this grayscale image converted to RGBA form

  }, {
    key: "getAsRGBA",
    value: function getAsRGBA() {
      var scale = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1.0;
      var ret = new Uint8ClampedArray(4 * this.size.x * this.size.y);

      for (var y = 0; y < this.size.y; y++) {
        for (var x = 0; x < this.size.x; x++) {
          var pixel = y * this.size.x + x;
          var current = this.get(x, y) * scale;
          ret[pixel * 4 + 0] = current;
          ret[pixel * 4 + 1] = current;
          ret[pixel * 4 + 2] = current;
          ret[pixel * 4 + 3] = 255;
        }
      }

      return ret;
    } // Display this ImageWrapper in a given Canvas element at the specified scale

  }, {
    key: "show",
    value: function show(canvas) {
      var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1.0;
      var ctx = canvas.getContext('2d');

      if (!ctx) {
        throw new Error('Unable to get canvas context');
      }

      var frame = ctx.getImageData(0, 0, canvas.width, canvas.height);
      var data = this.getAsRGBA(scale); // eslint-disable-next-line no-param-reassign

      canvas.width = this.size.x; // eslint-disable-next-line no-param-reassign

      canvas.height = this.size.y;
      var newFrame = new ImageData(data, frame.width, frame.height);
      ctx.putImageData(newFrame, 0, 0);
    } // Displays a specified SubImage area in a given canvas. This differs drastically from
    // creating a new SubImage and using it's show() method. Why? I don't have the answer to that
    // yet.  I suspect the HSV/RGB operations involved here are making it significantly different,
    // but until I can visualize these functions side by side, I'm just going to copy the existing
    // implementation.

  }, {
    key: "overlay",
    value: function overlay(canvas, inScale, from) {
      var adjustedScale = inScale < 0 || inScale > 360 ? 360 : inScale;
      var hsv = [0, 1, 1];
      var rgb = [0, 0, 0];
      var whiteRgb = [255, 255, 255];
      var blackRgb = [0, 0, 0];
      var result = [];
      var ctx = canvas.getContext('2d');

      if (!ctx) {
        throw new Error('Unable to get canvas context');
      }

      var frame = ctx.getImageData(from.x, from.y, this.size.x, this.size.y);
      var data = frame.data;
      var length = this.data.length;

      while (length--) {
        hsv[0] = this.data[length] * adjustedScale; // eslint-disable-next-line no-nested-ternary

        result = hsv[0] <= 0 ? whiteRgb : hsv[0] >= 360 ? blackRgb : Object(_cv_utils__WEBPACK_IMPORTED_MODULE_5__["hsv2rgb"])(hsv, rgb);
        var pos = length * 4;
        var _result = result;

        var _result2 = _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0___default()(_result, 3);

        data[pos] = _result2[0];
        data[pos + 1] = _result2[1];
        data[pos + 2] = _result2[2];
        data[pos + 3] = 255;
      }

      ctx.putImageData(frame, from.x, from.y);
    }
  }]);

  return ImageWrapper;
}();

/* harmony default export */ __webpack_exports__["a"] = (ImageWrapper);

/***/ }),
/* 10 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, "imageRef", function() { return /* binding */ imageRef; });
__webpack_require__.d(__webpack_exports__, "computeIntegralImage2", function() { return /* binding */ computeIntegralImage2; });
__webpack_require__.d(__webpack_exports__, "computeIntegralImage", function() { return /* binding */ computeIntegralImage; });
__webpack_require__.d(__webpack_exports__, "thresholdImage", function() { return /* binding */ thresholdImage; });
__webpack_require__.d(__webpack_exports__, "computeHistogram", function() { return /* binding */ computeHistogram; });
__webpack_require__.d(__webpack_exports__, "sharpenLine", function() { return /* binding */ sharpenLine; });
__webpack_require__.d(__webpack_exports__, "determineOtsuThreshold", function() { return /* binding */ determineOtsuThreshold; });
__webpack_require__.d(__webpack_exports__, "otsuThreshold", function() { return /* binding */ otsuThreshold; });
__webpack_require__.d(__webpack_exports__, "computeBinaryImage", function() { return /* binding */ computeBinaryImage; });
__webpack_require__.d(__webpack_exports__, "cluster", function() { return /* binding */ cv_utils_cluster; });
__webpack_require__.d(__webpack_exports__, "Tracer", function() { return /* binding */ Tracer; });
__webpack_require__.d(__webpack_exports__, "DILATE", function() { return /* binding */ DILATE; });
__webpack_require__.d(__webpack_exports__, "ERODE", function() { return /* binding */ ERODE; });
__webpack_require__.d(__webpack_exports__, "dilate", function() { return /* binding */ dilate; });
__webpack_require__.d(__webpack_exports__, "erode", function() { return /* binding */ erode; });
__webpack_require__.d(__webpack_exports__, "subtract", function() { return /* binding */ subtract; });
__webpack_require__.d(__webpack_exports__, "bitwiseOr", function() { return /* binding */ bitwiseOr; });
__webpack_require__.d(__webpack_exports__, "countNonZero", function() { return /* binding */ countNonZero; });
__webpack_require__.d(__webpack_exports__, "topGeneric", function() { return /* binding */ topGeneric; });
__webpack_require__.d(__webpack_exports__, "grayArrayFromImage", function() { return /* binding */ grayArrayFromImage; });
__webpack_require__.d(__webpack_exports__, "grayArrayFromContext", function() { return /* binding */ grayArrayFromContext; });
__webpack_require__.d(__webpack_exports__, "grayAndHalfSampleFromCanvasData", function() { return /* binding */ grayAndHalfSampleFromCanvasData; });
__webpack_require__.d(__webpack_exports__, "computeGray", function() { return /* binding */ computeGray; });
__webpack_require__.d(__webpack_exports__, "loadImageArray", function() { return /* binding */ loadImageArray; });
__webpack_require__.d(__webpack_exports__, "halfSample", function() { return /* binding */ halfSample; });
__webpack_require__.d(__webpack_exports__, "hsv2rgb", function() { return /* binding */ hsv2rgb; });
__webpack_require__.d(__webpack_exports__, "_computeDivisors", function() { return /* binding */ _computeDivisors; });
__webpack_require__.d(__webpack_exports__, "calculatePatchSize", function() { return /* binding */ calculatePatchSize; });
__webpack_require__.d(__webpack_exports__, "_parseCSSDimensionValues", function() { return /* binding */ _parseCSSDimensionValues; });
__webpack_require__.d(__webpack_exports__, "_dimensionsConverters", function() { return /* binding */ _dimensionsConverters; });
__webpack_require__.d(__webpack_exports__, "computeImageArea", function() { return /* binding */ computeImageArea; });

// EXTERNAL MODULE: ./node_modules/gl-vec2/index.js
var gl_vec2 = __webpack_require__(7);

// EXTERNAL MODULE: ./node_modules/gl-vec3/index.js
var gl_vec3 = __webpack_require__(84);

// CONCATENATED MODULE: ./src/common/cluster.js
// TODO: cluster.js and cv_utils.js are pretty tightly intertwined, making for a complex conversion
// into typescript. be warned. :-)

var vec2 = {
  clone: gl_vec2["clone"],
  dot: gl_vec2["dot"]
};
/**
 * Creates a cluster for grouping similar orientations of datapoints
 */

/* harmony default export */ var cluster = ({
  create: function create(point, threshold) {
    var points = [];
    var center = {
      rad: 0,
      vec: vec2.clone([0, 0])
    };
    var pointMap = {};

    function _add(pointToAdd) {
      pointMap[pointToAdd.id] = pointToAdd;
      points.push(pointToAdd);
    }

    function updateCenter() {
      var i;
      var sum = 0;

      for (i = 0; i < points.length; i++) {
        sum += points[i].rad;
      }

      center.rad = sum / points.length;
      center.vec = vec2.clone([Math.cos(center.rad), Math.sin(center.rad)]);
    }

    function init() {
      _add(point);

      updateCenter();
    }

    init();
    return {
      add: function add(pointToAdd) {
        if (!pointMap[pointToAdd.id]) {
          _add(pointToAdd);

          updateCenter();
        }
      },
      fits: function fits(otherPoint) {
        // check cosine similarity to center-angle
        var similarity = Math.abs(vec2.dot(otherPoint.point.vec, center.vec));

        if (similarity > threshold) {
          return true;
        }

        return false;
      },
      getPoints: function getPoints() {
        return points;
      },
      getCenter: function getCenter() {
        return center;
      }
    };
  },
  createPoint: function createPoint(newPoint, id, property) {
    return {
      rad: newPoint[property],
      point: newPoint,
      id: id
    };
  }
});
// EXTERNAL MODULE: ./src/common/array_helper.ts
var array_helper = __webpack_require__(8);

// CONCATENATED MODULE: ./src/common/cv_utils.js
/* eslint-disable no-mixed-operators */

/* eslint-disable no-bitwise */




var cv_utils_vec2 = {
  clone: gl_vec2["clone"]
};
var vec3 = {
  clone: gl_vec3["clone"]
};
/**
 * @param x x-coordinate
 * @param y y-coordinate
 * @return ImageReference {x,y} Coordinate
 */

function imageRef(x, y) {
  var that = {
    x: x,
    y: y,
    toVec2: function toVec2() {
      return cv_utils_vec2.clone([this.x, this.y]);
    },
    toVec3: function toVec3() {
      return vec3.clone([this.x, this.y, 1]);
    },
    round: function round() {
      this.x = this.x > 0.0 ? Math.floor(this.x + 0.5) : Math.floor(this.x - 0.5);
      this.y = this.y > 0.0 ? Math.floor(this.y + 0.5) : Math.floor(this.y - 0.5);
      return this;
    }
  };
  return that;
}
/**
 * Computes an integral image of a given grayscale image.
 * @param imageDataContainer {ImageDataContainer} the image to be integrated
 */

function computeIntegralImage2(imageWrapper, integralWrapper) {
  var imageData = imageWrapper.data;
  var width = imageWrapper.size.x;
  var height = imageWrapper.size.y;
  var integralImageData = integralWrapper.data;
  var sum = 0;
  var posA = 0;
  var posB = 0;
  var posC = 0;
  var posD = 0;
  var x;
  var y; // sum up first column

  posB = width;
  sum = 0;

  for (y = 1; y < height; y++) {
    sum += imageData[posA];
    integralImageData[posB] += sum;
    posA += width;
    posB += width;
  }

  posA = 0;
  posB = 1;
  sum = 0;

  for (x = 1; x < width; x++) {
    sum += imageData[posA];
    integralImageData[posB] += sum;
    posA++;
    posB++;
  }

  for (y = 1; y < height; y++) {
    posA = y * width + 1;
    posB = (y - 1) * width + 1;
    posC = y * width;
    posD = (y - 1) * width;

    for (x = 1; x < width; x++) {
      integralImageData[posA] += imageData[posA] + integralImageData[posB] + integralImageData[posC] - integralImageData[posD];
      posA++;
      posB++;
      posC++;
      posD++;
    }
  }
}
function computeIntegralImage(imageWrapper, integralWrapper) {
  var imageData = imageWrapper.data;
  var width = imageWrapper.size.x;
  var height = imageWrapper.size.y;
  var integralImageData = integralWrapper.data;
  var sum = 0; // sum up first row

  for (var i = 0; i < width; i++) {
    sum += imageData[i];
    integralImageData[i] = sum;
  }

  for (var v = 1; v < height; v++) {
    sum = 0;

    for (var u = 0; u < width; u++) {
      sum += imageData[v * width + u];
      integralImageData[v * width + u] = sum + integralImageData[(v - 1) * width + u];
    }
  }
}
function thresholdImage(imageWrapper, threshold, targetWrapper) {
  if (!targetWrapper) {
    // eslint-disable-next-line no-param-reassign
    targetWrapper = imageWrapper;
  }

  var imageData = imageWrapper.data;
  var length = imageData.length;
  var targetData = targetWrapper.data;

  while (length--) {
    targetData[length] = imageData[length] < threshold ? 1 : 0;
  }
}
function computeHistogram(imageWrapper, bitsPerPixel) {
  if (!bitsPerPixel) {
    // eslint-disable-next-line no-param-reassign
    bitsPerPixel = 8;
  }

  var imageData = imageWrapper.data;
  var length = imageData.length;
  var bitShift = 8 - bitsPerPixel;
  var bucketCnt = 1 << bitsPerPixel;
  var hist = new Int32Array(bucketCnt);

  while (length--) {
    hist[imageData[length] >> bitShift]++;
  }

  return hist;
}
function sharpenLine(line) {
  var i;
  var length = line.length;
  var left = line[0];
  var center = line[1];
  var right;

  for (i = 1; i < length - 1; i++) {
    right = line[i + 1]; //  -1 4 -1 kernel
    // eslint-disable-next-line no-param-reassign

    line[i - 1] = center * 2 - left - right & 255;
    left = center;
    center = right;
  }

  return line;
}
function determineOtsuThreshold(imageWrapper) {
  var bitsPerPixel = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 8;
  var hist;
  var bitShift = 8 - bitsPerPixel;

  function px(init, end) {
    var sum = 0;

    for (var i = init; i <= end; i++) {
      sum += hist[i];
    }

    return sum;
  }

  function mx(init, end) {
    var sum = 0;

    for (var i = init; i <= end; i++) {
      sum += i * hist[i];
    }

    return sum;
  }

  function determineThreshold() {
    var vet = [0];
    var p1;
    var p2;
    var p12;
    var m1;
    var m2;
    var m12;
    var max = (1 << bitsPerPixel) - 1;
    hist = computeHistogram(imageWrapper, bitsPerPixel);

    for (var k = 1; k < max; k++) {
      p1 = px(0, k);
      p2 = px(k + 1, max);
      p12 = p1 * p2;

      if (p12 === 0) {
        p12 = 1;
      }

      m1 = mx(0, k) * p2;
      m2 = mx(k + 1, max) * p1;
      m12 = m1 - m2;
      vet[k] = m12 * m12 / p12;
    }

    return array_helper["a" /* default */].maxIndex(vet);
  }

  var threshold = determineThreshold();
  return threshold << bitShift;
}
function otsuThreshold(imageWrapper, targetWrapper) {
  var threshold = determineOtsuThreshold(imageWrapper);
  thresholdImage(imageWrapper, threshold, targetWrapper);
  return threshold;
} // local thresholding

function computeBinaryImage(imageWrapper, integralWrapper, targetWrapper) {
  computeIntegralImage(imageWrapper, integralWrapper);

  if (!targetWrapper) {
    // eslint-disable-next-line no-param-reassign
    targetWrapper = imageWrapper;
  }

  var imageData = imageWrapper.data;
  var targetData = targetWrapper.data;
  var width = imageWrapper.size.x;
  var height = imageWrapper.size.y;
  var integralImageData = integralWrapper.data;
  var sum = 0;
  var v;
  var u;
  var kernel = 3;
  var A;
  var B;
  var C;
  var D;
  var avg;
  var size = (kernel * 2 + 1) * (kernel * 2 + 1); // clear out top & bottom-border

  for (v = 0; v <= kernel; v++) {
    for (u = 0; u < width; u++) {
      targetData[v * width + u] = 0;
      targetData[(height - 1 - v) * width + u] = 0;
    }
  } // clear out left & right border


  for (v = kernel; v < height - kernel; v++) {
    for (u = 0; u <= kernel; u++) {
      targetData[v * width + u] = 0;
      targetData[v * width + (width - 1 - u)] = 0;
    }
  }

  for (v = kernel + 1; v < height - kernel - 1; v++) {
    for (u = kernel + 1; u < width - kernel; u++) {
      A = integralImageData[(v - kernel - 1) * width + (u - kernel - 1)];
      B = integralImageData[(v - kernel - 1) * width + (u + kernel)];
      C = integralImageData[(v + kernel) * width + (u - kernel - 1)];
      D = integralImageData[(v + kernel) * width + (u + kernel)];
      sum = D - C - B + A;
      avg = sum / size;
      targetData[v * width + u] = imageData[v * width + u] > avg + 5 ? 0 : 1;
    }
  }
}
function cv_utils_cluster(points, threshold, property) {
  var i;
  var k;
  var thisCluster;
  var point;
  var clusters = [];

  if (!property) {
    // eslint-disable-next-line no-param-reassign
    property = 'rad';
  }

  function addToCluster(newPoint) {
    var found = false;

    for (k = 0; k < clusters.length; k++) {
      thisCluster = clusters[k];

      if (thisCluster.fits(newPoint)) {
        thisCluster.add(newPoint);
        found = true;
      }
    }

    return found;
  } // iterate over each cloud


  for (i = 0; i < points.length; i++) {
    point = cluster.createPoint(points[i], i, property);

    if (!addToCluster(point)) {
      clusters.push(cluster.create(point, threshold));
    }
  }

  return clusters;
}
var Tracer = {
  trace: function trace(points, vec) {
    var iteration;
    var maxIterations = 10;
    var top = [];
    var result = [];
    var centerPos = 0;
    var currentPos = 0;

    function trace(idx, forward) {
      var to;
      var toIdx;
      var predictedPos;
      var thresholdX = 1;
      var thresholdY = Math.abs(vec[1] / 10);
      var found = false;

      function match(pos, predicted) {
        if (pos.x > predicted.x - thresholdX && pos.x < predicted.x + thresholdX && pos.y > predicted.y - thresholdY && pos.y < predicted.y + thresholdY) {
          return true;
        }

        return false;
      } // check if the next index is within the vec specifications
      // if not, check as long as the threshold is met


      var from = points[idx];

      if (forward) {
        predictedPos = {
          x: from.x + vec[0],
          y: from.y + vec[1]
        };
      } else {
        predictedPos = {
          x: from.x - vec[0],
          y: from.y - vec[1]
        };
      }

      toIdx = forward ? idx + 1 : idx - 1;
      to = points[toIdx]; // eslint-disable-next-line no-cond-assign

      while (to && (found = match(to, predictedPos)) !== true && Math.abs(to.y - from.y) < vec[1]) {
        toIdx = forward ? toIdx + 1 : toIdx - 1;
        to = points[toIdx];
      }

      return found ? toIdx : null;
    }

    for (iteration = 0; iteration < maxIterations; iteration++) {
      // randomly select point to start with
      centerPos = Math.floor(Math.random() * points.length); // trace forward

      top = [];
      currentPos = centerPos;
      top.push(points[currentPos]); // eslint-disable-next-line no-cond-assign

      while ((currentPos = trace(currentPos, true)) !== null) {
        top.push(points[currentPos]);
      }

      if (centerPos > 0) {
        currentPos = centerPos; // eslint-disable-next-line no-cond-assign

        while ((currentPos = trace(currentPos, false)) !== null) {
          top.push(points[currentPos]);
        }
      }

      if (top.length > result.length) {
        result = top;
      }
    }

    return result;
  }
};
var DILATE = 1;
var ERODE = 2;
function dilate(inImageWrapper, outImageWrapper) {
  var v;
  var u;
  var inImageData = inImageWrapper.data;
  var outImageData = outImageWrapper.data;
  var height = inImageWrapper.size.y;
  var width = inImageWrapper.size.x;
  var sum;
  var yStart1;
  var yStart2;
  var xStart1;
  var xStart2;

  for (v = 1; v < height - 1; v++) {
    for (u = 1; u < width - 1; u++) {
      yStart1 = v - 1;
      yStart2 = v + 1;
      xStart1 = u - 1;
      xStart2 = u + 1;
      sum = inImageData[yStart1 * width + xStart1] + inImageData[yStart1 * width + xStart2] + inImageData[v * width + u] + inImageData[yStart2 * width + xStart1] + inImageData[yStart2 * width + xStart2];
      outImageData[v * width + u] = sum > 0 ? 1 : 0;
    }
  }
}
function erode(inImageWrapper, outImageWrapper) {
  var v;
  var u;
  var inImageData = inImageWrapper.data;
  var outImageData = outImageWrapper.data;
  var height = inImageWrapper.size.y;
  var width = inImageWrapper.size.x;
  var sum;
  var yStart1;
  var yStart2;
  var xStart1;
  var xStart2;

  for (v = 1; v < height - 1; v++) {
    for (u = 1; u < width - 1; u++) {
      yStart1 = v - 1;
      yStart2 = v + 1;
      xStart1 = u - 1;
      xStart2 = u + 1;
      sum = inImageData[yStart1 * width + xStart1] + inImageData[yStart1 * width + xStart2] + inImageData[v * width + u] + inImageData[yStart2 * width + xStart1] + inImageData[yStart2 * width + xStart2];
      outImageData[v * width + u] = sum === 5 ? 1 : 0;
    }
  }
}
function subtract(aImageWrapper, bImageWrapper, resultImageWrapper) {
  if (!resultImageWrapper) {
    // eslint-disable-next-line no-param-reassign
    resultImageWrapper = aImageWrapper;
  }

  var length = aImageWrapper.data.length;
  var aImageData = aImageWrapper.data;
  var bImageData = bImageWrapper.data;
  var cImageData = resultImageWrapper.data;

  while (length--) {
    cImageData[length] = aImageData[length] - bImageData[length];
  }
}
function bitwiseOr(aImageWrapper, bImageWrapper, resultImageWrapper) {
  if (!resultImageWrapper) {
    // eslint-disable-next-line no-param-reassign
    resultImageWrapper = aImageWrapper;
  }

  var length = aImageWrapper.data.length;
  var aImageData = aImageWrapper.data;
  var bImageData = bImageWrapper.data;
  var cImageData = resultImageWrapper.data;

  while (length--) {
    cImageData[length] = aImageData[length] || bImageData[length];
  }
}
function countNonZero(imageWrapper) {
  var length = imageWrapper.data.length;
  var data = imageWrapper.data;
  var sum = 0;

  while (length--) {
    sum += data[length];
  }

  return sum;
}
function topGeneric(list, top, scoreFunc) {
  var i;
  var minIdx = 0;
  var min = 0;
  var queue = [];
  var score;
  var hit;
  var pos;

  for (i = 0; i < top; i++) {
    queue[i] = {
      score: 0,
      item: null
    };
  }

  for (i = 0; i < list.length; i++) {
    score = scoreFunc.apply(this, [list[i]]);

    if (score > min) {
      hit = queue[minIdx];
      hit.score = score;
      hit.item = list[i];
      min = Number.MAX_VALUE;

      for (pos = 0; pos < top; pos++) {
        if (queue[pos].score < min) {
          min = queue[pos].score;
          minIdx = pos;
        }
      }
    }
  }

  return queue;
}
function grayArrayFromImage(htmlImage, offsetX, ctx, array) {
  ctx.drawImage(htmlImage, offsetX, 0, htmlImage.width, htmlImage.height);
  var ctxData = ctx.getImageData(offsetX, 0, htmlImage.width, htmlImage.height).data;
  computeGray(ctxData, array);
}
function grayArrayFromContext(ctx, size, offset, array) {
  var ctxData = ctx.getImageData(offset.x, offset.y, size.x, size.y).data;
  computeGray(ctxData, array);
}
function grayAndHalfSampleFromCanvasData(canvasData, size, outArray) {
  var topRowIdx = 0;
  var bottomRowIdx = size.x;
  var endIdx = Math.floor(canvasData.length / 4);
  var outWidth = size.x / 2;
  var outImgIdx = 0;
  var inWidth = size.x;
  var i;

  while (bottomRowIdx < endIdx) {
    for (i = 0; i < outWidth; i++) {
      // eslint-disable-next-line no-param-reassign
      outArray[outImgIdx] = (0.299 * canvasData[topRowIdx * 4 + 0] + 0.587 * canvasData[topRowIdx * 4 + 1] + 0.114 * canvasData[topRowIdx * 4 + 2] + (0.299 * canvasData[(topRowIdx + 1) * 4 + 0] + 0.587 * canvasData[(topRowIdx + 1) * 4 + 1] + 0.114 * canvasData[(topRowIdx + 1) * 4 + 2]) + (0.299 * canvasData[bottomRowIdx * 4 + 0] + 0.587 * canvasData[bottomRowIdx * 4 + 1] + 0.114 * canvasData[bottomRowIdx * 4 + 2]) + (0.299 * canvasData[(bottomRowIdx + 1) * 4 + 0] + 0.587 * canvasData[(bottomRowIdx + 1) * 4 + 1] + 0.114 * canvasData[(bottomRowIdx + 1) * 4 + 2])) / 4;
      outImgIdx++;
      topRowIdx += 2;
      bottomRowIdx += 2;
    }

    topRowIdx += inWidth;
    bottomRowIdx += inWidth;
  }
}
function computeGray(imageData, outArray, config) {
  var l = imageData.length / 4 | 0;
  var singleChannel = config && config.singleChannel === true;

  if (singleChannel) {
    for (var i = 0; i < l; i++) {
      // eslint-disable-next-line no-param-reassign
      outArray[i] = imageData[i * 4 + 0];
    }
  } else {
    for (var _i = 0; _i < l; _i++) {
      // eslint-disable-next-line no-param-reassign
      outArray[_i] = 0.299 * imageData[_i * 4 + 0] + 0.587 * imageData[_i * 4 + 1] + 0.114 * imageData[_i * 4 + 2];
    }
  }
}
function loadImageArray(src, callback) {
  var canvas = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : document && document.createElement('canvas');
  var img = new Image();
  img.callback = callback;

  img.onload = function () {
    // eslint-disable-next-line no-param-reassign
    canvas.width = this.width; // eslint-disable-next-line no-param-reassign

    canvas.height = this.height;
    var ctx = canvas.getContext('2d');
    ctx.drawImage(this, 0, 0);
    var array = new Uint8Array(this.width * this.height);
    ctx.drawImage(this, 0, 0);

    var _ctx$getImageData = ctx.getImageData(0, 0, this.width, this.height),
        data = _ctx$getImageData.data;

    computeGray(data, array);
    this.callback(array, {
      x: this.width,
      y: this.height
    }, this);
  };

  img.src = src;
}
/**
 * @param inImg {ImageWrapper} input image to be sampled
 * @param outImg {ImageWrapper} to be stored in
 */

function halfSample(inImgWrapper, outImgWrapper) {
  var inImg = inImgWrapper.data;
  var inWidth = inImgWrapper.size.x;
  var outImg = outImgWrapper.data;
  var topRowIdx = 0;
  var bottomRowIdx = inWidth;
  var endIdx = inImg.length;
  var outWidth = inWidth / 2;
  var outImgIdx = 0;

  while (bottomRowIdx < endIdx) {
    for (var i = 0; i < outWidth; i++) {
      outImg[outImgIdx] = Math.floor((inImg[topRowIdx] + inImg[topRowIdx + 1] + inImg[bottomRowIdx] + inImg[bottomRowIdx + 1]) / 4);
      outImgIdx++;
      topRowIdx += 2;
      bottomRowIdx += 2;
    }

    topRowIdx += inWidth;
    bottomRowIdx += inWidth;
  }
}
function hsv2rgb(hsv) {
  var rgb = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0, 0];
  var h = hsv[0];
  var s = hsv[1];
  var v = hsv[2];
  var c = v * s;
  var x = c * (1 - Math.abs(h / 60 % 2 - 1));
  var m = v - c;
  var r = 0;
  var g = 0;
  var b = 0;

  if (h < 60) {
    r = c;
    g = x;
  } else if (h < 120) {
    r = x;
    g = c;
  } else if (h < 180) {
    g = c;
    b = x;
  } else if (h < 240) {
    g = x;
    b = c;
  } else if (h < 300) {
    r = x;
    b = c;
  } else if (h < 360) {
    r = c;
    b = x;
  } // eslint-disable-next-line no-param-reassign


  rgb[0] = (r + m) * 255 | 0; // eslint-disable-next-line no-param-reassign

  rgb[1] = (g + m) * 255 | 0; // eslint-disable-next-line no-param-reassign

  rgb[2] = (b + m) * 255 | 0;
  return rgb;
}
function _computeDivisors(n) {
  var largeDivisors = [];
  var divisors = [];

  for (var i = 1; i < Math.sqrt(n) + 1; i++) {
    if (n % i === 0) {
      divisors.push(i);

      if (i !== n / i) {
        largeDivisors.unshift(Math.floor(n / i));
      }
    }
  }

  return divisors.concat(largeDivisors);
}

function _computeIntersection(arr1, arr2) {
  var i = 0;
  var j = 0;
  var result = [];

  while (i < arr1.length && j < arr2.length) {
    if (arr1[i] === arr2[j]) {
      result.push(arr1[i]);
      i++;
      j++;
    } else if (arr1[i] > arr2[j]) {
      j++;
    } else {
      i++;
    }
  }

  return result;
}

function calculatePatchSize(patchSize, imgSize) {
  var divisorsX = _computeDivisors(imgSize.x);

  var divisorsY = _computeDivisors(imgSize.y);

  var wideSide = Math.max(imgSize.x, imgSize.y);

  var common = _computeIntersection(divisorsX, divisorsY);

  var nrOfPatchesList = [8, 10, 15, 20, 32, 60, 80];
  var nrOfPatchesMap = {
    'x-small': 5,
    small: 4,
    medium: 3,
    large: 2,
    'x-large': 1
  };
  var nrOfPatchesIdx = nrOfPatchesMap[patchSize] || nrOfPatchesMap.medium;
  var nrOfPatches = nrOfPatchesList[nrOfPatchesIdx];
  var desiredPatchSize = Math.floor(wideSide / nrOfPatches);
  var optimalPatchSize;

  function findPatchSizeForDivisors(divisors) {
    var i = 0;
    var found = divisors[Math.floor(divisors.length / 2)];

    while (i < divisors.length - 1 && divisors[i] < desiredPatchSize) {
      i++;
    }

    if (i > 0) {
      if (Math.abs(divisors[i] - desiredPatchSize) > Math.abs(divisors[i - 1] - desiredPatchSize)) {
        found = divisors[i - 1];
      } else {
        found = divisors[i];
      }
    }

    if (desiredPatchSize / found < nrOfPatchesList[nrOfPatchesIdx + 1] / nrOfPatchesList[nrOfPatchesIdx] && desiredPatchSize / found > nrOfPatchesList[nrOfPatchesIdx - 1] / nrOfPatchesList[nrOfPatchesIdx]) {
      return {
        x: found,
        y: found
      };
    }

    return null;
  }

  optimalPatchSize = findPatchSizeForDivisors(common);

  if (!optimalPatchSize) {
    optimalPatchSize = findPatchSizeForDivisors(_computeDivisors(wideSide));

    if (!optimalPatchSize) {
      optimalPatchSize = findPatchSizeForDivisors(_computeDivisors(desiredPatchSize * nrOfPatches));
    }
  }

  return optimalPatchSize;
}
function _parseCSSDimensionValues(value) {
  var dimension = {
    value: parseFloat(value),
    unit: value.indexOf('%') === value.length - 1 ? '%' : '%'
  };
  return dimension;
}
var _dimensionsConverters = {
  top: function top(dimension, context) {
    return dimension.unit === '%' ? Math.floor(context.height * (dimension.value / 100)) : null;
  },
  right: function right(dimension, context) {
    return dimension.unit === '%' ? Math.floor(context.width - context.width * (dimension.value / 100)) : null;
  },
  bottom: function bottom(dimension, context) {
    return dimension.unit === '%' ? Math.floor(context.height - context.height * (dimension.value / 100)) : null;
  },
  left: function left(dimension, context) {
    return dimension.unit === '%' ? Math.floor(context.width * (dimension.value / 100)) : null;
  }
};
function computeImageArea(inputWidth, inputHeight, area) {
  var context = {
    width: inputWidth,
    height: inputHeight
  };
  var parsedArea = Object.keys(area).reduce(function (result, key) {
    var value = area[key];

    var parsed = _parseCSSDimensionValues(value);

    var calculated = _dimensionsConverters[key](parsed, context); // eslint-disable-next-line no-param-reassign


    result[key] = calculated;
    return result;
  }, {});
  return {
    sx: parsedArea.left,
    sy: parsedArea.top,
    sw: parsedArea.right - parsedArea.left,
    sh: parsedArea.bottom - parsedArea.top
  };
}

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(230);

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

var superPropBase = __webpack_require__(229);

function _get(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    module.exports = _get = Reflect.get;
    module.exports["default"] = module.exports, module.exports.__esModule = true;
  } else {
    module.exports = _get = function _get(target, property, receiver) {
      var base = superPropBase(target, property);
      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property);

      if (desc.get) {
        return desc.get.call(receiver);
      }

      return desc.value;
    };

    module.exports["default"] = module.exports, module.exports.__esModule = true;
  }

  return _get(target, property, receiver || target);
}

module.exports = _get;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),
/* 13 */
/***/ (function(module, exports) {

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

module.exports = isObject;

/***/ }),
/* 14 */
/***/ (function(module, exports) {

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;
module.exports = isArray;

/***/ }),
/* 15 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// TODO: XYPosition should be an XYObject, but that breaks XYDefinition, which breaks drawPath() below.
// XYDefinition tells us which component of a given array or object is the "X" and which is the "Y".
// Usually this is 0 for X and 1 for Y, but might be used as 'x' for x and 'y' for Y.
/* harmony default export */ __webpack_exports__["a"] = ({
  drawRect: function drawRect(pos, size, ctx, style) {
    ctx.strokeStyle = style.color;
    ctx.fillStyle = style.color;
    ctx.lineWidth = style.lineWidth || 1;
    ctx.beginPath();
    ctx.strokeRect(pos.x, pos.y, size.x, size.y);
  },
  drawPath: function drawPath(path, def, ctx, style) {
    ctx.strokeStyle = style.color;
    ctx.fillStyle = style.color;
    ctx.lineWidth = style.lineWidth;
    ctx.beginPath();
    ctx.moveTo(path[0][def.x], path[0][def.y]);

    for (var j = 1; j < path.length; j++) {
      ctx.lineTo(path[j][def.x], path[j][def.y]);
    }

    ctx.closePath();
    ctx.stroke();
  },
  drawImage: function drawImage(imageData, size, ctx) {
    var canvasData = ctx.getImageData(0, 0, size.x, size.y);
    var data = canvasData.data;
    var canvasDataPos = data.length;
    var imageDataPos = imageData.length;

    if (canvasDataPos / imageDataPos !== 4) {
      return false;
    }

    while (imageDataPos--) {
      var value = imageData[imageDataPos];
      data[--canvasDataPos] = 255;
      data[--canvasDataPos] = value;
      data[--canvasDataPos] = value;
      data[--canvasDataPos] = value;
    }

    ctx.putImageData(canvasData, 0, 0);
    return true;
  }
});

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

var baseMerge = __webpack_require__(92),
    createAssigner = __webpack_require__(147);
/**
 * This method is like `_.assign` except that it recursively merges own and
 * inherited enumerable string keyed properties of source objects into the
 * destination object. Source properties that resolve to `undefined` are
 * skipped if a destination value exists. Array and plain object properties
 * are merged recursively. Other objects and value types are overridden by
 * assignment. Source objects are applied from left to right. Subsequent
 * sources overwrite property assignments of previous sources.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 0.5.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @example
 *
 * var object = {
 *   'a': [{ 'b': 2 }, { 'd': 4 }]
 * };
 *
 * var other = {
 *   'a': [{ 'c': 3 }, { 'e': 5 }]
 * };
 *
 * _.merge(object, other);
 * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
 */


var merge = createAssigner(function (object, source, srcIndex) {
  baseMerge(object, source, srcIndex);
});
module.exports = merge;

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

var freeGlobal = __webpack_require__(46);
/** Detect free variable `self`. */


var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
/** Used as a reference to the global object. */

var root = freeGlobal || freeSelf || Function('return this')();
module.exports = root;

/***/ }),
/* 18 */
/***/ (function(module, exports) {

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

module.exports = isObjectLike;

/***/ }),
/* 19 */
/***/ (function(module, exports) {

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    module.exports = _typeof = function _typeof(obj) {
      return typeof obj;
    };

    module.exports["default"] = module.exports, module.exports.__esModule = true;
  } else {
    module.exports = _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };

    module.exports["default"] = module.exports, module.exports.__esModule = true;
  }

  return _typeof(obj);
}

module.exports = _typeof;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),
/* 20 */
/***/ (function(module, exports) {

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

module.exports = _asyncToGenerator;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),
/* 21 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * http://www.codeproject.com/Tips/407172/Connected-Component-Labeling-and-Vectorization
 */
var Tracer = {
  searchDirections: [[0, 1], [1, 1], [1, 0], [1, -1], [0, -1], [-1, -1], [-1, 0], [-1, 1]],
  create: function create(imageWrapper, labelWrapper) {
    var imageData = imageWrapper.data;
    var labelData = labelWrapper.data;
    var searchDirections = this.searchDirections;
    var width = imageWrapper.size.x;
    var pos;

    function _trace(current, color, label, edgelabel) {
      var i;
      var y;
      var x;

      for (i = 0; i < 7; i++) {
        y = current.cy + searchDirections[current.dir][0];
        x = current.cx + searchDirections[current.dir][1];
        pos = y * width + x;

        if (imageData[pos] === color && (labelData[pos] === 0 || labelData[pos] === label)) {
          labelData[pos] = label;
          current.cy = y;
          current.cx = x;
          return true;
        }

        if (labelData[pos] === 0) {
          labelData[pos] = edgelabel;
        }

        current.dir = (current.dir + 1) % 8;
      }

      return false;
    }

    function vertex2D(x, y, dir) {
      return {
        dir: dir,
        x: x,
        y: y,
        next: null,
        prev: null
      };
    }

    function _contourTracing(sy, sx, label, color, edgelabel) {
      var Fv = null;
      var Cv;
      var P;
      var ldir;
      var current = {
        cx: sx,
        cy: sy,
        dir: 0
      };

      if (_trace(current, color, label, edgelabel)) {
        Fv = vertex2D(sx, sy, current.dir);
        Cv = Fv;
        ldir = current.dir;
        P = vertex2D(current.cx, current.cy, 0);
        P.prev = Cv;
        Cv.next = P;
        P.next = null;
        Cv = P;

        do {
          current.dir = (current.dir + 6) % 8;

          _trace(current, color, label, edgelabel);

          if (ldir !== current.dir) {
            Cv.dir = current.dir;
            P = vertex2D(current.cx, current.cy, 0);
            P.prev = Cv;
            Cv.next = P;
            P.next = null;
            Cv = P;
          } else {
            Cv.dir = ldir;
            Cv.x = current.cx;
            Cv.y = current.cy;
          }

          ldir = current.dir;
        } while (current.cx !== sx || current.cy !== sy);

        Fv.prev = Cv.prev;
        Cv.prev.next = Fv;
      }

      return Fv;
    }

    return {
      trace: function trace(current, color, label, edgelabel) {
        return _trace(current, color, label, edgelabel);
      },
      contourTracing: function contourTracing(sy, sx, label, color, edgelabel) {
        return _contourTracing(sy, sx, label, color, edgelabel);
      }
    };
  }
};
/* harmony default export */ __webpack_exports__["a"] = (Tracer);

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(27),
    getRawTag = __webpack_require__(105),
    objectToString = __webpack_require__(106);
/** `Object#toString` result references. */


var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';
/** Built-in value references. */

var symToStringTag = Symbol ? Symbol.toStringTag : undefined;
/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */

function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }

  return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
}

module.exports = baseGetTag;

/***/ }),
/* 23 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/* harmony import */ var gl_vec2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7);
/* harmony import */ var gl_vec2__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(gl_vec2__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var gl_mat2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(35);
/* harmony import */ var gl_mat2__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(gl_mat2__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _common_image_wrapper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(9);
/* harmony import */ var _common_cv_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(10);
/* harmony import */ var _common_array_helper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(8);
/* harmony import */ var _common_image_debug__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(15);
/* harmony import */ var _rasterizer__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(87);
/* harmony import */ var _tracer__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(21);
/* harmony import */ var _skeletonizer__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(88);










var _config;

var _currentImageWrapper;

var _skelImageWrapper;

var _subImageWrapper;

var _labelImageWrapper;

var _patchGrid;

var _patchLabelGrid;

var _imageToPatchGrid;

var _binaryImageWrapper;

var _patchSize;

var _canvasContainer = {
  ctx: {
    binary: null
  },
  dom: {
    binary: null
  }
};
var _numPatches = {
  x: 0,
  y: 0
};

var _inputImageWrapper;

var _skeletonizer;

function initBuffers() {
  if (_config.halfSample) {
    _currentImageWrapper = new _common_image_wrapper__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"]({
      // eslint-disable-next-line no-bitwise
      x: _inputImageWrapper.size.x / 2 | 0,
      // eslint-disable-next-line no-bitwise
      y: _inputImageWrapper.size.y / 2 | 0
    });
  } else {
    _currentImageWrapper = _inputImageWrapper;
  }

  _patchSize = Object(_common_cv_utils__WEBPACK_IMPORTED_MODULE_3__["calculatePatchSize"])(_config.patchSize, _currentImageWrapper.size); // eslint-disable-next-line no-bitwise

  _numPatches.x = _currentImageWrapper.size.x / _patchSize.x | 0; // eslint-disable-next-line no-bitwise

  _numPatches.y = _currentImageWrapper.size.y / _patchSize.y | 0;
  _binaryImageWrapper = new _common_image_wrapper__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"](_currentImageWrapper.size, undefined, Uint8Array, false);
  _labelImageWrapper = new _common_image_wrapper__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"](_patchSize, undefined, Array, true);
  var skeletonImageData = new ArrayBuffer(64 * 1024);
  _subImageWrapper = new _common_image_wrapper__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"](_patchSize, new Uint8Array(skeletonImageData, 0, _patchSize.x * _patchSize.y));
  _skelImageWrapper = new _common_image_wrapper__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"](_patchSize, new Uint8Array(skeletonImageData, _patchSize.x * _patchSize.y * 3, _patchSize.x * _patchSize.y), undefined, true);
  _skeletonizer = Object(_skeletonizer__WEBPACK_IMPORTED_MODULE_8__[/* default */ "a"])(typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : global, {
    size: _patchSize.x
  }, skeletonImageData);
  _imageToPatchGrid = new _common_image_wrapper__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"]({
    // eslint-disable-next-line no-bitwise
    x: _currentImageWrapper.size.x / _subImageWrapper.size.x | 0,
    // eslint-disable-next-line no-bitwise
    y: _currentImageWrapper.size.y / _subImageWrapper.size.y | 0
  }, undefined, Array, true);
  _patchGrid = new _common_image_wrapper__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"](_imageToPatchGrid.size, undefined, undefined, true);
  _patchLabelGrid = new _common_image_wrapper__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"](_imageToPatchGrid.size, undefined, Int32Array, true);
}

function initCanvas() {
  if (_config.useWorker || typeof document === 'undefined') {
    return;
  }

  _canvasContainer.dom.binary = document.createElement('canvas');
  _canvasContainer.dom.binary.className = 'binaryBuffer';

  if (false) {}

  _canvasContainer.ctx.binary = _canvasContainer.dom.binary.getContext('2d');
  _canvasContainer.dom.binary.width = _binaryImageWrapper.size.x;
  _canvasContainer.dom.binary.height = _binaryImageWrapper.size.y;
}
/**
 * Creates a bounding box which encloses all the given patches
 * @returns {Array} The minimal bounding box
 */


function boxFromPatches(patches) {
  var overAvg;
  var i;
  var j;
  var patch;
  var transMat;
  var minx = _binaryImageWrapper.size.x;
  var miny = _binaryImageWrapper.size.y;
  var maxx = -_binaryImageWrapper.size.x;
  var maxy = -_binaryImageWrapper.size.y;
  var box;
  var scale; // draw all patches which are to be taken into consideration

  overAvg = 0;

  for (i = 0; i < patches.length; i++) {
    patch = patches[i];
    overAvg += patch.rad;

    if (false) {}
  }

  overAvg /= patches.length;
  overAvg = (overAvg * 180 / Math.PI + 90) % 180 - 90;

  if (overAvg < 0) {
    overAvg += 180;
  }

  overAvg = (180 - overAvg) * Math.PI / 180;
  transMat = gl_mat2__WEBPACK_IMPORTED_MODULE_1__["copy"](gl_mat2__WEBPACK_IMPORTED_MODULE_1__["create"](), [Math.cos(overAvg), Math.sin(overAvg), -Math.sin(overAvg), Math.cos(overAvg)]); // iterate over patches and rotate by angle

  for (i = 0; i < patches.length; i++) {
    patch = patches[i];

    for (j = 0; j < 4; j++) {
      gl_vec2__WEBPACK_IMPORTED_MODULE_0__["transformMat2"](patch.box[j], patch.box[j], transMat);
    }

    if (false) {}
  } // find bounding box


  for (i = 0; i < patches.length; i++) {
    patch = patches[i];

    for (j = 0; j < 4; j++) {
      if (patch.box[j][0] < minx) {
        minx = patch.box[j][0];
      }

      if (patch.box[j][0] > maxx) {
        maxx = patch.box[j][0];
      }

      if (patch.box[j][1] < miny) {
        miny = patch.box[j][1];
      }

      if (patch.box[j][1] > maxy) {
        maxy = patch.box[j][1];
      }
    }
  }

  box = [[minx, miny], [maxx, miny], [maxx, maxy], [minx, maxy]];

  if (false) {}

  scale = _config.halfSample ? 2 : 1; // reverse rotation;

  transMat = gl_mat2__WEBPACK_IMPORTED_MODULE_1__["invert"](transMat, transMat);

  for (j = 0; j < 4; j++) {
    gl_vec2__WEBPACK_IMPORTED_MODULE_0__["transformMat2"](box[j], box[j], transMat);
  }

  if (false) {}

  for (j = 0; j < 4; j++) {
    gl_vec2__WEBPACK_IMPORTED_MODULE_0__["scale"](box[j], box[j], scale);
  }

  return box;
}
/**
 * Creates a binary image of the current image
 */


function binarizeImage() {
  Object(_common_cv_utils__WEBPACK_IMPORTED_MODULE_3__["otsuThreshold"])(_currentImageWrapper, _binaryImageWrapper);

  _binaryImageWrapper.zeroBorder();

  if (false) {}
}
/**
 * Iterate over the entire image
 * extract patches
 */


function findPatches() {
  var i;
  var j;
  var x;
  var y;
  var moments;
  var patchesFound = [];
  var rasterizer;
  var rasterResult;
  var patch;

  for (i = 0; i < _numPatches.x; i++) {
    for (j = 0; j < _numPatches.y; j++) {
      x = _subImageWrapper.size.x * i;
      y = _subImageWrapper.size.y * j; // seperate parts

      skeletonize(x, y); // Rasterize, find individual bars

      _skelImageWrapper.zeroBorder();

      _common_array_helper__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].init(_labelImageWrapper.data, 0);
      rasterizer = _rasterizer__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"].create(_skelImageWrapper, _labelImageWrapper);
      rasterResult = rasterizer.rasterize(0);

      if (false) {} // calculate moments from the skeletonized patch


      moments = _labelImageWrapper.moments(rasterResult.count); // extract eligible patches

      patchesFound = patchesFound.concat(describePatch(moments, [i, j], x, y));
    }
  }

  if (false) {}

  return patchesFound;
}
/**
 * Finds those connected areas which contain at least 6 patches
 * and returns them ordered DESC by the number of contained patches
 * @param {Number} maxLabel
 */


function findBiggestConnectedAreas(maxLabel) {
  var i;
  var sum;
  var labelHist = [];
  var topLabels = [];

  for (i = 0; i < maxLabel; i++) {
    labelHist.push(0);
  }

  sum = _patchLabelGrid.data.length;

  while (sum--) {
    if (_patchLabelGrid.data[sum] > 0) {
      labelHist[_patchLabelGrid.data[sum] - 1]++;
    }
  }

  labelHist = labelHist.map(function (val, idx) {
    return {
      val: val,
      label: idx + 1
    };
  });
  labelHist.sort(function (a, b) {
    return b.val - a.val;
  }); // extract top areas with at least 6 patches present

  topLabels = labelHist.filter(function (el) {
    return el.val >= 5;
  });
  return topLabels;
}
/**
 *
 */


function findBoxes(topLabels, maxLabel) {
  var i;
  var j;
  var sum;
  var patches = [];
  var patch;
  var box;
  var boxes = [];
  var hsv = [0, 1, 1];
  var rgb = [0, 0, 0];

  for (i = 0; i < topLabels.length; i++) {
    sum = _patchLabelGrid.data.length;
    patches.length = 0;

    while (sum--) {
      if (_patchLabelGrid.data[sum] === topLabels[i].label) {
        patch = _imageToPatchGrid.data[sum];
        patches.push(patch);
      }
    }

    box = boxFromPatches(patches);

    if (box) {
      boxes.push(box); // draw patch-labels if requested

      if (false) {}
    }
  }

  return boxes;
}
/**
 * Find similar moments (via cluster)
 * @param {Object} moments
 */


function similarMoments(moments) {
  var clusters = Object(_common_cv_utils__WEBPACK_IMPORTED_MODULE_3__["cluster"])(moments, 0.90);
  var topCluster = Object(_common_cv_utils__WEBPACK_IMPORTED_MODULE_3__["topGeneric"])(clusters, 1, function (e) {
    return e.getPoints().length;
  });
  var points = [];
  var result = [];

  if (topCluster.length === 1) {
    points = topCluster[0].item.getPoints();

    for (var i = 0; i < points.length; i++) {
      result.push(points[i].point);
    }
  }

  return result;
}

function skeletonize(x, y) {
  _binaryImageWrapper.subImageAsCopy(_subImageWrapper, Object(_common_cv_utils__WEBPACK_IMPORTED_MODULE_3__["imageRef"])(x, y));

  _skeletonizer.skeletonize(); // Show skeleton if requested


  if (false) {}
}
/**
 * Extracts and describes those patches which seem to contain a barcode pattern
 * @param {Array} moments
 * @param {Object} patchPos,
 * @param {Number} x
 * @param {Number} y
 * @returns {Array} list of patches
 */


function describePatch(moments, patchPos, x, y) {
  var k;
  var avg;
  var eligibleMoments = [];
  var matchingMoments;
  var patch;
  var patchesFound = [];
  var minComponentWeight = Math.ceil(_patchSize.x / 3);

  if (moments.length >= 2) {
    // only collect moments which's area covers at least minComponentWeight pixels.
    for (k = 0; k < moments.length; k++) {
      if (moments[k].m00 > minComponentWeight) {
        eligibleMoments.push(moments[k]);
      }
    } // if at least 2 moments are found which have at least minComponentWeights covered


    if (eligibleMoments.length >= 2) {
      matchingMoments = similarMoments(eligibleMoments);
      avg = 0; // determine the similarity of the moments

      for (k = 0; k < matchingMoments.length; k++) {
        avg += matchingMoments[k].rad;
      } // Only two of the moments are allowed not to fit into the equation
      // add the patch to the set


      if (matchingMoments.length > 1 && matchingMoments.length >= eligibleMoments.length / 4 * 3 && matchingMoments.length > moments.length / 4) {
        avg /= matchingMoments.length;
        patch = {
          index: patchPos[1] * _numPatches.x + patchPos[0],
          pos: {
            x: x,
            y: y
          },
          box: [gl_vec2__WEBPACK_IMPORTED_MODULE_0__["clone"]([x, y]), gl_vec2__WEBPACK_IMPORTED_MODULE_0__["clone"]([x + _subImageWrapper.size.x, y]), gl_vec2__WEBPACK_IMPORTED_MODULE_0__["clone"]([x + _subImageWrapper.size.x, y + _subImageWrapper.size.y]), gl_vec2__WEBPACK_IMPORTED_MODULE_0__["clone"]([x, y + _subImageWrapper.size.y])],
          moments: matchingMoments,
          rad: avg,
          vec: gl_vec2__WEBPACK_IMPORTED_MODULE_0__["clone"]([Math.cos(avg), Math.sin(avg)])
        };
        patchesFound.push(patch);
      }
    }
  }

  return patchesFound;
}
/**
 * finds patches which are connected and share the same orientation
 * @param {Object} patchesFound
 */


function rasterizeAngularSimilarity(patchesFound) {
  var label = 0;
  var threshold = 0.95;
  var currIdx = 0;
  var j;
  var patch;
  var hsv = [0, 1, 1];
  var rgb = [0, 0, 0];

  function notYetProcessed() {
    var i;

    for (i = 0; i < _patchLabelGrid.data.length; i++) {
      if (_patchLabelGrid.data[i] === 0 && _patchGrid.data[i] === 1) {
        return i;
      }
    }

    return _patchLabelGrid.length;
  }

  function trace(currentIdx) {
    var x;
    var y;
    var currentPatch;
    var idx;
    var dir;
    var current = {
      x: currentIdx % _patchLabelGrid.size.x,
      y: currentIdx / _patchLabelGrid.size.x | 0
    };
    var similarity;

    if (currentIdx < _patchLabelGrid.data.length) {
      currentPatch = _imageToPatchGrid.data[currentIdx]; // assign label

      _patchLabelGrid.data[currentIdx] = label;

      for (dir = 0; dir < _tracer__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].searchDirections.length; dir++) {
        y = current.y + _tracer__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].searchDirections[dir][0];
        x = current.x + _tracer__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].searchDirections[dir][1];
        idx = y * _patchLabelGrid.size.x + x; // continue if patch empty

        if (_patchGrid.data[idx] === 0) {
          _patchLabelGrid.data[idx] = Number.MAX_VALUE; // eslint-disable-next-line no-continue

          continue;
        }

        if (_patchLabelGrid.data[idx] === 0) {
          similarity = Math.abs(gl_vec2__WEBPACK_IMPORTED_MODULE_0__["dot"](_imageToPatchGrid.data[idx].vec, currentPatch.vec));

          if (similarity > threshold) {
            trace(idx);
          }
        }
      }
    }
  } // prepare for finding the right patches


  _common_array_helper__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].init(_patchGrid.data, 0);
  _common_array_helper__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].init(_patchLabelGrid.data, 0);
  _common_array_helper__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].init(_imageToPatchGrid.data, null);

  for (j = 0; j < patchesFound.length; j++) {
    patch = patchesFound[j];
    _imageToPatchGrid.data[patch.index] = patch;
    _patchGrid.data[patch.index] = 1;
  } // rasterize the patches found to determine area


  _patchGrid.zeroBorder(); // eslint-disable-next-line no-cond-assign


  while ((currIdx = notYetProcessed()) < _patchLabelGrid.data.length) {
    label++;
    trace(currIdx);
  } // draw patch-labels if requested


  if (false) {}

  return label;
}

/* harmony default export */ __webpack_exports__["a"] = ({
  init: function init(inputImageWrapper, config) {
    _config = config;
    _inputImageWrapper = inputImageWrapper;
    initBuffers();
    initCanvas();
  },
  locate: function locate() {
    if (_config.halfSample) {
      Object(_common_cv_utils__WEBPACK_IMPORTED_MODULE_3__["halfSample"])(_inputImageWrapper, _currentImageWrapper);
    }

    binarizeImage();
    var patchesFound = findPatches(); // return unless 5% or more patches are found

    if (patchesFound.length < _numPatches.x * _numPatches.y * 0.05) {
      return null;
    } // rasterrize area by comparing angular similarity;


    var maxLabel = rasterizeAngularSimilarity(patchesFound);

    if (maxLabel < 1) {
      return null;
    } // search for area with the most patches (biggest connected area)


    var topLabels = findBiggestConnectedAreas(maxLabel);

    if (topLabels.length === 0) {
      return null;
    }

    var boxes = findBoxes(topLabels, maxLabel);
    return boxes;
  },
  checkImageConstraints: function checkImageConstraints(inputStream, config) {
    var patchSize;
    var width = inputStream.getWidth();
    var height = inputStream.getHeight();
    var thisHalfSample = config.halfSample ? 0.5 : 1;
    var area; // calculate width and height based on area

    if (inputStream.getConfig().area) {
      area = Object(_common_cv_utils__WEBPACK_IMPORTED_MODULE_3__["computeImageArea"])(width, height, inputStream.getConfig().area);
      inputStream.setTopRight({
        x: area.sx,
        y: area.sy
      });
      inputStream.setCanvasSize({
        x: width,
        y: height
      });
      width = area.sw;
      height = area.sh;
    }

    var size = {
      x: Math.floor(width * thisHalfSample),
      y: Math.floor(height * thisHalfSample)
    };
    patchSize = Object(_common_cv_utils__WEBPACK_IMPORTED_MODULE_3__["calculatePatchSize"])(config.patchSize, size);

    if (false) {}

    inputStream.setWidth(Math.floor(Math.floor(size.x / patchSize.x) * (1 / thisHalfSample) * patchSize.x));
    inputStream.setHeight(Math.floor(Math.floor(size.y / patchSize.y) * (1 / thisHalfSample) * patchSize.y));

    if (inputStream.getWidth() % patchSize.x === 0 && inputStream.getHeight() % patchSize.y === 0) {
      return true;
    }

    throw new Error("Image dimensions do not comply with the current settings: Width (".concat(width, " )and height (").concat(height, ") must a multiple of ").concat(patchSize.x));
  }
});
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(47)))

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

var listCacheClear = __webpack_require__(94),
    listCacheDelete = __webpack_require__(95),
    listCacheGet = __webpack_require__(96),
    listCacheHas = __webpack_require__(97),
    listCacheSet = __webpack_require__(98);
/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */


function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;
  this.clear();

  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
} // Add methods to `ListCache`.


ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;
module.exports = ListCache;

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

var eq = __webpack_require__(26);
/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */


function assocIndexOf(array, key) {
  var length = array.length;

  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }

  return -1;
}

module.exports = assocIndexOf;

/***/ }),
/* 26 */
/***/ (function(module, exports) {

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || value !== value && other !== other;
}

module.exports = eq;

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__(17);
/** Built-in value references. */


var Symbol = root.Symbol;
module.exports = Symbol;

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(36);
/* Built-in method references that are verified to be native. */


var nativeCreate = getNative(Object, 'create');
module.exports = nativeCreate;

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

var isKeyable = __webpack_require__(119);
/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */


function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
}

module.exports = getMapData;

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

var baseIsArguments = __webpack_require__(134),
    isObjectLike = __webpack_require__(18);
/** Used for built-in method references. */


var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/** Built-in value references. */

var propertyIsEnumerable = objectProto.propertyIsEnumerable;
/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */

var isArguments = baseIsArguments(function () {
  return arguments;
}()) ? baseIsArguments : function (value) {
  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
};
module.exports = isArguments;

/***/ }),
/* 31 */
/***/ (function(module, exports) {

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;
/** Used to detect unsigned integer values. */

var reIsUint = /^(?:0|[1-9]\d*)$/;
/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */

function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length && (type == 'number' || type != 'symbol' && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
}

module.exports = isIndex;

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

var isArray = __webpack_require__(14),
    isKey = __webpack_require__(234),
    stringToPath = __webpack_require__(235),
    toString = __webpack_require__(238);
/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @param {Object} [object] The object to query keys on.
 * @returns {Array} Returns the cast property path array.
 */


function castPath(value, object) {
  if (isArray(value)) {
    return value;
  }

  return isKey(value, object) ? [value] : stringToPath(toString(value));
}

module.exports = castPath;

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

var arrayWithHoles = __webpack_require__(155);

var iterableToArrayLimit = __webpack_require__(156);

var unsupportedIterableToArray = __webpack_require__(61);

var nonIterableRest = __webpack_require__(157);

function _slicedToArray(arr, i) {
  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();
}

module.exports = _slicedToArray;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

var arrayWithoutHoles = __webpack_require__(226);

var iterableToArray = __webpack_require__(227);

var unsupportedIterableToArray = __webpack_require__(61);

var nonIterableSpread = __webpack_require__(228);

function _toConsumableArray(arr) {
  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();
}

module.exports = _toConsumableArray;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {
  determinant: __webpack_require__(253),
  transpose: __webpack_require__(254),
  multiply: __webpack_require__(255),
  identity: __webpack_require__(256),
  adjoint: __webpack_require__(257),
  rotate: __webpack_require__(258),
  invert: __webpack_require__(259),
  create: __webpack_require__(260),
  scale: __webpack_require__(261),
  copy: __webpack_require__(262),
  frob: __webpack_require__(263),
  ldu: __webpack_require__(264)
};

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

var baseIsNative = __webpack_require__(104),
    getValue = __webpack_require__(110);
/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */


function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

module.exports = getNative;

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(22),
    isObject = __webpack_require__(13);
/** `Object#toString` result references. */


var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';
/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */

function isFunction(value) {
  if (!isObject(value)) {
    return false;
  } // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.


  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

module.exports = isFunction;

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

var defineProperty = __webpack_require__(50);
/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */


function baseAssignValue(object, key, value) {
  if (key == '__proto__' && defineProperty) {
    defineProperty(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

module.exports = baseAssignValue;

/***/ }),
/* 39 */
/***/ (function(module, exports) {

module.exports = function (module) {
  if (!module.webpackPolyfill) {
    module.deprecate = function () {};

    module.paths = []; // module.parent = undefined by default

    if (!module.children) module.children = [];
    Object.defineProperty(module, "loaded", {
      enumerable: true,
      get: function () {
        return module.l;
      }
    });
    Object.defineProperty(module, "id", {
      enumerable: true,
      get: function () {
        return module.i;
      }
    });
    module.webpackPolyfill = 1;
  }

  return module;
};

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

var isFunction = __webpack_require__(37),
    isLength = __webpack_require__(41);
/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */


function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

module.exports = isArrayLike;

/***/ }),
/* 41 */
/***/ (function(module, exports) {

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;
/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */

function isLength(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

module.exports = isLength;

/***/ }),
/* 42 */
/***/ (function(module, exports) {

function _setPrototypeOf(o, p) {
  module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  module.exports["default"] = module.exports, module.exports.__esModule = true;
  return _setPrototypeOf(o, p);
}

module.exports = _setPrototypeOf;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(22),
    isObjectLike = __webpack_require__(18);
/** `Object#toString` result references. */


var symbolTag = '[object Symbol]';
/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */

function isSymbol(value) {
  return typeof value == 'symbol' || isObjectLike(value) && baseGetTag(value) == symbolTag;
}

module.exports = isSymbol;

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

var isSymbol = __webpack_require__(43);
/** Used as references for various `Number` constants. */


var INFINITY = 1 / 0;
/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */

function toKey(value) {
  if (typeof value == 'string' || isSymbol(value)) {
    return value;
  }

  var result = value + '';
  return result == '0' && 1 / value == -INFINITY ? '-0' : result;
}

module.exports = toKey;

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(36),
    root = __webpack_require__(17);
/* Built-in method references that are verified to be native. */


var Map = getNative(root, 'Map');
module.exports = Map;

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;
module.exports = freeGlobal;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(47)))

/***/ }),
/* 47 */
/***/ (function(module, exports) {

var g; // This works in non-strict mode

g = function () {
  return this;
}();

try {
  // This works if eval is allowed (see CSP)
  g = g || new Function("return this")();
} catch (e) {
  // This works if the window reference is available
  if (typeof window === "object") g = window;
} // g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}


module.exports = g;

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

var mapCacheClear = __webpack_require__(111),
    mapCacheDelete = __webpack_require__(118),
    mapCacheGet = __webpack_require__(120),
    mapCacheHas = __webpack_require__(121),
    mapCacheSet = __webpack_require__(122);
/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */


function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;
  this.clear();

  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
} // Add methods to `MapCache`.


MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;
module.exports = MapCache;

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

var baseAssignValue = __webpack_require__(38),
    eq = __webpack_require__(26);
/**
 * This function is like `assignValue` except that it doesn't assign
 * `undefined` values.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */


function assignMergeValue(object, key, value) {
  if (value !== undefined && !eq(object[key], value) || value === undefined && !(key in object)) {
    baseAssignValue(object, key, value);
  }
}

module.exports = assignMergeValue;

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(36);

var defineProperty = function () {
  try {
    var func = getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}();

module.exports = defineProperty;

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

var overArg = __webpack_require__(133);
/** Built-in value references. */


var getPrototype = overArg(Object.getPrototypeOf, Object);
module.exports = getPrototype;

/***/ }),
/* 52 */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var objectProto = Object.prototype;
/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */

function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = typeof Ctor == 'function' && Ctor.prototype || objectProto;
  return value === proto;
}

module.exports = isPrototype;

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var root = __webpack_require__(17),
    stubFalse = __webpack_require__(136);
/** Detect free variable `exports`. */


var freeExports =  true && exports && !exports.nodeType && exports;
/** Detect free variable `module`. */

var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;
/** Detect the popular CommonJS extension `module.exports`. */

var moduleExports = freeModule && freeModule.exports === freeExports;
/** Built-in value references. */

var Buffer = moduleExports ? root.Buffer : undefined;
/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;
/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */

var isBuffer = nativeIsBuffer || stubFalse;
module.exports = isBuffer;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(39)(module)))

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

var baseIsTypedArray = __webpack_require__(138),
    baseUnary = __webpack_require__(139),
    nodeUtil = __webpack_require__(140);
/* Node.js helper references. */


var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */

var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
module.exports = isTypedArray;

/***/ }),
/* 55 */
/***/ (function(module, exports) {

/**
 * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function safeGet(object, key) {
  if (key === 'constructor' && typeof object[key] === 'function') {
    return;
  }

  if (key == '__proto__') {
    return;
  }

  return object[key];
}

module.exports = safeGet;

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

var baseAssignValue = __webpack_require__(38),
    eq = __webpack_require__(26);
/** Used for built-in method references. */


var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */

function assignValue(object, key, value) {
  var objValue = object[key];

  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined && !(key in object)) {
    baseAssignValue(object, key, value);
  }
}

module.exports = assignValue;

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

var arrayLikeKeys = __webpack_require__(143),
    baseKeysIn = __webpack_require__(145),
    isArrayLike = __webpack_require__(40);
/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */


function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}

module.exports = keysIn;

/***/ }),
/* 58 */
/***/ (function(module, exports) {

/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

module.exports = identity;

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

var apply = __webpack_require__(149);
/* Built-in method references for those with the same name as other `lodash` methods. */


var nativeMax = Math.max;
/**
 * A specialized version of `baseRest` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */

function overRest(func, start, transform) {
  start = nativeMax(start === undefined ? func.length - 1 : start, 0);
  return function () {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }

    index = -1;
    var otherArgs = Array(start + 1);

    while (++index < start) {
      otherArgs[index] = args[index];
    }

    otherArgs[start] = transform(array);
    return apply(func, this, otherArgs);
  };
}

module.exports = overRest;

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

var baseSetToString = __webpack_require__(150),
    shortOut = __webpack_require__(152);
/**
 * Sets the `toString` method of `func` to return `string`.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */


var setToString = shortOut(baseSetToString);
module.exports = setToString;

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

var arrayLikeToArray = __webpack_require__(62);

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);
}

module.exports = _unsupportedIterableToArray;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),
/* 62 */
/***/ (function(module, exports) {

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

module.exports = _arrayLikeToArray;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),
/* 63 */
/***/ (function(module, exports) {

module.exports = 0.000001;

/***/ }),
/* 64 */
/***/ (function(module, exports) {

module.exports = create;
/**
 * Creates a new, empty vec2
 *
 * @returns {vec2} a new 2D vector
 */

function create() {
  var out = new Float32Array(2);
  out[0] = 0;
  out[1] = 0;
  return out;
}

/***/ }),
/* 65 */
/***/ (function(module, exports) {

module.exports = subtract;
/**
 * Subtracts vector b from vector a
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  return out;
}

/***/ }),
/* 66 */
/***/ (function(module, exports) {

module.exports = multiply;
/**
 * Multiplies two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */

function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  return out;
}

/***/ }),
/* 67 */
/***/ (function(module, exports) {

module.exports = divide;
/**
 * Divides two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */

function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  return out;
}

/***/ }),
/* 68 */
/***/ (function(module, exports) {

module.exports = distance;
/**
 * Calculates the euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} distance between a and b
 */

function distance(a, b) {
  var x = b[0] - a[0],
      y = b[1] - a[1];
  return Math.sqrt(x * x + y * y);
}

/***/ }),
/* 69 */
/***/ (function(module, exports) {

module.exports = squaredDistance;
/**
 * Calculates the squared euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} squared distance between a and b
 */

function squaredDistance(a, b) {
  var x = b[0] - a[0],
      y = b[1] - a[1];
  return x * x + y * y;
}

/***/ }),
/* 70 */
/***/ (function(module, exports) {

module.exports = length;
/**
 * Calculates the length of a vec2
 *
 * @param {vec2} a vector to calculate length of
 * @returns {Number} length of a
 */

function length(a) {
  var x = a[0],
      y = a[1];
  return Math.sqrt(x * x + y * y);
}

/***/ }),
/* 71 */
/***/ (function(module, exports) {

module.exports = squaredLength;
/**
 * Calculates the squared length of a vec2
 *
 * @param {vec2} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */

function squaredLength(a) {
  var x = a[0],
      y = a[1];
  return x * x + y * y;
}

/***/ }),
/* 72 */
/***/ (function(module, exports) {

module.exports = 0.000001;

/***/ }),
/* 73 */
/***/ (function(module, exports) {

module.exports = create;
/**
 * Creates a new, empty vec3
 *
 * @returns {vec3} a new 3D vector
 */

function create() {
  var out = new Float32Array(3);
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  return out;
}

/***/ }),
/* 74 */
/***/ (function(module, exports) {

module.exports = fromValues;
/**
 * Creates a new vec3 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} a new 3D vector
 */

function fromValues(x, y, z) {
  var out = new Float32Array(3);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}

/***/ }),
/* 75 */
/***/ (function(module, exports) {

module.exports = normalize;
/**
 * Normalize a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to normalize
 * @returns {vec3} out
 */

function normalize(out, a) {
  var x = a[0],
      y = a[1],
      z = a[2];
  var len = x * x + y * y + z * z;

  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
    out[0] = a[0] * len;
    out[1] = a[1] * len;
    out[2] = a[2] * len;
  }

  return out;
}

/***/ }),
/* 76 */
/***/ (function(module, exports) {

module.exports = dot;
/**
 * Calculates the dot product of two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} dot product of a and b
 */

function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}

/***/ }),
/* 77 */
/***/ (function(module, exports) {

module.exports = subtract;
/**
 * Subtracts vector b from vector a
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  return out;
}

/***/ }),
/* 78 */
/***/ (function(module, exports) {

module.exports = multiply;
/**
 * Multiplies two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */

function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  return out;
}

/***/ }),
/* 79 */
/***/ (function(module, exports) {

module.exports = divide;
/**
 * Divides two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */

function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  return out;
}

/***/ }),
/* 80 */
/***/ (function(module, exports) {

module.exports = distance;
/**
 * Calculates the euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} distance between a and b
 */

function distance(a, b) {
  var x = b[0] - a[0],
      y = b[1] - a[1],
      z = b[2] - a[2];
  return Math.sqrt(x * x + y * y + z * z);
}

/***/ }),
/* 81 */
/***/ (function(module, exports) {

module.exports = squaredDistance;
/**
 * Calculates the squared euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} squared distance between a and b
 */

function squaredDistance(a, b) {
  var x = b[0] - a[0],
      y = b[1] - a[1],
      z = b[2] - a[2];
  return x * x + y * y + z * z;
}

/***/ }),
/* 82 */
/***/ (function(module, exports) {

module.exports = length;
/**
 * Calculates the length of a vec3
 *
 * @param {vec3} a vector to calculate length of
 * @returns {Number} length of a
 */

function length(a) {
  var x = a[0],
      y = a[1],
      z = a[2];
  return Math.sqrt(x * x + y * y + z * z);
}

/***/ }),
/* 83 */
/***/ (function(module, exports) {

module.exports = squaredLength;
/**
 * Calculates the squared length of a vec3
 *
 * @param {vec3} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */

function squaredLength(a) {
  var x = a[0],
      y = a[1],
      z = a[2];
  return x * x + y * y + z * z;
}

/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {
  EPSILON: __webpack_require__(72),
  create: __webpack_require__(73),
  clone: __webpack_require__(193),
  angle: __webpack_require__(194),
  fromValues: __webpack_require__(74),
  copy: __webpack_require__(195),
  set: __webpack_require__(196),
  equals: __webpack_require__(197),
  exactEquals: __webpack_require__(198),
  add: __webpack_require__(199),
  subtract: __webpack_require__(77),
  sub: __webpack_require__(200),
  multiply: __webpack_require__(78),
  mul: __webpack_require__(201),
  divide: __webpack_require__(79),
  div: __webpack_require__(202),
  min: __webpack_require__(203),
  max: __webpack_require__(204),
  floor: __webpack_require__(205),
  ceil: __webpack_require__(206),
  round: __webpack_require__(207),
  scale: __webpack_require__(208),
  scaleAndAdd: __webpack_require__(209),
  distance: __webpack_require__(80),
  dist: __webpack_require__(210),
  squaredDistance: __webpack_require__(81),
  sqrDist: __webpack_require__(211),
  length: __webpack_require__(82),
  len: __webpack_require__(212),
  squaredLength: __webpack_require__(83),
  sqrLen: __webpack_require__(213),
  negate: __webpack_require__(214),
  inverse: __webpack_require__(215),
  normalize: __webpack_require__(75),
  dot: __webpack_require__(76),
  cross: __webpack_require__(216),
  lerp: __webpack_require__(217),
  random: __webpack_require__(218),
  transformMat4: __webpack_require__(219),
  transformMat3: __webpack_require__(220),
  transformQuat: __webpack_require__(221),
  rotateX: __webpack_require__(222),
  rotateY: __webpack_require__(223),
  rotateZ: __webpack_require__(224),
  forEach: __webpack_require__(225)
};

/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

var basePick = __webpack_require__(231),
    flatRest = __webpack_require__(245);
/**
 * Creates an object composed of the picked `object` properties.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The source object.
 * @param {...(string|string[])} [paths] The property paths to pick.
 * @returns {Object} Returns the new object.
 * @example
 *
 * var object = { 'a': 1, 'b': '2', 'c': 3 };
 *
 * _.pick(object, ['a', 'c']);
 * // => { 'a': 1, 'c': 3 }
 */


var pick = flatRest(function (object, paths) {
  return object == null ? {} : basePick(object, paths);
});
module.exports = pick;

/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

var getPrototypeOf = __webpack_require__(2);

var setPrototypeOf = __webpack_require__(42);

var isNativeFunction = __webpack_require__(250);

var construct = __webpack_require__(251);

function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;

  module.exports = _wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !isNativeFunction(Class)) return Class;

    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }

    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);

      _cache.set(Class, Wrapper);
    }

    function Wrapper() {
      return construct(Class, arguments, getPrototypeOf(this).constructor);
    }

    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return setPrototypeOf(Wrapper, Class);
  };

  module.exports["default"] = module.exports, module.exports.__esModule = true;
  return _wrapNativeSuper(Class);
}

module.exports = _wrapNativeSuper;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),
/* 87 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _tracer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(21);

/**
 * http://www.codeproject.com/Tips/407172/Connected-Component-Labeling-and-Vectorization
 */

var Rasterizer = {
  createContour2D: function createContour2D() {
    return {
      dir: null,
      index: null,
      firstVertex: null,
      insideContours: null,
      nextpeer: null,
      prevpeer: null
    };
  },
  CONTOUR_DIR: {
    CW_DIR: 0,
    CCW_DIR: 1,
    UNKNOWN_DIR: 2
  },
  DIR: {
    OUTSIDE_EDGE: -32767,
    INSIDE_EDGE: -32766
  },
  create: function create(imageWrapper, labelWrapper) {
    var imageData = imageWrapper.data;
    var labelData = labelWrapper.data;
    var width = imageWrapper.size.x;
    var height = imageWrapper.size.y;
    var tracer = _tracer__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].create(imageWrapper, labelWrapper);
    return {
      rasterize: function rasterize(depthlabel) {
        var color;
        var bc;
        var lc;
        var labelindex;
        var cx;
        var cy;
        var colorMap = [];
        var vertex;
        var p;
        var cc;
        var sc;
        var pos;
        var connectedCount = 0;
        var i;

        for (i = 0; i < 400; i++) {
          colorMap[i] = 0;
        }

        colorMap[0] = imageData[0];
        cc = null;

        for (cy = 1; cy < height - 1; cy++) {
          labelindex = 0;
          bc = colorMap[0];

          for (cx = 1; cx < width - 1; cx++) {
            pos = cy * width + cx;

            if (labelData[pos] === 0) {
              color = imageData[pos];

              if (color !== bc) {
                if (labelindex === 0) {
                  lc = connectedCount + 1;
                  colorMap[lc] = color;
                  bc = color;
                  vertex = tracer.contourTracing(cy, cx, lc, color, Rasterizer.DIR.OUTSIDE_EDGE);

                  if (vertex !== null) {
                    connectedCount++;
                    labelindex = lc;
                    p = Rasterizer.createContour2D();
                    p.dir = Rasterizer.CONTOUR_DIR.CW_DIR;
                    p.index = labelindex;
                    p.firstVertex = vertex;
                    p.nextpeer = cc;
                    p.insideContours = null;

                    if (cc !== null) {
                      cc.prevpeer = p;
                    }

                    cc = p;
                  }
                } else {
                  vertex = tracer.contourTracing(cy, cx, Rasterizer.DIR.INSIDE_EDGE, color, labelindex);

                  if (vertex !== null) {
                    p = Rasterizer.createContour2D();
                    p.firstVertex = vertex;
                    p.insideContours = null;

                    if (depthlabel === 0) {
                      p.dir = Rasterizer.CONTOUR_DIR.CCW_DIR;
                    } else {
                      p.dir = Rasterizer.CONTOUR_DIR.CW_DIR;
                    }

                    p.index = depthlabel;
                    sc = cc;

                    while (sc !== null && sc.index !== labelindex) {
                      sc = sc.nextpeer;
                    }

                    if (sc !== null) {
                      p.nextpeer = sc.insideContours;

                      if (sc.insideContours !== null) {
                        sc.insideContours.prevpeer = p;
                      }

                      sc.insideContours = p;
                    }
                  }
                }
              } else {
                labelData[pos] = labelindex;
              }
            } else if (labelData[pos] === Rasterizer.DIR.OUTSIDE_EDGE || labelData[pos] === Rasterizer.DIR.INSIDE_EDGE) {
              labelindex = 0;

              if (labelData[pos] === Rasterizer.DIR.INSIDE_EDGE) {
                bc = imageData[pos];
              } else {
                bc = colorMap[0];
              }
            } else {
              labelindex = labelData[pos];
              bc = colorMap[labelindex];
            }
          }
        }

        sc = cc;

        while (sc !== null) {
          sc.index = depthlabel;
          sc = sc.nextpeer;
        }

        return {
          cc: cc,
          count: connectedCount
        };
      },
      debug: {
        drawContour: function drawContour(canvas, firstContour) {
          var ctx = canvas.getContext('2d');
          var pq = firstContour;
          var iq;
          var q;
          var p;
          ctx.strokeStyle = 'red';
          ctx.fillStyle = 'red';
          ctx.lineWidth = 1;

          if (pq !== null) {
            iq = pq.insideContours;
          } else {
            iq = null;
          }

          while (pq !== null) {
            if (iq !== null) {
              q = iq;
              iq = iq.nextpeer;
            } else {
              q = pq;
              pq = pq.nextpeer;

              if (pq !== null) {
                iq = pq.insideContours;
              } else {
                iq = null;
              }
            }

            switch (q.dir) {
              case Rasterizer.CONTOUR_DIR.CW_DIR:
                ctx.strokeStyle = 'red';
                break;

              case Rasterizer.CONTOUR_DIR.CCW_DIR:
                ctx.strokeStyle = 'blue';
                break;

              case Rasterizer.CONTOUR_DIR.UNKNOWN_DIR:
                ctx.strokeStyle = 'green';
                break;
            }

            p = q.firstVertex;
            ctx.beginPath();
            ctx.moveTo(p.x, p.y);

            do {
              p = p.next;
              ctx.lineTo(p.x, p.y);
            } while (p !== q.firstVertex);

            ctx.stroke();
          }
        }
      }
    };
  }
};
/* harmony default export */ __webpack_exports__["a"] = (Rasterizer);

/***/ }),
/* 88 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* eslint-disable no-param-reassign */

/* eslint-disable no-bitwise */

/* eslint-disable eqeqeq */

/* @preserve ASM BEGIN */
function Skeletonizer(stdlib, foreign, buffer) {
  'use asm';

  var images = new stdlib.Uint8Array(buffer);
  var size = foreign.size | 0;
  var imul = stdlib.Math.imul;

  function erode(inImagePtr, outImagePtr) {
    inImagePtr |= 0;
    outImagePtr |= 0;
    var v = 0;
    var u = 0;
    var sum = 0;
    var yStart1 = 0;
    var yStart2 = 0;
    var xStart1 = 0;
    var xStart2 = 0;
    var offset = 0;

    for (v = 1; (v | 0) < (size - 1 | 0); v = v + 1 | 0) {
      offset = offset + size | 0;

      for (u = 1; (u | 0) < (size - 1 | 0); u = u + 1 | 0) {
        yStart1 = offset - size | 0;
        yStart2 = offset + size | 0;
        xStart1 = u - 1 | 0;
        xStart2 = u + 1 | 0;
        sum = (images[inImagePtr + yStart1 + xStart1 | 0] | 0) + (images[inImagePtr + yStart1 + xStart2 | 0] | 0) + (images[inImagePtr + offset + u | 0] | 0) + (images[inImagePtr + yStart2 + xStart1 | 0] | 0) + (images[inImagePtr + yStart2 + xStart2 | 0] | 0) | 0;

        if ((sum | 0) == (5 | 0)) {
          images[outImagePtr + offset + u | 0] = 1;
        } else {
          images[outImagePtr + offset + u | 0] = 0;
        }
      }
    }
  }

  function subtract(aImagePtr, bImagePtr, outImagePtr) {
    aImagePtr |= 0;
    bImagePtr |= 0;
    outImagePtr |= 0;
    var length = 0;
    length = imul(size, size) | 0;

    while ((length | 0) > 0) {
      length = length - 1 | 0;
      images[outImagePtr + length | 0] = (images[aImagePtr + length | 0] | 0) - (images[bImagePtr + length | 0] | 0) | 0;
    }
  }

  function bitwiseOr(aImagePtr, bImagePtr, outImagePtr) {
    aImagePtr |= 0;
    bImagePtr |= 0;
    outImagePtr |= 0;
    var length = 0;
    length = imul(size, size) | 0;

    while ((length | 0) > 0) {
      length = length - 1 | 0;
      images[outImagePtr + length | 0] = images[aImagePtr + length | 0] | 0 | (images[bImagePtr + length | 0] | 0) | 0;
    }
  }

  function countNonZero(imagePtr) {
    imagePtr |= 0;
    var sum = 0;
    var length = 0;
    length = imul(size, size) | 0;

    while ((length | 0) > 0) {
      length = length - 1 | 0;
      sum = (sum | 0) + (images[imagePtr + length | 0] | 0) | 0;
    }

    return sum | 0;
  }

  function init(imagePtr, value) {
    imagePtr |= 0;
    value |= 0;
    var length = 0;
    length = imul(size, size) | 0;

    while ((length | 0) > 0) {
      length = length - 1 | 0;
      images[imagePtr + length | 0] = value;
    }
  }

  function dilate(inImagePtr, outImagePtr) {
    inImagePtr |= 0;
    outImagePtr |= 0;
    var v = 0;
    var u = 0;
    var sum = 0;
    var yStart1 = 0;
    var yStart2 = 0;
    var xStart1 = 0;
    var xStart2 = 0;
    var offset = 0;

    for (v = 1; (v | 0) < (size - 1 | 0); v = v + 1 | 0) {
      offset = offset + size | 0;

      for (u = 1; (u | 0) < (size - 1 | 0); u = u + 1 | 0) {
        yStart1 = offset - size | 0;
        yStart2 = offset + size | 0;
        xStart1 = u - 1 | 0;
        xStart2 = u + 1 | 0;
        sum = (images[inImagePtr + yStart1 + xStart1 | 0] | 0) + (images[inImagePtr + yStart1 + xStart2 | 0] | 0) + (images[inImagePtr + offset + u | 0] | 0) + (images[inImagePtr + yStart2 + xStart1 | 0] | 0) + (images[inImagePtr + yStart2 + xStart2 | 0] | 0) | 0;

        if ((sum | 0) > (0 | 0)) {
          images[outImagePtr + offset + u | 0] = 1;
        } else {
          images[outImagePtr + offset + u | 0] = 0;
        }
      }
    }
  }

  function memcpy(srcImagePtr, dstImagePtr) {
    srcImagePtr |= 0;
    dstImagePtr |= 0;
    var length = 0;
    length = imul(size, size) | 0;

    while ((length | 0) > 0) {
      length = length - 1 | 0;
      images[dstImagePtr + length | 0] = images[srcImagePtr + length | 0] | 0;
    }
  }

  function zeroBorder(imagePtr) {
    imagePtr |= 0;
    var x = 0;
    var y = 0;

    for (x = 0; (x | 0) < (size - 1 | 0); x = x + 1 | 0) {
      images[imagePtr + x | 0] = 0;
      images[imagePtr + y | 0] = 0;
      y = y + size - 1 | 0;
      images[imagePtr + y | 0] = 0;
      y = y + 1 | 0;
    }

    for (x = 0; (x | 0) < (size | 0); x = x + 1 | 0) {
      images[imagePtr + y | 0] = 0;
      y = y + 1 | 0;
    }
  }

  function skeletonize() {
    var subImagePtr = 0;
    var erodedImagePtr = 0;
    var tempImagePtr = 0;
    var skelImagePtr = 0;
    var sum = 0;
    var done = 0;
    erodedImagePtr = imul(size, size) | 0;
    tempImagePtr = erodedImagePtr + erodedImagePtr | 0;
    skelImagePtr = tempImagePtr + erodedImagePtr | 0; // init skel-image

    init(skelImagePtr, 0);
    zeroBorder(subImagePtr);

    do {
      erode(subImagePtr, erodedImagePtr);
      dilate(erodedImagePtr, tempImagePtr);
      subtract(subImagePtr, tempImagePtr, tempImagePtr);
      bitwiseOr(skelImagePtr, tempImagePtr, skelImagePtr);
      memcpy(erodedImagePtr, subImagePtr);
      sum = countNonZero(subImagePtr) | 0;
      done = (sum | 0) == 0 | 0;
    } while (!done);
  }

  return {
    skeletonize: skeletonize
  };
}
/* @preserve ASM END */


/* harmony default export */ __webpack_exports__["a"] = (Skeletonizer);
/* eslint-enable eqeqeq */

/***/ }),
/* 89 */
/***/ (function(module, exports) {

module.exports = require("get-pixels");

/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

// NOTE FOR ANYONE IN HERE IN THE FUTURE: This module is used when the module is built for use in Node.
// Webpack.config.js explicitly REPLACES this module with the file called frame_grabber_browser when it is packing the Browser distribution.
var CVUtils = __webpack_require__(10);

var Ndarray = __webpack_require__(265);

var Interp2D = __webpack_require__(266).d2;

var FrameGrabber = {};

FrameGrabber.create = function (inputStream, canvas) {
  var _that = {};

  var _videoSize = CVUtils.imageRef(inputStream.getRealWidth(), inputStream.getRealHeight());

  var _canvasSize = inputStream.getCanvasSize();

  var _size = CVUtils.imageRef(inputStream.getWidth(), inputStream.getHeight());

  var _topRight = inputStream.getTopRight();

  var _data = new Uint8Array(_size.x * _size.y);

  var _grayData = new Uint8Array(_videoSize.x * _videoSize.y);

  var _canvasData = new Uint8Array(_canvasSize.x * _canvasSize.y);
  /* eslint-disable new-cap */


  var _grayImageArray = Ndarray(_grayData, [_videoSize.y, _videoSize.x]).transpose(1, 0);

  var _canvasImageArray = Ndarray(_canvasData, [_canvasSize.y, _canvasSize.x]).transpose(1, 0);

  var _targetImageArray = _canvasImageArray.hi(_topRight.x + _size.x, _topRight.y + _size.y).lo(_topRight.x, _topRight.y);

  var _stepSizeX = _videoSize.x / _canvasSize.x;

  var _stepSizeY = _videoSize.y / _canvasSize.y;

  if (false) {}
  /**
   * Uses the given array as frame-buffer
   */


  _that.attachData = function (data) {
    _data = data;
  };
  /**
   * Returns the used frame-buffer
   */


  _that.getData = function () {
    return _data;
  };
  /**
   * Fetches a frame from the input-stream and puts into the frame-buffer.
   * The image-data is converted to gray-scale and then half-sampled if configured.
   */


  _that.grab = function () {
    var frame = inputStream.getFrame();

    if (frame) {
      this.scaleAndCrop(frame);
      return true;
    }

    return false;
  }; // eslint-disable-next-line


  _that.scaleAndCrop = function (frame) {
    // 1. compute full-sized gray image
    CVUtils.computeGray(frame.data, _grayData); // 2. interpolate

    for (var y = 0; y < _canvasSize.y; y++) {
      for (var x = 0; x < _canvasSize.x; x++) {
        // eslint-disable-next-line no-bitwise
        _canvasImageArray.set(x, y, Interp2D(_grayImageArray, x * _stepSizeX, y * _stepSizeY) | 0);
      }
    } // targetImageArray must be equal to targetSize


    if (_targetImageArray.shape[0] !== _size.x || _targetImageArray.shape[1] !== _size.y) {
      throw new Error('Shapes do not match!');
    } // 3. crop


    for (var _y = 0; _y < _size.y; _y++) {
      for (var _x = 0; _x < _size.x; _x++) {
        _data[_y * _size.x + _x] = _targetImageArray.get(_x, _y);
      }
    }
  };

  _that.getSize = function () {
    return _size;
  };

  return _that;
};

module.exports = FrameGrabber;

/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(267);


/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

var Stack = __webpack_require__(93),
    assignMergeValue = __webpack_require__(49),
    baseFor = __webpack_require__(123),
    baseMergeDeep = __webpack_require__(125),
    isObject = __webpack_require__(13),
    keysIn = __webpack_require__(57),
    safeGet = __webpack_require__(55);
/**
 * The base implementation of `_.merge` without support for multiple sources.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} [customizer] The function to customize merged values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */


function baseMerge(object, source, srcIndex, customizer, stack) {
  if (object === source) {
    return;
  }

  baseFor(source, function (srcValue, key) {
    stack || (stack = new Stack());

    if (isObject(srcValue)) {
      baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
    } else {
      var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + '', object, source, stack) : undefined;

      if (newValue === undefined) {
        newValue = srcValue;
      }

      assignMergeValue(object, key, newValue);
    }
  }, keysIn);
}

module.exports = baseMerge;

/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

var ListCache = __webpack_require__(24),
    stackClear = __webpack_require__(99),
    stackDelete = __webpack_require__(100),
    stackGet = __webpack_require__(101),
    stackHas = __webpack_require__(102),
    stackSet = __webpack_require__(103);
/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */


function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
} // Add methods to `Stack`.


Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;
module.exports = Stack;

/***/ }),
/* 94 */
/***/ (function(module, exports) {

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

module.exports = listCacheClear;

/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(25);
/** Used for built-in method references. */


var arrayProto = Array.prototype;
/** Built-in value references. */

var splice = arrayProto.splice;
/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */

function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }

  var lastIndex = data.length - 1;

  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }

  --this.size;
  return true;
}

module.exports = listCacheDelete;

/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(25);
/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */


function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);
  return index < 0 ? undefined : data[index][1];
}

module.exports = listCacheGet;

/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(25);
/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */


function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

module.exports = listCacheHas;

/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(25);
/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */


function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }

  return this;
}

module.exports = listCacheSet;

/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

var ListCache = __webpack_require__(24);
/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */


function stackClear() {
  this.__data__ = new ListCache();
  this.size = 0;
}

module.exports = stackClear;

/***/ }),
/* 100 */
/***/ (function(module, exports) {

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);
  this.size = data.size;
  return result;
}

module.exports = stackDelete;

/***/ }),
/* 101 */
/***/ (function(module, exports) {

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

module.exports = stackGet;

/***/ }),
/* 102 */
/***/ (function(module, exports) {

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

module.exports = stackHas;

/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

var ListCache = __webpack_require__(24),
    Map = __webpack_require__(45),
    MapCache = __webpack_require__(48);
/** Used as the size to enable large array optimizations. */


var LARGE_ARRAY_SIZE = 200;
/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */

function stackSet(key, value) {
  var data = this.__data__;

  if (data instanceof ListCache) {
    var pairs = data.__data__;

    if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }

    data = this.__data__ = new MapCache(pairs);
  }

  data.set(key, value);
  this.size = data.size;
  return this;
}

module.exports = stackSet;

/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

var isFunction = __webpack_require__(37),
    isMasked = __webpack_require__(107),
    isObject = __webpack_require__(13),
    toSource = __webpack_require__(109);
/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */


var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
/** Used to detect host constructors (Safari). */

var reIsHostCtor = /^\[object .+?Constructor\]$/;
/** Used for built-in method references. */

var funcProto = Function.prototype,
    objectProto = Object.prototype;
/** Used to resolve the decompiled source of functions. */

var funcToString = funcProto.toString;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/** Used to detect if a method is native. */

var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */

function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }

  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

module.exports = baseIsNative;

/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(27);
/** Used for built-in method references. */


var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */

var nativeObjectToString = objectProto.toString;
/** Built-in value references. */

var symToStringTag = Symbol ? Symbol.toStringTag : undefined;
/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */

function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);

  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }

  return result;
}

module.exports = getRawTag;

/***/ }),
/* 106 */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var objectProto = Object.prototype;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */

var nativeObjectToString = objectProto.toString;
/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */

function objectToString(value) {
  return nativeObjectToString.call(value);
}

module.exports = objectToString;

/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

var coreJsData = __webpack_require__(108);
/** Used to detect methods masquerading as native. */


var maskSrcKey = function () {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? 'Symbol(src)_1.' + uid : '';
}();
/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */


function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}

module.exports = isMasked;

/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__(17);
/** Used to detect overreaching core-js shims. */


var coreJsData = root['__core-js_shared__'];
module.exports = coreJsData;

/***/ }),
/* 109 */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var funcProto = Function.prototype;
/** Used to resolve the decompiled source of functions. */

var funcToString = funcProto.toString;
/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */

function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}

    try {
      return func + '';
    } catch (e) {}
  }

  return '';
}

module.exports = toSource;

/***/ }),
/* 110 */
/***/ (function(module, exports) {

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

module.exports = getValue;

/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

var Hash = __webpack_require__(112),
    ListCache = __webpack_require__(24),
    Map = __webpack_require__(45);
/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */


function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash(),
    'map': new (Map || ListCache)(),
    'string': new Hash()
  };
}

module.exports = mapCacheClear;

/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

var hashClear = __webpack_require__(113),
    hashDelete = __webpack_require__(114),
    hashGet = __webpack_require__(115),
    hashHas = __webpack_require__(116),
    hashSet = __webpack_require__(117);
/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */


function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;
  this.clear();

  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
} // Add methods to `Hash`.


Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;
module.exports = Hash;

/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(28);
/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */


function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}

module.exports = hashClear;

/***/ }),
/* 114 */
/***/ (function(module, exports) {

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = hashDelete;

/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(28);
/** Used to stand-in for `undefined` hash values. */


var HASH_UNDEFINED = '__lodash_hash_undefined__';
/** Used for built-in method references. */

var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */

function hashGet(key) {
  var data = this.__data__;

  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }

  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

module.exports = hashGet;

/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(28);
/** Used for built-in method references. */


var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */

function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
}

module.exports = hashHas;

/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(28);
/** Used to stand-in for `undefined` hash values. */


var HASH_UNDEFINED = '__lodash_hash_undefined__';
/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */

function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
  return this;
}

module.exports = hashSet;

/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(29);
/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */


function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = mapCacheDelete;

/***/ }),
/* 119 */
/***/ (function(module, exports) {

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
}

module.exports = isKeyable;

/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(29);
/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */


function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

module.exports = mapCacheGet;

/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(29);
/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */


function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

module.exports = mapCacheHas;

/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(29);
/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */


function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;
  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

module.exports = mapCacheSet;

/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

var createBaseFor = __webpack_require__(124);
/**
 * The base implementation of `baseForOwn` which iterates over `object`
 * properties returned by `keysFunc` and invokes `iteratee` for each property.
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */


var baseFor = createBaseFor();
module.exports = baseFor;

/***/ }),
/* 124 */
/***/ (function(module, exports) {

/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseFor(fromRight) {
  return function (object, iteratee, keysFunc) {
    var index = -1,
        iterable = Object(object),
        props = keysFunc(object),
        length = props.length;

    while (length--) {
      var key = props[fromRight ? length : ++index];

      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }

    return object;
  };
}

module.exports = createBaseFor;

/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

var assignMergeValue = __webpack_require__(49),
    cloneBuffer = __webpack_require__(126),
    cloneTypedArray = __webpack_require__(127),
    copyArray = __webpack_require__(130),
    initCloneObject = __webpack_require__(131),
    isArguments = __webpack_require__(30),
    isArray = __webpack_require__(14),
    isArrayLikeObject = __webpack_require__(135),
    isBuffer = __webpack_require__(53),
    isFunction = __webpack_require__(37),
    isObject = __webpack_require__(13),
    isPlainObject = __webpack_require__(137),
    isTypedArray = __webpack_require__(54),
    safeGet = __webpack_require__(55),
    toPlainObject = __webpack_require__(141);
/**
 * A specialized version of `baseMerge` for arrays and objects which performs
 * deep merges and tracks traversed objects enabling objects with circular
 * references to be merged.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {string} key The key of the value to merge.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} mergeFunc The function to merge values.
 * @param {Function} [customizer] The function to customize assigned values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */


function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
  var objValue = safeGet(object, key),
      srcValue = safeGet(source, key),
      stacked = stack.get(srcValue);

  if (stacked) {
    assignMergeValue(object, key, stacked);
    return;
  }

  var newValue = customizer ? customizer(objValue, srcValue, key + '', object, source, stack) : undefined;
  var isCommon = newValue === undefined;

  if (isCommon) {
    var isArr = isArray(srcValue),
        isBuff = !isArr && isBuffer(srcValue),
        isTyped = !isArr && !isBuff && isTypedArray(srcValue);
    newValue = srcValue;

    if (isArr || isBuff || isTyped) {
      if (isArray(objValue)) {
        newValue = objValue;
      } else if (isArrayLikeObject(objValue)) {
        newValue = copyArray(objValue);
      } else if (isBuff) {
        isCommon = false;
        newValue = cloneBuffer(srcValue, true);
      } else if (isTyped) {
        isCommon = false;
        newValue = cloneTypedArray(srcValue, true);
      } else {
        newValue = [];
      }
    } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
      newValue = objValue;

      if (isArguments(objValue)) {
        newValue = toPlainObject(objValue);
      } else if (!isObject(objValue) || isFunction(objValue)) {
        newValue = initCloneObject(srcValue);
      }
    } else {
      isCommon = false;
    }
  }

  if (isCommon) {
    // Recursively merge objects and arrays (susceptible to call stack limits).
    stack.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
    stack['delete'](srcValue);
  }

  assignMergeValue(object, key, newValue);
}

module.exports = baseMergeDeep;

/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var root = __webpack_require__(17);
/** Detect free variable `exports`. */


var freeExports =  true && exports && !exports.nodeType && exports;
/** Detect free variable `module`. */

var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;
/** Detect the popular CommonJS extension `module.exports`. */

var moduleExports = freeModule && freeModule.exports === freeExports;
/** Built-in value references. */

var Buffer = moduleExports ? root.Buffer : undefined,
    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;
/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */

function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }

  var length = buffer.length,
      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
  buffer.copy(result);
  return result;
}

module.exports = cloneBuffer;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(39)(module)))

/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

var cloneArrayBuffer = __webpack_require__(128);
/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */


function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

module.exports = cloneTypedArray;

/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

var Uint8Array = __webpack_require__(129);
/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */


function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
  return result;
}

module.exports = cloneArrayBuffer;

/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__(17);
/** Built-in value references. */


var Uint8Array = root.Uint8Array;
module.exports = Uint8Array;

/***/ }),
/* 130 */
/***/ (function(module, exports) {

/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;
  array || (array = Array(length));

  while (++index < length) {
    array[index] = source[index];
  }

  return array;
}

module.exports = copyArray;

/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

var baseCreate = __webpack_require__(132),
    getPrototype = __webpack_require__(51),
    isPrototype = __webpack_require__(52);
/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */


function initCloneObject(object) {
  return typeof object.constructor == 'function' && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
}

module.exports = initCloneObject;

/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(13);
/** Built-in value references. */


var objectCreate = Object.create;
/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} proto The object to inherit from.
 * @returns {Object} Returns the new object.
 */

var baseCreate = function () {
  function object() {}

  return function (proto) {
    if (!isObject(proto)) {
      return {};
    }

    if (objectCreate) {
      return objectCreate(proto);
    }

    object.prototype = proto;
    var result = new object();
    object.prototype = undefined;
    return result;
  };
}();

module.exports = baseCreate;

/***/ }),
/* 133 */
/***/ (function(module, exports) {

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function (arg) {
    return func(transform(arg));
  };
}

module.exports = overArg;

/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(22),
    isObjectLike = __webpack_require__(18);
/** `Object#toString` result references. */


var argsTag = '[object Arguments]';
/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */

function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

module.exports = baseIsArguments;

/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

var isArrayLike = __webpack_require__(40),
    isObjectLike = __webpack_require__(18);
/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */


function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

module.exports = isArrayLikeObject;

/***/ }),
/* 136 */
/***/ (function(module, exports) {

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = stubFalse;

/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(22),
    getPrototype = __webpack_require__(51),
    isObjectLike = __webpack_require__(18);
/** `Object#toString` result references. */


var objectTag = '[object Object]';
/** Used for built-in method references. */

var funcProto = Function.prototype,
    objectProto = Object.prototype;
/** Used to resolve the decompiled source of functions. */

var funcToString = funcProto.toString;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/** Used to infer the `Object` constructor. */

var objectCtorString = funcToString.call(Object);
/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */

function isPlainObject(value) {
  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
    return false;
  }

  var proto = getPrototype(value);

  if (proto === null) {
    return true;
  }

  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
}

module.exports = isPlainObject;

/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(22),
    isLength = __webpack_require__(41),
    isObjectLike = __webpack_require__(18);
/** `Object#toString` result references. */


var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';
var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';
/** Used to identify `toStringTag` values of typed arrays. */

var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */

function baseIsTypedArray(value) {
  return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

module.exports = baseIsTypedArray;

/***/ }),
/* 139 */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function (value) {
    return func(value);
  };
}

module.exports = baseUnary;

/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var freeGlobal = __webpack_require__(46);
/** Detect free variable `exports`. */


var freeExports =  true && exports && !exports.nodeType && exports;
/** Detect free variable `module`. */

var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;
/** Detect the popular CommonJS extension `module.exports`. */

var moduleExports = freeModule && freeModule.exports === freeExports;
/** Detect free variable `process` from Node.js. */

var freeProcess = moduleExports && freeGlobal.process;
/** Used to access faster Node.js helpers. */

var nodeUtil = function () {
  try {
    // Use `util.types` for Node.js 10+.
    var types = freeModule && freeModule.require && freeModule.require('util').types;

    if (types) {
      return types;
    } // Legacy `process.binding('util')` for Node.js < 10.


    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}();

module.exports = nodeUtil;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(39)(module)))

/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

var copyObject = __webpack_require__(142),
    keysIn = __webpack_require__(57);
/**
 * Converts `value` to a plain object flattening inherited enumerable string
 * keyed properties of `value` to own properties of the plain object.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {Object} Returns the converted plain object.
 * @example
 *
 * function Foo() {
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.assign({ 'a': 1 }, new Foo);
 * // => { 'a': 1, 'b': 2 }
 *
 * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
 * // => { 'a': 1, 'b': 2, 'c': 3 }
 */


function toPlainObject(value) {
  return copyObject(value, keysIn(value));
}

module.exports = toPlainObject;

/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

var assignValue = __webpack_require__(56),
    baseAssignValue = __webpack_require__(38);
/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */


function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});
  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];
    var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined;

    if (newValue === undefined) {
      newValue = source[key];
    }

    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }

  return object;
}

module.exports = copyObject;

/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

var baseTimes = __webpack_require__(144),
    isArguments = __webpack_require__(30),
    isArray = __webpack_require__(14),
    isBuffer = __webpack_require__(53),
    isIndex = __webpack_require__(31),
    isTypedArray = __webpack_require__(54);
/** Used for built-in method references. */


var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */

function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && ( // Safari 9 has enumerable `arguments.length` in strict mode.
    key == 'length' || isBuff && (key == 'offset' || key == 'parent') || isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset') || // Skip index properties.
    isIndex(key, length)))) {
      result.push(key);
    }
  }

  return result;
}

module.exports = arrayLikeKeys;

/***/ }),
/* 144 */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }

  return result;
}

module.exports = baseTimes;

/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(13),
    isPrototype = __webpack_require__(52),
    nativeKeysIn = __webpack_require__(146);
/** Used for built-in method references. */


var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */

function baseKeysIn(object) {
  if (!isObject(object)) {
    return nativeKeysIn(object);
  }

  var isProto = isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }

  return result;
}

module.exports = baseKeysIn;

/***/ }),
/* 146 */
/***/ (function(module, exports) {

/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];

  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }

  return result;
}

module.exports = nativeKeysIn;

/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

var baseRest = __webpack_require__(148),
    isIterateeCall = __webpack_require__(153);
/**
 * Creates a function like `_.assign`.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @returns {Function} Returns the new assigner function.
 */


function createAssigner(assigner) {
  return baseRest(function (object, sources) {
    var index = -1,
        length = sources.length,
        customizer = length > 1 ? sources[length - 1] : undefined,
        guard = length > 2 ? sources[2] : undefined;
    customizer = assigner.length > 3 && typeof customizer == 'function' ? (length--, customizer) : undefined;

    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? undefined : customizer;
      length = 1;
    }

    object = Object(object);

    while (++index < length) {
      var source = sources[index];

      if (source) {
        assigner(object, source, index, customizer);
      }
    }

    return object;
  });
}

module.exports = createAssigner;

/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

var identity = __webpack_require__(58),
    overRest = __webpack_require__(59),
    setToString = __webpack_require__(60);
/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */


function baseRest(func, start) {
  return setToString(overRest(func, start, identity), func + '');
}

module.exports = baseRest;

/***/ }),
/* 149 */
/***/ (function(module, exports) {

/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0:
      return func.call(thisArg);

    case 1:
      return func.call(thisArg, args[0]);

    case 2:
      return func.call(thisArg, args[0], args[1]);

    case 3:
      return func.call(thisArg, args[0], args[1], args[2]);
  }

  return func.apply(thisArg, args);
}

module.exports = apply;

/***/ }),
/* 150 */
/***/ (function(module, exports, __webpack_require__) {

var constant = __webpack_require__(151),
    defineProperty = __webpack_require__(50),
    identity = __webpack_require__(58);
/**
 * The base implementation of `setToString` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */


var baseSetToString = !defineProperty ? identity : function (func, string) {
  return defineProperty(func, 'toString', {
    'configurable': true,
    'enumerable': false,
    'value': constant(string),
    'writable': true
  });
};
module.exports = baseSetToString;

/***/ }),
/* 151 */
/***/ (function(module, exports) {

/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */
function constant(value) {
  return function () {
    return value;
  };
}

module.exports = constant;

/***/ }),
/* 152 */
/***/ (function(module, exports) {

/** Used to detect hot functions by number of calls within a span of milliseconds. */
var HOT_COUNT = 800,
    HOT_SPAN = 16;
/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeNow = Date.now;
/**
 * Creates a function that'll short out and invoke `identity` instead
 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
 * milliseconds.
 *
 * @private
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new shortable function.
 */

function shortOut(func) {
  var count = 0,
      lastCalled = 0;
  return function () {
    var stamp = nativeNow(),
        remaining = HOT_SPAN - (stamp - lastCalled);
    lastCalled = stamp;

    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }

    return func.apply(undefined, arguments);
  };
}

module.exports = shortOut;

/***/ }),
/* 153 */
/***/ (function(module, exports, __webpack_require__) {

var eq = __webpack_require__(26),
    isArrayLike = __webpack_require__(40),
    isIndex = __webpack_require__(31),
    isObject = __webpack_require__(13);
/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */


function isIterateeCall(value, index, object) {
  if (!isObject(object)) {
    return false;
  }

  var type = typeof index;

  if (type == 'number' ? isArrayLike(object) && isIndex(index, object.length) : type == 'string' && index in object) {
    return eq(object[index], value);
  }

  return false;
}

module.exports = isIterateeCall;

/***/ }),
/* 154 */
/***/ (function(module, exports) {

/*
 * typedefs.js
 * Normalizes browser-specific prefixes and provide some basic polyfills
 */
if (typeof window !== 'undefined') {
  if (!window.requestAnimationFrame) {
    window.requestAnimationFrame = function () {
      return window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (
      /* function FrameRequestCallback */
      callback) {
        window.setTimeout(callback, 1000 / 60);
      };
    }();
  }
}

if (typeof Math.imul !== 'function') {
  /* eslint-disable no-bitwise */
  Math.imul = function (a, b) {
    var ah = a >>> 16 & 0xffff;
    var al = a & 0xffff;
    var bh = b >>> 16 & 0xffff;
    var bl = b & 0xffff; // the shift by 0 fixes the sign on the high part
    // the final |0 converts the unsigned value into a signed value

    return al * bl + (ah * bl + al * bh << 16 >>> 0) | 0;
  };
  /* eslint-enable no-bitwise */

}

if (typeof Object.assign !== 'function') {
  Object.assign = function (target) {
    // .length of function is 2
    'use strict';

    if (target === null) {
      // TypeError if undefined or null
      throw new TypeError('Cannot convert undefined or null to object');
    }

    var to = Object(target);

    for (var index = 1; index < arguments.length; index++) {
      // eslint-disable-next-line prefer-rest-params
      var nextSource = arguments[index];

      if (nextSource !== null) {
        // Skip over if undefined or null
        // eslint-disable-next-line no-restricted-syntax
        for (var nextKey in nextSource) {
          // Avoid bugs when hasOwnProperty is shadowed
          if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
            to[nextKey] = nextSource[nextKey];
          }
        }
      }
    }

    return to;
  };
}

/***/ }),
/* 155 */
/***/ (function(module, exports) {

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

module.exports = _arrayWithHoles;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),
/* 156 */
/***/ (function(module, exports) {

function _iterableToArrayLimit(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;

  var _s, _e;

  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

module.exports = _iterableToArrayLimit;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),
/* 157 */
/***/ (function(module, exports) {

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

module.exports = _nonIterableRest;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),
/* 158 */
/***/ (function(module, exports) {

module.exports = clone;
/**
 * Creates a new vec2 initialized with values from an existing vector
 *
 * @param {vec2} a vector to clone
 * @returns {vec2} a new 2D vector
 */

function clone(a) {
  var out = new Float32Array(2);
  out[0] = a[0];
  out[1] = a[1];
  return out;
}

/***/ }),
/* 159 */
/***/ (function(module, exports) {

module.exports = fromValues;
/**
 * Creates a new vec2 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} a new 2D vector
 */

function fromValues(x, y) {
  var out = new Float32Array(2);
  out[0] = x;
  out[1] = y;
  return out;
}

/***/ }),
/* 160 */
/***/ (function(module, exports) {

module.exports = copy;
/**
 * Copy the values from one vec2 to another
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the source vector
 * @returns {vec2} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  return out;
}

/***/ }),
/* 161 */
/***/ (function(module, exports) {

module.exports = set;
/**
 * Set the components of a vec2 to the given values
 *
 * @param {vec2} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} out
 */

function set(out, x, y) {
  out[0] = x;
  out[1] = y;
  return out;
}

/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = equals;

var EPSILON = __webpack_require__(63);
/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec2} a The first vector.
 * @param {vec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */


function equals(a, b) {
  var a0 = a[0];
  var a1 = a[1];
  var b0 = b[0];
  var b1 = b[1];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1));
}

/***/ }),
/* 163 */
/***/ (function(module, exports) {

module.exports = exactEquals;
/**
 * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)
 *
 * @param {vec2} a The first vector.
 * @param {vec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1];
}

/***/ }),
/* 164 */
/***/ (function(module, exports) {

module.exports = add;
/**
 * Adds two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  return out;
}

/***/ }),
/* 165 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(65);

/***/ }),
/* 166 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(66);

/***/ }),
/* 167 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(67);

/***/ }),
/* 168 */
/***/ (function(module, exports) {

module.exports = inverse;
/**
 * Returns the inverse of the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to invert
 * @returns {vec2} out
 */

function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  return out;
}

/***/ }),
/* 169 */
/***/ (function(module, exports) {

module.exports = min;
/**
 * Returns the minimum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */

function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  return out;
}

/***/ }),
/* 170 */
/***/ (function(module, exports) {

module.exports = max;
/**
 * Returns the maximum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */

function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  return out;
}

/***/ }),
/* 171 */
/***/ (function(module, exports) {

module.exports = rotate;
/**
 * Rotates a vec2 by an angle
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to rotate
 * @param {Number} angle the angle of rotation (in radians)
 * @returns {vec2} out
 */

function rotate(out, a, angle) {
  var c = Math.cos(angle),
      s = Math.sin(angle);
  var x = a[0],
      y = a[1];
  out[0] = x * c - y * s;
  out[1] = x * s + y * c;
  return out;
}

/***/ }),
/* 172 */
/***/ (function(module, exports) {

module.exports = floor;
/**
 * Math.floor the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to floor
 * @returns {vec2} out
 */

function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  return out;
}

/***/ }),
/* 173 */
/***/ (function(module, exports) {

module.exports = ceil;
/**
 * Math.ceil the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to ceil
 * @returns {vec2} out
 */

function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  return out;
}

/***/ }),
/* 174 */
/***/ (function(module, exports) {

module.exports = round;
/**
 * Math.round the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to round
 * @returns {vec2} out
 */

function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  return out;
}

/***/ }),
/* 175 */
/***/ (function(module, exports) {

module.exports = scale;
/**
 * Scales a vec2 by a scalar number
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec2} out
 */

function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  return out;
}

/***/ }),
/* 176 */
/***/ (function(module, exports) {

module.exports = scaleAndAdd;
/**
 * Adds two vec2's after scaling the second operand by a scalar value
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec2} out
 */

function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  return out;
}

/***/ }),
/* 177 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(68);

/***/ }),
/* 178 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(69);

/***/ }),
/* 179 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(70);

/***/ }),
/* 180 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(71);

/***/ }),
/* 181 */
/***/ (function(module, exports) {

module.exports = negate;
/**
 * Negates the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to negate
 * @returns {vec2} out
 */

function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  return out;
}

/***/ }),
/* 182 */
/***/ (function(module, exports) {

module.exports = normalize;
/**
 * Normalize a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to normalize
 * @returns {vec2} out
 */

function normalize(out, a) {
  var x = a[0],
      y = a[1];
  var len = x * x + y * y;

  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
    out[0] = a[0] * len;
    out[1] = a[1] * len;
  }

  return out;
}

/***/ }),
/* 183 */
/***/ (function(module, exports) {

module.exports = dot;
/**
 * Calculates the dot product of two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} dot product of a and b
 */

function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1];
}

/***/ }),
/* 184 */
/***/ (function(module, exports) {

module.exports = cross;
/**
 * Computes the cross product of two vec2's
 * Note that the cross product must by definition produce a 3D vector
 *
 * @param {vec3} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec3} out
 */

function cross(out, a, b) {
  var z = a[0] * b[1] - a[1] * b[0];
  out[0] = out[1] = 0;
  out[2] = z;
  return out;
}

/***/ }),
/* 185 */
/***/ (function(module, exports) {

module.exports = lerp;
/**
 * Performs a linear interpolation between two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec2} out
 */

function lerp(out, a, b, t) {
  var ax = a[0],
      ay = a[1];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  return out;
}

/***/ }),
/* 186 */
/***/ (function(module, exports) {

module.exports = random;
/**
 * Generates a random vector with the given scale
 *
 * @param {vec2} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec2} out
 */

function random(out, scale) {
  scale = scale || 1.0;
  var r = Math.random() * 2.0 * Math.PI;
  out[0] = Math.cos(r) * scale;
  out[1] = Math.sin(r) * scale;
  return out;
}

/***/ }),
/* 187 */
/***/ (function(module, exports) {

module.exports = transformMat2;
/**
 * Transforms the vec2 with a mat2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2} m matrix to transform with
 * @returns {vec2} out
 */

function transformMat2(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[2] * y;
  out[1] = m[1] * x + m[3] * y;
  return out;
}

/***/ }),
/* 188 */
/***/ (function(module, exports) {

module.exports = transformMat2d;
/**
 * Transforms the vec2 with a mat2d
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2d} m matrix to transform with
 * @returns {vec2} out
 */

function transformMat2d(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[2] * y + m[4];
  out[1] = m[1] * x + m[3] * y + m[5];
  return out;
}

/***/ }),
/* 189 */
/***/ (function(module, exports) {

module.exports = transformMat3;
/**
 * Transforms the vec2 with a mat3
 * 3rd vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat3} m matrix to transform with
 * @returns {vec2} out
 */

function transformMat3(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[3] * y + m[6];
  out[1] = m[1] * x + m[4] * y + m[7];
  return out;
}

/***/ }),
/* 190 */
/***/ (function(module, exports) {

module.exports = transformMat4;
/**
 * Transforms the vec2 with a mat4
 * 3rd vector component is implicitly '0'
 * 4th vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec2} out
 */

function transformMat4(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[4] * y + m[12];
  out[1] = m[1] * x + m[5] * y + m[13];
  return out;
}

/***/ }),
/* 191 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = forEach;

var vec = __webpack_require__(64)();
/**
 * Perform some operation over an array of vec2s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */


function forEach(a, stride, offset, count, fn, arg) {
  var i, l;

  if (!stride) {
    stride = 2;
  }

  if (!offset) {
    offset = 0;
  }

  if (count) {
    l = Math.min(count * stride + offset, a.length);
  } else {
    l = a.length;
  }

  for (i = offset; i < l; i += stride) {
    vec[0] = a[i];
    vec[1] = a[i + 1];
    fn(vec, vec, arg);
    a[i] = vec[0];
    a[i + 1] = vec[1];
  }

  return a;
}

/***/ }),
/* 192 */
/***/ (function(module, exports) {

module.exports = limit;
/**
 * Limit the magnitude of this vector to the value used for the `max`
 * parameter.
 *
 * @param  {vec2} the vector to limit
 * @param  {Number} max the maximum magnitude for the vector
 * @returns {vec2} out
 */

function limit(out, a, max) {
  var mSq = a[0] * a[0] + a[1] * a[1];

  if (mSq > max * max) {
    var n = Math.sqrt(mSq);
    out[0] = a[0] / n * max;
    out[1] = a[1] / n * max;
  } else {
    out[0] = a[0];
    out[1] = a[1];
  }

  return out;
}

/***/ }),
/* 193 */
/***/ (function(module, exports) {

module.exports = clone;
/**
 * Creates a new vec3 initialized with values from an existing vector
 *
 * @param {vec3} a vector to clone
 * @returns {vec3} a new 3D vector
 */

function clone(a) {
  var out = new Float32Array(3);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}

/***/ }),
/* 194 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = angle;

var fromValues = __webpack_require__(74);

var normalize = __webpack_require__(75);

var dot = __webpack_require__(76);
/**
 * Get the angle between two 3D vectors
 * @param {vec3} a The first operand
 * @param {vec3} b The second operand
 * @returns {Number} The angle in radians
 */


function angle(a, b) {
  var tempA = fromValues(a[0], a[1], a[2]);
  var tempB = fromValues(b[0], b[1], b[2]);
  normalize(tempA, tempA);
  normalize(tempB, tempB);
  var cosine = dot(tempA, tempB);

  if (cosine > 1.0) {
    return 0;
  } else {
    return Math.acos(cosine);
  }
}

/***/ }),
/* 195 */
/***/ (function(module, exports) {

module.exports = copy;
/**
 * Copy the values from one vec3 to another
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the source vector
 * @returns {vec3} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}

/***/ }),
/* 196 */
/***/ (function(module, exports) {

module.exports = set;
/**
 * Set the components of a vec3 to the given values
 *
 * @param {vec3} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} out
 */

function set(out, x, y, z) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}

/***/ }),
/* 197 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = equals;

var EPSILON = __webpack_require__(72);
/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec3} a The first vector.
 * @param {vec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */


function equals(a, b) {
  var a0 = a[0];
  var a1 = a[1];
  var a2 = a[2];
  var b0 = b[0];
  var b1 = b[1];
  var b2 = b[2];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2));
}

/***/ }),
/* 198 */
/***/ (function(module, exports) {

module.exports = exactEquals;
/**
 * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)
 *
 * @param {vec3} a The first vector.
 * @param {vec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
}

/***/ }),
/* 199 */
/***/ (function(module, exports) {

module.exports = add;
/**
 * Adds two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  return out;
}

/***/ }),
/* 200 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(77);

/***/ }),
/* 201 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(78);

/***/ }),
/* 202 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(79);

/***/ }),
/* 203 */
/***/ (function(module, exports) {

module.exports = min;
/**
 * Returns the minimum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */

function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  return out;
}

/***/ }),
/* 204 */
/***/ (function(module, exports) {

module.exports = max;
/**
 * Returns the maximum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */

function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  return out;
}

/***/ }),
/* 205 */
/***/ (function(module, exports) {

module.exports = floor;
/**
 * Math.floor the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to floor
 * @returns {vec3} out
 */

function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  return out;
}

/***/ }),
/* 206 */
/***/ (function(module, exports) {

module.exports = ceil;
/**
 * Math.ceil the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to ceil
 * @returns {vec3} out
 */

function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  return out;
}

/***/ }),
/* 207 */
/***/ (function(module, exports) {

module.exports = round;
/**
 * Math.round the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to round
 * @returns {vec3} out
 */

function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  return out;
}

/***/ }),
/* 208 */
/***/ (function(module, exports) {

module.exports = scale;
/**
 * Scales a vec3 by a scalar number
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec3} out
 */

function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  return out;
}

/***/ }),
/* 209 */
/***/ (function(module, exports) {

module.exports = scaleAndAdd;
/**
 * Adds two vec3's after scaling the second operand by a scalar value
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec3} out
 */

function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  return out;
}

/***/ }),
/* 210 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(80);

/***/ }),
/* 211 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(81);

/***/ }),
/* 212 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(82);

/***/ }),
/* 213 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(83);

/***/ }),
/* 214 */
/***/ (function(module, exports) {

module.exports = negate;
/**
 * Negates the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to negate
 * @returns {vec3} out
 */

function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  return out;
}

/***/ }),
/* 215 */
/***/ (function(module, exports) {

module.exports = inverse;
/**
 * Returns the inverse of the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to invert
 * @returns {vec3} out
 */

function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  return out;
}

/***/ }),
/* 216 */
/***/ (function(module, exports) {

module.exports = cross;
/**
 * Computes the cross product of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */

function cross(out, a, b) {
  var ax = a[0],
      ay = a[1],
      az = a[2],
      bx = b[0],
      by = b[1],
      bz = b[2];
  out[0] = ay * bz - az * by;
  out[1] = az * bx - ax * bz;
  out[2] = ax * by - ay * bx;
  return out;
}

/***/ }),
/* 217 */
/***/ (function(module, exports) {

module.exports = lerp;
/**
 * Performs a linear interpolation between two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec3} out
 */

function lerp(out, a, b, t) {
  var ax = a[0],
      ay = a[1],
      az = a[2];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  return out;
}

/***/ }),
/* 218 */
/***/ (function(module, exports) {

module.exports = random;
/**
 * Generates a random vector with the given scale
 *
 * @param {vec3} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec3} out
 */

function random(out, scale) {
  scale = scale || 1.0;
  var r = Math.random() * 2.0 * Math.PI;
  var z = Math.random() * 2.0 - 1.0;
  var zScale = Math.sqrt(1.0 - z * z) * scale;
  out[0] = Math.cos(r) * zScale;
  out[1] = Math.sin(r) * zScale;
  out[2] = z * scale;
  return out;
}

/***/ }),
/* 219 */
/***/ (function(module, exports) {

module.exports = transformMat4;
/**
 * Transforms the vec3 with a mat4.
 * 4th vector component is implicitly '1'
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec3} out
 */

function transformMat4(out, a, m) {
  var x = a[0],
      y = a[1],
      z = a[2],
      w = m[3] * x + m[7] * y + m[11] * z + m[15];
  w = w || 1.0;
  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
  return out;
}

/***/ }),
/* 220 */
/***/ (function(module, exports) {

module.exports = transformMat3;
/**
 * Transforms the vec3 with a mat3.
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat4} m the 3x3 matrix to transform with
 * @returns {vec3} out
 */

function transformMat3(out, a, m) {
  var x = a[0],
      y = a[1],
      z = a[2];
  out[0] = x * m[0] + y * m[3] + z * m[6];
  out[1] = x * m[1] + y * m[4] + z * m[7];
  out[2] = x * m[2] + y * m[5] + z * m[8];
  return out;
}

/***/ }),
/* 221 */
/***/ (function(module, exports) {

module.exports = transformQuat;
/**
 * Transforms the vec3 with a quat
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec3} out
 */

function transformQuat(out, a, q) {
  // benchmarks: http://jsperf.com/quaternion-transform-vec3-implementations
  var x = a[0],
      y = a[1],
      z = a[2],
      qx = q[0],
      qy = q[1],
      qz = q[2],
      qw = q[3],
      // calculate quat * vec
  ix = qw * x + qy * z - qz * y,
      iy = qw * y + qz * x - qx * z,
      iz = qw * z + qx * y - qy * x,
      iw = -qx * x - qy * y - qz * z; // calculate result * inverse quat

  out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
  out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
  out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
  return out;
}

/***/ }),
/* 222 */
/***/ (function(module, exports) {

module.exports = rotateX;
/**
 * Rotate a 3D vector around the x-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */

function rotateX(out, a, b, c) {
  var by = b[1];
  var bz = b[2]; // Translate point to the origin

  var py = a[1] - by;
  var pz = a[2] - bz;
  var sc = Math.sin(c);
  var cc = Math.cos(c); // perform rotation and translate to correct position

  out[0] = a[0];
  out[1] = by + py * cc - pz * sc;
  out[2] = bz + py * sc + pz * cc;
  return out;
}

/***/ }),
/* 223 */
/***/ (function(module, exports) {

module.exports = rotateY;
/**
 * Rotate a 3D vector around the y-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */

function rotateY(out, a, b, c) {
  var bx = b[0];
  var bz = b[2]; // translate point to the origin

  var px = a[0] - bx;
  var pz = a[2] - bz;
  var sc = Math.sin(c);
  var cc = Math.cos(c); // perform rotation and translate to correct position

  out[0] = bx + pz * sc + px * cc;
  out[1] = a[1];
  out[2] = bz + pz * cc - px * sc;
  return out;
}

/***/ }),
/* 224 */
/***/ (function(module, exports) {

module.exports = rotateZ;
/**
 * Rotate a 3D vector around the z-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */

function rotateZ(out, a, b, c) {
  var bx = b[0];
  var by = b[1]; //Translate point to the origin

  var px = a[0] - bx;
  var py = a[1] - by;
  var sc = Math.sin(c);
  var cc = Math.cos(c); // perform rotation and translate to correct position

  out[0] = bx + px * cc - py * sc;
  out[1] = by + px * sc + py * cc;
  out[2] = a[2];
  return out;
}

/***/ }),
/* 225 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = forEach;

var vec = __webpack_require__(73)();
/**
 * Perform some operation over an array of vec3s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */


function forEach(a, stride, offset, count, fn, arg) {
  var i, l;

  if (!stride) {
    stride = 3;
  }

  if (!offset) {
    offset = 0;
  }

  if (count) {
    l = Math.min(count * stride + offset, a.length);
  } else {
    l = a.length;
  }

  for (i = offset; i < l; i += stride) {
    vec[0] = a[i];
    vec[1] = a[i + 1];
    vec[2] = a[i + 2];
    fn(vec, vec, arg);
    a[i] = vec[0];
    a[i + 1] = vec[1];
    a[i + 2] = vec[2];
  }

  return a;
}

/***/ }),
/* 226 */
/***/ (function(module, exports, __webpack_require__) {

var arrayLikeToArray = __webpack_require__(62);

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return arrayLikeToArray(arr);
}

module.exports = _arrayWithoutHoles;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),
/* 227 */
/***/ (function(module, exports) {

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}

module.exports = _iterableToArray;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),
/* 228 */
/***/ (function(module, exports) {

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

module.exports = _nonIterableSpread;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),
/* 229 */
/***/ (function(module, exports, __webpack_require__) {

var getPrototypeOf = __webpack_require__(2);

function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = getPrototypeOf(object);
    if (object === null) break;
  }

  return object;
}

module.exports = _superPropBase;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),
/* 230 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var runtime = function (exports) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.

  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []); // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.

    generator._invoke = makeInvokeMethod(innerFn, self, context);
    return generator;
  }

  exports.wrap = wrap; // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.

  function tryCatch(fn, obj, arg) {
    try {
      return {
        type: "normal",
        arg: fn.call(obj, arg)
      };
    } catch (err) {
      return {
        type: "throw",
        arg: err
      };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed"; // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.

  var ContinueSentinel = {}; // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.

  function Generator() {}

  function GeneratorFunction() {}

  function GeneratorFunctionPrototype() {} // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.


  var IteratorPrototype = {};

  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));

  if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = "GeneratorFunction"; // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.

  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function (method) {
      prototype[method] = function (arg) {
        return this._invoke(method, arg);
      };
    });
  }

  exports.isGeneratorFunction = function (genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor ? ctor === GeneratorFunction || // For the native GeneratorFunction constructor, the best we can
    // do is to check its .name property.
    (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
  };

  exports.mark = function (genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;

      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }

    genFun.prototype = Object.create(Gp);
    return genFun;
  }; // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.


  exports.awrap = function (arg) {
    return {
      __await: arg
    };
  };

  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);

      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;

        if (value && typeof value === "object" && hasOwn.call(value, "__await")) {
          return PromiseImpl.resolve(value.__await).then(function (value) {
            invoke("next", value, resolve, reject);
          }, function (err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return PromiseImpl.resolve(value).then(function (unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function (error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new PromiseImpl(function (resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise = // If enqueue has been called before, then we want to wait until
      // all previous Promises have been resolved before calling invoke,
      // so that results are always delivered in the correct order. If
      // enqueue has not been called before, then it is important to
      // call invoke immediately, without waiting on a callback to fire,
      // so that the async generator function has the opportunity to do
      // any necessary setup in a predictable way. This predictability
      // is why the Promise constructor synchronously invokes its
      // executor callback, and why async functions synchronously
      // execute code before the first await. Since we implement simple
      // async functions in terms of async generators, it is especially
      // important to get this right, even though it requires care.
      previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, // Avoid propagating failures to Promises returned by later
      // invocations of the iterator.
      callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
    } // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).


    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);

  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };

  exports.AsyncIterator = AsyncIterator; // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.

  exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    if (PromiseImpl === void 0) PromiseImpl = Promise;
    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
    return exports.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.
    : iter.next().then(function (result) {
      return result.done ? result.value : iter.next();
    });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;
    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        } // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume


        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;

        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);

          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;
        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);
        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;
        var record = tryCatch(innerFn, self, context);

        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done ? GenStateCompleted : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };
        } else if (record.type === "throw") {
          state = GenStateCompleted; // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.

          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  } // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.


  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];

    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        // Note: ["return"] must be used for ES3 parsing compatibility.
        if (delegate.iterator["return"]) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError("The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (!info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value; // Resume execution at the desired location (see delegateYield).

      context.next = delegate.nextLoc; // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.

      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }
    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    } // The delegate iterator is finished, so forget it and continue with
    // the outer generator.


    context.delegate = null;
    return ContinueSentinel;
  } // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.


  defineIteratorMethods(Gp);
  Gp[toStringTagSymbol] = "Generator"; // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.

  Gp[iteratorSymbol] = function () {
    return this;
  };

  Gp.toString = function () {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = {
      tryLoc: locs[0]
    };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{
      tryLoc: "root"
    }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  exports.keys = function (object) {
    var keys = [];

    for (var key in object) {
      keys.push(key);
    }

    keys.reverse(); // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.

    return function next() {
      while (keys.length) {
        var key = keys.pop();

        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      } // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.


      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];

      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1,
            next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;
          return next;
        };

        return next.next = next;
      }
    } // Return an iterator with no values.


    return {
      next: doneResult
    };
  }

  exports.values = values;

  function doneResult() {
    return {
      value: undefined,
      done: true
    };
  }

  Context.prototype = {
    constructor: Context,
    reset: function (skipTempReset) {
      this.prev = 0;
      this.next = 0; // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.

      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;
      this.method = "next";
      this.arg = undefined;
      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },
    stop: function () {
      this.done = true;
      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;

      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },
    dispatchException: function (exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;

      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !!caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }
          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }
          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }
          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },
    abrupt: function (type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },
    complete: function (record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" || record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },
    finish: function (finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },
    "catch": function (tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;

          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }

          return thrown;
        }
      } // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.


      throw new Error("illegal catch attempt");
    },
    delegateYield: function (iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  }; // Regardless of whether this script is executing as a CommonJS module
  // or not, return the runtime object so that we can declare the variable
  // regeneratorRuntime in the outer scope, which allows this module to be
  // injected easily by `bin/regenerator --include-runtime script.js`.

  return exports;
}( // If this script is executing as a CommonJS module, use module.exports
// as the regeneratorRuntime namespace. Otherwise create a new empty
// object. Either way, the resulting object will be used to initialize
// the regeneratorRuntime variable at the top of this file.
 true ? module.exports : undefined);

try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  // This module should not be running in strict mode, so the above
  // assignment should always work unless something is misconfigured. Just
  // in case runtime.js accidentally runs in strict mode, we can escape
  // strict mode using a global Function call. This could conceivably fail
  // if a Content Security Policy forbids using Function, but in that case
  // the proper solution is to fix the accidental strict mode problem. If
  // you've misconfigured your bundler to force strict mode and applied a
  // CSP to forbid Function, and you're not willing to fix either of those
  // problems, please detail your unique predicament in a GitHub issue.
  Function("r", "regeneratorRuntime = r")(runtime);
}

/***/ }),
/* 231 */
/***/ (function(module, exports, __webpack_require__) {

var basePickBy = __webpack_require__(232),
    hasIn = __webpack_require__(242);
/**
 * The base implementation of `_.pick` without support for individual
 * property identifiers.
 *
 * @private
 * @param {Object} object The source object.
 * @param {string[]} paths The property paths to pick.
 * @returns {Object} Returns the new object.
 */


function basePick(object, paths) {
  return basePickBy(object, paths, function (value, path) {
    return hasIn(object, path);
  });
}

module.exports = basePick;

/***/ }),
/* 232 */
/***/ (function(module, exports, __webpack_require__) {

var baseGet = __webpack_require__(233),
    baseSet = __webpack_require__(241),
    castPath = __webpack_require__(32);
/**
 * The base implementation of  `_.pickBy` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The source object.
 * @param {string[]} paths The property paths to pick.
 * @param {Function} predicate The function invoked per property.
 * @returns {Object} Returns the new object.
 */


function basePickBy(object, paths, predicate) {
  var index = -1,
      length = paths.length,
      result = {};

  while (++index < length) {
    var path = paths[index],
        value = baseGet(object, path);

    if (predicate(value, path)) {
      baseSet(result, castPath(path, object), value);
    }
  }

  return result;
}

module.exports = basePickBy;

/***/ }),
/* 233 */
/***/ (function(module, exports, __webpack_require__) {

var castPath = __webpack_require__(32),
    toKey = __webpack_require__(44);
/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */


function baseGet(object, path) {
  path = castPath(path, object);
  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[toKey(path[index++])];
  }

  return index && index == length ? object : undefined;
}

module.exports = baseGet;

/***/ }),
/* 234 */
/***/ (function(module, exports, __webpack_require__) {

var isArray = __webpack_require__(14),
    isSymbol = __webpack_require__(43);
/** Used to match property names within property paths. */


var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/;
/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */

function isKey(value, object) {
  if (isArray(value)) {
    return false;
  }

  var type = typeof value;

  if (type == 'number' || type == 'symbol' || type == 'boolean' || value == null || isSymbol(value)) {
    return true;
  }

  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
}

module.exports = isKey;

/***/ }),
/* 235 */
/***/ (function(module, exports, __webpack_require__) {

var memoizeCapped = __webpack_require__(236);
/** Used to match property names within property paths. */


var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
/** Used to match backslashes in property paths. */

var reEscapeChar = /\\(\\)?/g;
/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */

var stringToPath = memoizeCapped(function (string) {
  var result = [];

  if (string.charCodeAt(0) === 46
  /* . */
  ) {
    result.push('');
  }

  string.replace(rePropName, function (match, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, '$1') : number || match);
  });
  return result;
});
module.exports = stringToPath;

/***/ }),
/* 236 */
/***/ (function(module, exports, __webpack_require__) {

var memoize = __webpack_require__(237);
/** Used as the maximum memoize cache size. */


var MAX_MEMOIZE_SIZE = 500;
/**
 * A specialized version of `_.memoize` which clears the memoized function's
 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
 *
 * @private
 * @param {Function} func The function to have its output memoized.
 * @returns {Function} Returns the new memoized function.
 */

function memoizeCapped(func) {
  var result = memoize(func, function (key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }

    return key;
  });
  var cache = result.cache;
  return result;
}

module.exports = memoizeCapped;

/***/ }),
/* 237 */
/***/ (function(module, exports, __webpack_require__) {

var MapCache = __webpack_require__(48);
/** Error message constants. */


var FUNC_ERROR_TEXT = 'Expected a function';
/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */

function memoize(func, resolver) {
  if (typeof func != 'function' || resolver != null && typeof resolver != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }

  var memoized = function () {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }

    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };

  memoized.cache = new (memoize.Cache || MapCache)();
  return memoized;
} // Expose `MapCache`.


memoize.Cache = MapCache;
module.exports = memoize;

/***/ }),
/* 238 */
/***/ (function(module, exports, __webpack_require__) {

var baseToString = __webpack_require__(239);
/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */


function toString(value) {
  return value == null ? '' : baseToString(value);
}

module.exports = toString;

/***/ }),
/* 239 */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(27),
    arrayMap = __webpack_require__(240),
    isArray = __webpack_require__(14),
    isSymbol = __webpack_require__(43);
/** Used as references for various `Number` constants. */


var INFINITY = 1 / 0;
/** Used to convert symbols to primitives and strings. */

var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;
/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */

function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }

  if (isArray(value)) {
    // Recursively convert values (susceptible to call stack limits).
    return arrayMap(value, baseToString) + '';
  }

  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }

  var result = value + '';
  return result == '0' && 1 / value == -INFINITY ? '-0' : result;
}

module.exports = baseToString;

/***/ }),
/* 240 */
/***/ (function(module, exports) {

/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }

  return result;
}

module.exports = arrayMap;

/***/ }),
/* 241 */
/***/ (function(module, exports, __webpack_require__) {

var assignValue = __webpack_require__(56),
    castPath = __webpack_require__(32),
    isIndex = __webpack_require__(31),
    isObject = __webpack_require__(13),
    toKey = __webpack_require__(44);
/**
 * The base implementation of `_.set`.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {Array|string} path The path of the property to set.
 * @param {*} value The value to set.
 * @param {Function} [customizer] The function to customize path creation.
 * @returns {Object} Returns `object`.
 */


function baseSet(object, path, value, customizer) {
  if (!isObject(object)) {
    return object;
  }

  path = castPath(path, object);
  var index = -1,
      length = path.length,
      lastIndex = length - 1,
      nested = object;

  while (nested != null && ++index < length) {
    var key = toKey(path[index]),
        newValue = value;

    if (key === '__proto__' || key === 'constructor' || key === 'prototype') {
      return object;
    }

    if (index != lastIndex) {
      var objValue = nested[key];
      newValue = customizer ? customizer(objValue, key, nested) : undefined;

      if (newValue === undefined) {
        newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
      }
    }

    assignValue(nested, key, newValue);
    nested = nested[key];
  }

  return object;
}

module.exports = baseSet;

/***/ }),
/* 242 */
/***/ (function(module, exports, __webpack_require__) {

var baseHasIn = __webpack_require__(243),
    hasPath = __webpack_require__(244);
/**
 * Checks if `path` is a direct or inherited property of `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.hasIn(object, 'a');
 * // => true
 *
 * _.hasIn(object, 'a.b');
 * // => true
 *
 * _.hasIn(object, ['a', 'b']);
 * // => true
 *
 * _.hasIn(object, 'b');
 * // => false
 */


function hasIn(object, path) {
  return object != null && hasPath(object, path, baseHasIn);
}

module.exports = hasIn;

/***/ }),
/* 243 */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.hasIn` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function baseHasIn(object, key) {
  return object != null && key in Object(object);
}

module.exports = baseHasIn;

/***/ }),
/* 244 */
/***/ (function(module, exports, __webpack_require__) {

var castPath = __webpack_require__(32),
    isArguments = __webpack_require__(30),
    isArray = __webpack_require__(14),
    isIndex = __webpack_require__(31),
    isLength = __webpack_require__(41),
    toKey = __webpack_require__(44);
/**
 * Checks if `path` exists on `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @param {Function} hasFunc The function to check properties.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 */


function hasPath(object, path, hasFunc) {
  path = castPath(path, object);
  var index = -1,
      length = path.length,
      result = false;

  while (++index < length) {
    var key = toKey(path[index]);

    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }

    object = object[key];
  }

  if (result || ++index != length) {
    return result;
  }

  length = object == null ? 0 : object.length;
  return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
}

module.exports = hasPath;

/***/ }),
/* 245 */
/***/ (function(module, exports, __webpack_require__) {

var flatten = __webpack_require__(246),
    overRest = __webpack_require__(59),
    setToString = __webpack_require__(60);
/**
 * A specialized version of `baseRest` which flattens the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @returns {Function} Returns the new function.
 */


function flatRest(func) {
  return setToString(overRest(func, undefined, flatten), func + '');
}

module.exports = flatRest;

/***/ }),
/* 246 */
/***/ (function(module, exports, __webpack_require__) {

var baseFlatten = __webpack_require__(247);
/**
 * Flattens `array` a single level deep.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to flatten.
 * @returns {Array} Returns the new flattened array.
 * @example
 *
 * _.flatten([1, [2, [3, [4]], 5]]);
 * // => [1, 2, [3, [4]], 5]
 */


function flatten(array) {
  var length = array == null ? 0 : array.length;
  return length ? baseFlatten(array, 1) : [];
}

module.exports = flatten;

/***/ }),
/* 247 */
/***/ (function(module, exports, __webpack_require__) {

var arrayPush = __webpack_require__(248),
    isFlattenable = __webpack_require__(249);
/**
 * The base implementation of `_.flatten` with support for restricting flattening.
 *
 * @private
 * @param {Array} array The array to flatten.
 * @param {number} depth The maximum recursion depth.
 * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
 * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
 * @param {Array} [result=[]] The initial result value.
 * @returns {Array} Returns the new flattened array.
 */


function baseFlatten(array, depth, predicate, isStrict, result) {
  var index = -1,
      length = array.length;
  predicate || (predicate = isFlattenable);
  result || (result = []);

  while (++index < length) {
    var value = array[index];

    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        // Recursively flatten arrays (susceptible to call stack limits).
        baseFlatten(value, depth - 1, predicate, isStrict, result);
      } else {
        arrayPush(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }

  return result;
}

module.exports = baseFlatten;

/***/ }),
/* 248 */
/***/ (function(module, exports) {

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }

  return array;
}

module.exports = arrayPush;

/***/ }),
/* 249 */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(27),
    isArguments = __webpack_require__(30),
    isArray = __webpack_require__(14);
/** Built-in value references. */


var spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined;
/**
 * Checks if `value` is a flattenable `arguments` object or array.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
 */

function isFlattenable(value) {
  return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
}

module.exports = isFlattenable;

/***/ }),
/* 250 */
/***/ (function(module, exports) {

function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}

module.exports = _isNativeFunction;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),
/* 251 */
/***/ (function(module, exports, __webpack_require__) {

var setPrototypeOf = __webpack_require__(42);

var isNativeReflectConstruct = __webpack_require__(252);

function _construct(Parent, args, Class) {
  if (isNativeReflectConstruct()) {
    module.exports = _construct = Reflect.construct;
    module.exports["default"] = module.exports, module.exports.__esModule = true;
  } else {
    module.exports = _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) setPrototypeOf(instance, Class.prototype);
      return instance;
    };

    module.exports["default"] = module.exports, module.exports.__esModule = true;
  }

  return _construct.apply(null, arguments);
}

module.exports = _construct;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),
/* 252 */
/***/ (function(module, exports) {

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

module.exports = _isNativeReflectConstruct;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),
/* 253 */
/***/ (function(module, exports) {

module.exports = determinant;
/**
 * Calculates the determinant of a mat2
 *
 * @alias mat2.determinant
 * @param {mat2} a the source matrix
 * @returns {Number} determinant of a
 */

function determinant(a) {
  return a[0] * a[3] - a[2] * a[1];
}

/***/ }),
/* 254 */
/***/ (function(module, exports) {

module.exports = transpose;
/**
 * Transpose the values of a mat2
 *
 * @alias mat2.transpose
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */

function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache some values
  if (out === a) {
    var a1 = a[1];
    out[1] = a[2];
    out[2] = a1;
  } else {
    out[0] = a[0];
    out[1] = a[2];
    out[2] = a[1];
    out[3] = a[3];
  }

  return out;
}

/***/ }),
/* 255 */
/***/ (function(module, exports) {

module.exports = multiply;
/**
 * Multiplies two mat2's
 *
 * @alias mat2.multiply
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @returns {mat2} out
 */

function multiply(out, a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  out[0] = a0 * b0 + a2 * b1;
  out[1] = a1 * b0 + a3 * b1;
  out[2] = a0 * b2 + a2 * b3;
  out[3] = a1 * b2 + a3 * b3;
  return out;
}

/***/ }),
/* 256 */
/***/ (function(module, exports) {

module.exports = identity;
/**
 * Set a mat2 to the identity matrix
 *
 * @alias mat2.identity
 * @param {mat2} out the receiving matrix
 * @returns {mat2} out
 */

function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}

/***/ }),
/* 257 */
/***/ (function(module, exports) {

module.exports = adjoint;
/**
 * Calculates the adjugate of a mat2
 *
 * @alias mat2.adjoint
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */

function adjoint(out, a) {
  // Caching this value is nessecary if out == a
  var a0 = a[0];
  out[0] = a[3];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = a0;
  return out;
}

/***/ }),
/* 258 */
/***/ (function(module, exports) {

module.exports = rotate;
/**
 * Rotates a mat2 by the given angle
 *
 * @alias mat2.rotate
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2} out
 */

function rotate(out, a, rad) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  out[0] = a0 * c + a2 * s;
  out[1] = a1 * c + a3 * s;
  out[2] = a0 * -s + a2 * c;
  out[3] = a1 * -s + a3 * c;
  return out;
}

/***/ }),
/* 259 */
/***/ (function(module, exports) {

module.exports = invert;
/**
 * Inverts a mat2
 *
 * @alias mat2.invert
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */

function invert(out, a) {
  var a0 = a[0];
  var a1 = a[1];
  var a2 = a[2];
  var a3 = a[3];
  var det = a0 * a3 - a2 * a1;
  if (!det) return null;
  det = 1.0 / det;
  out[0] = a3 * det;
  out[1] = -a1 * det;
  out[2] = -a2 * det;
  out[3] = a0 * det;
  return out;
}

/***/ }),
/* 260 */
/***/ (function(module, exports) {

module.exports = create;
/**
 * Creates a new identity mat2
 *
 * @alias mat2.create
 * @returns {mat2} a new 2x2 matrix
 */

function create() {
  var out = new Float32Array(4);
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}

/***/ }),
/* 261 */
/***/ (function(module, exports) {

module.exports = scale;
/**
 * Scales the mat2 by the dimensions in the given vec2
 *
 * @alias mat2.scale
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to rotate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat2} out
 **/

function scale(out, a, v) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var v0 = v[0],
      v1 = v[1];
  out[0] = a0 * v0;
  out[1] = a1 * v0;
  out[2] = a2 * v1;
  out[3] = a3 * v1;
  return out;
}

/***/ }),
/* 262 */
/***/ (function(module, exports) {

module.exports = copy;
/**
 * Copy the values from one mat2 to another
 *
 * @alias mat2.copy
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}

/***/ }),
/* 263 */
/***/ (function(module, exports) {

module.exports = frob;
/**
 * Returns Frobenius norm of a mat2
 *
 * @alias mat2.frob
 * @param {mat2} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */

function frob(a) {
  return Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2));
}

/***/ }),
/* 264 */
/***/ (function(module, exports) {

module.exports = ldu;
/**
 * Returns L, D and U matrices (Lower triangular, Diagonal and Upper triangular) by factorizing the input matrix
 *
 * @alias mat2.ldu
 * @param {mat2} L the lower triangular matrix
 * @param {mat2} D the diagonal matrix
 * @param {mat2} U the upper triangular matrix
 * @param {mat2} a the input matrix to factorize
 */

function ldu(L, D, U, a) {
  L[2] = a[2] / a[0];
  U[0] = a[0];
  U[1] = a[1];
  U[3] = a[3] - L[2] * U[1];
  return [L, D, U];
}

/***/ }),
/* 265 */
/***/ (function(module, exports) {

module.exports = require("ndarray");

/***/ }),
/* 266 */
/***/ (function(module, exports) {

module.exports = require("ndarray-linear-interpolate");

/***/ }),
/* 267 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, "BarcodeDecoder", function() { return /* reexport */ barcode_decoder; });
__webpack_require__.d(__webpack_exports__, "Readers", function() { return /* reexport */ reader_namespaceObject; });
__webpack_require__.d(__webpack_exports__, "CameraAccess", function() { return /* reexport */ camera_access; });
__webpack_require__.d(__webpack_exports__, "ImageDebug", function() { return /* reexport */ image_debug["a" /* default */]; });
__webpack_require__.d(__webpack_exports__, "ImageWrapper", function() { return /* reexport */ image_wrapper["a" /* default */]; });
__webpack_require__.d(__webpack_exports__, "ResultCollector", function() { return /* reexport */ result_collector; });

// NAMESPACE OBJECT: ./src/reader/index.ts
var reader_namespaceObject = {};
__webpack_require__.r(reader_namespaceObject);
__webpack_require__.d(reader_namespaceObject, "BarcodeReader", function() { return barcode_reader; });
__webpack_require__.d(reader_namespaceObject, "TwoOfFiveReader", function() { return _2of5_reader; });
__webpack_require__.d(reader_namespaceObject, "NewCodabarReader", function() { return codabar_reader; });
__webpack_require__.d(reader_namespaceObject, "Code128Reader", function() { return code_128_reader; });
__webpack_require__.d(reader_namespaceObject, "Code32Reader", function() { return code_32_reader; });
__webpack_require__.d(reader_namespaceObject, "Code39Reader", function() { return code_39_reader; });
__webpack_require__.d(reader_namespaceObject, "Code39VINReader", function() { return code_39_vin_reader; });
__webpack_require__.d(reader_namespaceObject, "Code93Reader", function() { return code_93_reader; });
__webpack_require__.d(reader_namespaceObject, "EAN2Reader", function() { return ean_2_reader; });
__webpack_require__.d(reader_namespaceObject, "EAN5Reader", function() { return ean_5_reader; });
__webpack_require__.d(reader_namespaceObject, "EAN8Reader", function() { return ean_8_reader; });
__webpack_require__.d(reader_namespaceObject, "EANReader", function() { return ean_reader; });
__webpack_require__.d(reader_namespaceObject, "I2of5Reader", function() { return i2of5_reader; });
__webpack_require__.d(reader_namespaceObject, "UPCEReader", function() { return upc_e_reader; });
__webpack_require__.d(reader_namespaceObject, "UPCReader", function() { return upc_reader; });

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/typeof.js
var helpers_typeof = __webpack_require__(19);
var typeof_default = /*#__PURE__*/__webpack_require__.n(helpers_typeof);

// EXTERNAL MODULE: ./node_modules/lodash/merge.js
var merge = __webpack_require__(16);
var merge_default = /*#__PURE__*/__webpack_require__.n(merge);

// EXTERNAL MODULE: ./src/common/typedefs.js
var typedefs = __webpack_require__(154);

// EXTERNAL MODULE: ./src/common/image_wrapper.ts
var image_wrapper = __webpack_require__(9);

// CONCATENATED MODULE: ./src/decoder/bresenham.js
var Bresenham = {};
var Slope = {
  DIR: {
    UP: 1,
    DOWN: -1
  }
};
/**
 * Scans a line of the given image from point p1 to p2 and returns a result object containing
 * gray-scale values (0-255) of the underlying pixels in addition to the min
 * and max values.
 * @param {Object} imageWrapper
 * @param {Object} p1 The start point {x,y}
 * @param {Object} p2 The end point {x,y}
 * @returns {line, min, max}
 */

Bresenham.getBarcodeLine = function (imageWrapper, p1, p2) {
  /* eslint-disable no-bitwise */
  var x0 = p1.x | 0;
  var y0 = p1.y | 0;
  var x1 = p2.x | 0;
  var y1 = p2.y | 0;
  /* eslint-disable no-bitwise */

  var steep = Math.abs(y1 - y0) > Math.abs(x1 - x0);
  var error;
  var y;
  var tmp;
  var x;
  var line = [];
  var imageData = imageWrapper.data;
  var width = imageWrapper.size.x;
  var val;
  var min = 255;
  var max = 0;

  function read(a, b) {
    val = imageData[b * width + a];
    min = val < min ? val : min;
    max = val > max ? val : max;
    line.push(val);
  }

  if (steep) {
    tmp = x0;
    x0 = y0;
    y0 = tmp;
    tmp = x1;
    x1 = y1;
    y1 = tmp;
  }

  if (x0 > x1) {
    tmp = x0;
    x0 = x1;
    x1 = tmp;
    tmp = y0;
    y0 = y1;
    y1 = tmp;
  }

  var deltaX = x1 - x0;
  var deltaY = Math.abs(y1 - y0);
  error = deltaX / 2 | 0;
  y = y0;
  var yStep = y0 < y1 ? 1 : -1;

  for (x = x0; x < x1; x++) {
    if (steep) {
      read(y, x);
    } else {
      read(x, y);
    }

    error -= deltaY;

    if (error < 0) {
      y += yStep;
      error += deltaX;
    }
  }

  return {
    line: line,
    min: min,
    max: max
  };
};
/**
 * Converts the result from getBarcodeLine into a binary representation
 * also considering the frequency and slope of the signal for more robust results
 * @param {Object} result {line, min, max}
 */


Bresenham.toBinaryLine = function (result) {
  var min = result.min;
  var max = result.max;
  var line = result.line;
  var slope;
  var slope2;
  var center = min + (max - min) / 2;
  var extrema = [];
  var currentDir;
  var dir;
  var threshold = (max - min) / 12;
  var rThreshold = -threshold;
  var i;
  var j; // 1. find extrema

  currentDir = line[0] > center ? Slope.DIR.UP : Slope.DIR.DOWN;
  extrema.push({
    pos: 0,
    val: line[0]
  });

  for (i = 0; i < line.length - 2; i++) {
    slope = line[i + 1] - line[i];
    slope2 = line[i + 2] - line[i + 1];

    if (slope + slope2 < rThreshold && line[i + 1] < center * 1.5) {
      dir = Slope.DIR.DOWN;
    } else if (slope + slope2 > threshold && line[i + 1] > center * 0.5) {
      dir = Slope.DIR.UP;
    } else {
      dir = currentDir;
    }

    if (currentDir !== dir) {
      extrema.push({
        pos: i,
        val: line[i]
      });
      currentDir = dir;
    }
  }

  extrema.push({
    pos: line.length,
    val: line[line.length - 1]
  });

  for (j = extrema[0].pos; j < extrema[1].pos; j++) {
    line[j] = line[j] > center ? 0 : 1;
  } // iterate over extrema and convert to binary based on avg between minmax


  for (i = 1; i < extrema.length - 1; i++) {
    if (extrema[i + 1].val > extrema[i].val) {
      threshold = extrema[i].val + (extrema[i + 1].val - extrema[i].val) / 3 * 2 | 0;
    } else {
      threshold = extrema[i + 1].val + (extrema[i].val - extrema[i + 1].val) / 3 | 0;
    }

    for (j = extrema[i].pos; j < extrema[i + 1].pos; j++) {
      line[j] = line[j] > threshold ? 0 : 1;
    }
  }

  return {
    line: line,
    threshold: threshold
  };
};
/**
 * Used for development only
 */


Bresenham.debug = {
  printFrequency: function printFrequency(line, canvas) {
    var i;
    var ctx = canvas.getContext('2d'); // eslint-disable-next-line no-param-reassign

    canvas.width = line.length; // eslint-disable-next-line no-param-reassign

    canvas.height = 256;
    ctx.beginPath();
    ctx.strokeStyle = 'blue';

    for (i = 0; i < line.length; i++) {
      ctx.moveTo(i, 255);
      ctx.lineTo(i, 255 - line[i]);
    }

    ctx.stroke();
    ctx.closePath();
  },
  printPattern: function printPattern(line, canvas) {
    var ctx = canvas.getContext('2d');
    var i; // eslint-disable-next-line no-param-reassign

    canvas.width = line.length;
    ctx.fillColor = 'black';

    for (i = 0; i < line.length; i++) {
      if (line[i] === 1) {
        ctx.fillRect(i, 0, 1, 100);
      }
    }
  }
};
/* harmony default export */ var bresenham = (Bresenham);
// EXTERNAL MODULE: ./src/common/image_debug.ts
var image_debug = __webpack_require__(15);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/classCallCheck.js
var classCallCheck = __webpack_require__(3);
var classCallCheck_default = /*#__PURE__*/__webpack_require__.n(classCallCheck);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/createClass.js
var createClass = __webpack_require__(4);
var createClass_default = /*#__PURE__*/__webpack_require__.n(createClass);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/assertThisInitialized.js
var assertThisInitialized = __webpack_require__(1);
var assertThisInitialized_default = /*#__PURE__*/__webpack_require__.n(assertThisInitialized);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/inherits.js
var inherits = __webpack_require__(6);
var inherits_default = /*#__PURE__*/__webpack_require__.n(inherits);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js
var possibleConstructorReturn = __webpack_require__(5);
var possibleConstructorReturn_default = /*#__PURE__*/__webpack_require__.n(possibleConstructorReturn);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/getPrototypeOf.js
var getPrototypeOf = __webpack_require__(2);
var getPrototypeOf_default = /*#__PURE__*/__webpack_require__.n(getPrototypeOf);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/defineProperty.js
var defineProperty = __webpack_require__(0);
var defineProperty_default = /*#__PURE__*/__webpack_require__.n(defineProperty);

// EXTERNAL MODULE: ./src/common/array_helper.ts
var array_helper = __webpack_require__(8);

// CONCATENATED MODULE: ./src/reader/barcode_reader.ts




var BarcodeDirection;

(function (BarcodeDirection) {
  BarcodeDirection[BarcodeDirection["Forward"] = 1] = "Forward";
  BarcodeDirection[BarcodeDirection["Reverse"] = -1] = "Reverse";
})(BarcodeDirection || (BarcodeDirection = {}));

;
;
;
;
;
;
var barcode_reader_BarcodeReader = /*#__PURE__*/function () {
  function BarcodeReader(config, supplements) {
    classCallCheck_default()(this, BarcodeReader);

    defineProperty_default()(this, "_row", []);

    defineProperty_default()(this, "config", {});

    defineProperty_default()(this, "supplements", []);

    defineProperty_default()(this, "SINGLE_CODE_ERROR", 0);

    defineProperty_default()(this, "FORMAT", 'unknown');

    defineProperty_default()(this, "CONFIG_KEYS", {});

    this._row = [];
    this.config = config || {};

    if (supplements) {
      this.supplements = supplements;
    }

    return this;
  }

  createClass_default()(BarcodeReader, [{
    key: "_nextUnset",
    value: function _nextUnset(line) {
      var start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

      for (var i = start; i < line.length; i++) {
        if (!line[i]) return i;
      }

      return line.length;
    }
  }, {
    key: "_matchPattern",
    value: function _matchPattern(counter, code, maxSingleError) {
      var error = 0;
      var singleError = 0;
      var sum = 0;
      var modulo = 0;
      var barWidth = 0;
      var count = 0;
      var scaled = 0;
      maxSingleError = maxSingleError || this.SINGLE_CODE_ERROR || 1;

      for (var i = 0; i < counter.length; i++) {
        sum += counter[i];
        modulo += code[i];
      }

      if (sum < modulo) {
        return Number.MAX_VALUE;
      }

      barWidth = sum / modulo;
      maxSingleError *= barWidth;

      for (var _i = 0; _i < counter.length; _i++) {
        count = counter[_i];
        scaled = code[_i] * barWidth;
        singleError = Math.abs(count - scaled) / scaled;

        if (singleError > maxSingleError) {
          return Number.MAX_VALUE;
        }

        error += singleError;
      }

      return error / modulo;
    }
  }, {
    key: "_nextSet",
    value: function _nextSet(line) {
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

      for (var i = offset; i < line.length; i++) {
        if (line[i]) return i;
      }

      return line.length;
    }
  }, {
    key: "_correctBars",
    value: function _correctBars(counter, correction, indices) {
      var length = indices.length;
      var tmp = 0;

      while (length--) {
        tmp = counter[indices[length]] * (1 - (1 - correction) / 2);

        if (tmp > 1) {
          counter[indices[length]] = tmp;
        }
      }
    }
  }, {
    key: "decodePattern",
    value: function decodePattern(pattern) {
      // console.warn('* decodePattern', pattern);
      this._row = pattern; // console.warn('* decodePattern calling decode', typeof this, this.constructor, this.FORMAT, JSON.stringify(this));

      var result = this.decode(); // console.warn('* first result=', result);

      if (result === null) {
        this._row.reverse();

        result = this.decode(); // console.warn('* reversed result=', result);

        if (result) {
          result.direction = BarcodeDirection.Reverse;
          result.start = this._row.length - result.start;
          result.end = this._row.length - result.end;
        }
      } else {
        result.direction = BarcodeDirection.Forward;
      }

      if (result) {
        result.format = this.FORMAT;
      } // console.warn('* returning', result);


      return result;
    }
  }, {
    key: "_matchRange",
    value: function _matchRange(start, end, value) {
      var i;
      start = start < 0 ? 0 : start;

      for (i = start; i < end; i++) {
        if (this._row[i] !== value) {
          return false;
        }
      }

      return true;
    }
  }, {
    key: "_fillCounters",
    value: function _fillCounters() {
      var offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._nextUnset(this._row);
      var end = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._row.length;
      var isWhite = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      var counters = [];
      var counterPos = 0;
      counters[counterPos] = 0;

      for (var i = offset; i < end; i++) {
        if (this._row[i] ^ (isWhite ? 1 : 0)) {
          counters[counterPos]++;
        } else {
          counterPos++;
          counters[counterPos] = 1;
          isWhite = !isWhite;
        }
      }

      return counters;
    }
  }, {
    key: "_toCounters",
    value: function _toCounters(start, counters) {
      var numCounters = counters.length;
      var end = this._row.length;
      var isWhite = !this._row[start];
      var counterPos = 0;
      array_helper["a" /* default */].init(counters, 0);

      for (var i = start; i < end; i++) {
        if (this._row[i] ^ (isWhite ? 1 : 0)) {
          counters[counterPos]++;
        } else {
          counterPos++;

          if (counterPos === numCounters) {
            break;
          } else {
            counters[counterPos] = 1;
            isWhite = !isWhite;
          }
        }
      }

      return counters;
    }
  }], [{
    key: "Exception",
    get: function get() {
      return {
        StartNotFoundException: 'Start-Info was not found!',
        CodeNotFoundException: 'Code could not be found!',
        PatternNotFoundException: 'Pattern could not be found!'
      };
    }
  }]);

  return BarcodeReader;
}();
/* harmony default export */ var barcode_reader = (barcode_reader_BarcodeReader);
// CONCATENATED MODULE: ./src/reader/code_128_reader.ts








function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }



var code_128_reader_Code128Reader = /*#__PURE__*/function (_BarcodeReader) {
  inherits_default()(Code128Reader, _BarcodeReader);

  var _super = _createSuper(Code128Reader);

  function Code128Reader() {
    var _this;

    classCallCheck_default()(this, Code128Reader);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    defineProperty_default()(assertThisInitialized_default()(_this), "CODE_SHIFT", 98);

    defineProperty_default()(assertThisInitialized_default()(_this), "CODE_C", 99);

    defineProperty_default()(assertThisInitialized_default()(_this), "CODE_B", 100);

    defineProperty_default()(assertThisInitialized_default()(_this), "CODE_A", 101);

    defineProperty_default()(assertThisInitialized_default()(_this), "START_CODE_A", 103);

    defineProperty_default()(assertThisInitialized_default()(_this), "START_CODE_B", 104);

    defineProperty_default()(assertThisInitialized_default()(_this), "START_CODE_C", 105);

    defineProperty_default()(assertThisInitialized_default()(_this), "STOP_CODE", 106);

    defineProperty_default()(assertThisInitialized_default()(_this), "CODE_PATTERN", [[2, 1, 2, 2, 2, 2], [2, 2, 2, 1, 2, 2], [2, 2, 2, 2, 2, 1], [1, 2, 1, 2, 2, 3], [1, 2, 1, 3, 2, 2], [1, 3, 1, 2, 2, 2], [1, 2, 2, 2, 1, 3], [1, 2, 2, 3, 1, 2], [1, 3, 2, 2, 1, 2], [2, 2, 1, 2, 1, 3], [2, 2, 1, 3, 1, 2], [2, 3, 1, 2, 1, 2], [1, 1, 2, 2, 3, 2], [1, 2, 2, 1, 3, 2], [1, 2, 2, 2, 3, 1], [1, 1, 3, 2, 2, 2], [1, 2, 3, 1, 2, 2], [1, 2, 3, 2, 2, 1], [2, 2, 3, 2, 1, 1], [2, 2, 1, 1, 3, 2], [2, 2, 1, 2, 3, 1], [2, 1, 3, 2, 1, 2], [2, 2, 3, 1, 1, 2], [3, 1, 2, 1, 3, 1], [3, 1, 1, 2, 2, 2], [3, 2, 1, 1, 2, 2], [3, 2, 1, 2, 2, 1], [3, 1, 2, 2, 1, 2], [3, 2, 2, 1, 1, 2], [3, 2, 2, 2, 1, 1], [2, 1, 2, 1, 2, 3], [2, 1, 2, 3, 2, 1], [2, 3, 2, 1, 2, 1], [1, 1, 1, 3, 2, 3], [1, 3, 1, 1, 2, 3], [1, 3, 1, 3, 2, 1], [1, 1, 2, 3, 1, 3], [1, 3, 2, 1, 1, 3], [1, 3, 2, 3, 1, 1], [2, 1, 1, 3, 1, 3], [2, 3, 1, 1, 1, 3], [2, 3, 1, 3, 1, 1], [1, 1, 2, 1, 3, 3], [1, 1, 2, 3, 3, 1], [1, 3, 2, 1, 3, 1], [1, 1, 3, 1, 2, 3], [1, 1, 3, 3, 2, 1], [1, 3, 3, 1, 2, 1], [3, 1, 3, 1, 2, 1], [2, 1, 1, 3, 3, 1], [2, 3, 1, 1, 3, 1], [2, 1, 3, 1, 1, 3], [2, 1, 3, 3, 1, 1], [2, 1, 3, 1, 3, 1], [3, 1, 1, 1, 2, 3], [3, 1, 1, 3, 2, 1], [3, 3, 1, 1, 2, 1], [3, 1, 2, 1, 1, 3], [3, 1, 2, 3, 1, 1], [3, 3, 2, 1, 1, 1], [3, 1, 4, 1, 1, 1], [2, 2, 1, 4, 1, 1], [4, 3, 1, 1, 1, 1], [1, 1, 1, 2, 2, 4], [1, 1, 1, 4, 2, 2], [1, 2, 1, 1, 2, 4], [1, 2, 1, 4, 2, 1], [1, 4, 1, 1, 2, 2], [1, 4, 1, 2, 2, 1], [1, 1, 2, 2, 1, 4], [1, 1, 2, 4, 1, 2], [1, 2, 2, 1, 1, 4], [1, 2, 2, 4, 1, 1], [1, 4, 2, 1, 1, 2], [1, 4, 2, 2, 1, 1], [2, 4, 1, 2, 1, 1], [2, 2, 1, 1, 1, 4], [4, 1, 3, 1, 1, 1], [2, 4, 1, 1, 1, 2], [1, 3, 4, 1, 1, 1], [1, 1, 1, 2, 4, 2], [1, 2, 1, 1, 4, 2], [1, 2, 1, 2, 4, 1], [1, 1, 4, 2, 1, 2], [1, 2, 4, 1, 1, 2], [1, 2, 4, 2, 1, 1], [4, 1, 1, 2, 1, 2], [4, 2, 1, 1, 1, 2], [4, 2, 1, 2, 1, 1], [2, 1, 2, 1, 4, 1], [2, 1, 4, 1, 2, 1], [4, 1, 2, 1, 2, 1], [1, 1, 1, 1, 4, 3], [1, 1, 1, 3, 4, 1], [1, 3, 1, 1, 4, 1], [1, 1, 4, 1, 1, 3], [1, 1, 4, 3, 1, 1], [4, 1, 1, 1, 1, 3], [4, 1, 1, 3, 1, 1], [1, 1, 3, 1, 4, 1], [1, 1, 4, 1, 3, 1], [3, 1, 1, 1, 4, 1], [4, 1, 1, 1, 3, 1], [2, 1, 1, 4, 1, 2], [2, 1, 1, 2, 1, 4], [2, 1, 1, 2, 3, 2], [2, 3, 3, 1, 1, 1, 2]]);

    defineProperty_default()(assertThisInitialized_default()(_this), "SINGLE_CODE_ERROR", 0.64);

    defineProperty_default()(assertThisInitialized_default()(_this), "AVG_CODE_ERROR", 0.30);

    defineProperty_default()(assertThisInitialized_default()(_this), "FORMAT", 'code_128');

    defineProperty_default()(assertThisInitialized_default()(_this), "MODULE_INDICES", {
      bar: [0, 2, 4],
      space: [1, 3, 5]
    });

    return _this;
  }

  createClass_default()(Code128Reader, [{
    key: "_decodeCode",
    value: function _decodeCode(start, correction) {
      var bestMatch = {
        error: Number.MAX_VALUE,
        code: -1,
        start: start,
        end: start,
        correction: {
          bar: 1,
          space: 1
        }
      };
      var counter = [0, 0, 0, 0, 0, 0];
      var offset = start;
      var isWhite = !this._row[offset];
      var counterPos = 0;

      for (var i = offset; i < this._row.length; i++) {
        if (this._row[i] ^ (isWhite ? 1 : 0)) {
          counter[counterPos]++;
        } else {
          if (counterPos === counter.length - 1) {
            if (correction) {
              this._correct(counter, correction);
            }

            for (var code = 0; code < this.CODE_PATTERN.length; code++) {
              var error = this._matchPattern(counter, this.CODE_PATTERN[code]);

              if (error < bestMatch.error) {
                bestMatch.code = code;
                bestMatch.error = error;
              }
            }

            bestMatch.end = i;

            if (bestMatch.code === -1 || bestMatch.error > this.AVG_CODE_ERROR) {
              return null;
            }

            if (this.CODE_PATTERN[bestMatch.code]) {
              bestMatch.correction.bar = this.calculateCorrection(this.CODE_PATTERN[bestMatch.code], counter, this.MODULE_INDICES.bar);
              bestMatch.correction.space = this.calculateCorrection(this.CODE_PATTERN[bestMatch.code], counter, this.MODULE_INDICES.space);
            }

            return bestMatch;
          } else {
            counterPos++;
          }

          counter[counterPos] = 1;
          isWhite = !isWhite;
        }
      }

      return null;
    }
  }, {
    key: "_correct",
    value: function _correct(counter, correction) {
      this._correctBars(counter, correction.bar, this.MODULE_INDICES.bar);

      this._correctBars(counter, correction.space, this.MODULE_INDICES.space);
    }
  }, {
    key: "_findStart",
    value: // TODO: _findStart and decodeCode share similar code, can we re-use some?
    function _findStart() {
      var counter = [0, 0, 0, 0, 0, 0];

      var offset = this._nextSet(this._row);

      var bestMatch = {
        error: Number.MAX_VALUE,
        code: -1,
        start: 0,
        end: 0,
        correction: {
          bar: 1,
          space: 1
        }
      };
      var isWhite = false;
      var counterPos = 0;

      for (var i = offset; i < this._row.length; i++) {
        if (this._row[i] ^ (isWhite ? 1 : 0)) {
          counter[counterPos]++;
        } else {
          if (counterPos === counter.length - 1) {
            var sum = counter.reduce(function (prev, next) {
              return prev + next;
            }, 0);

            for (var code = this.START_CODE_A; code <= this.START_CODE_C; code++) {
              var error = this._matchPattern(counter, this.CODE_PATTERN[code]);

              if (error < bestMatch.error) {
                bestMatch.code = code;
                bestMatch.error = error;
              }
            }

            if (bestMatch.error < this.AVG_CODE_ERROR) {
              bestMatch.start = i - sum;
              bestMatch.end = i;
              bestMatch.correction.bar = this.calculateCorrection(this.CODE_PATTERN[bestMatch.code], counter, this.MODULE_INDICES.bar);
              bestMatch.correction.space = this.calculateCorrection(this.CODE_PATTERN[bestMatch.code], counter, this.MODULE_INDICES.space);
              return bestMatch;
            }

            for (var j = 0; j < 4; j++) {
              counter[j] = counter[j + 2];
            }

            counter[4] = 0;
            counter[5] = 0;
            counterPos--;
          } else {
            counterPos++;
          }

          counter[counterPos] = 1;
          isWhite = !isWhite;
        }
      }

      return null;
    }
  }, {
    key: "decode",
    value: function decode(row, start) {
      var _this2 = this;

      var startInfo = this._findStart();

      if (startInfo === null) {
        return null;
      } // var self = this,
      //     done = false,
      //     result = [],
      //     multiplier = 0,
      //     checksum = 0,
      //     codeset,
      //     rawResult = [],
      //     decodedCodes = [],
      //     shiftNext = false,
      //     unshift,
      //     removeLastCharacter = true;


      var code = {
        code: startInfo.code,
        start: startInfo.start,
        end: startInfo.end,
        correction: {
          bar: startInfo.correction.bar,
          space: startInfo.correction.space
        }
      };
      var decodedCodes = [];
      decodedCodes.push(code);
      var checksum = code.code;

      var codeset = function (c) {
        switch (c) {
          case _this2.START_CODE_A:
            return _this2.CODE_A;

          case _this2.START_CODE_B:
            return _this2.CODE_B;

          case _this2.START_CODE_C:
            return _this2.CODE_C;

          default:
            return null;
        }
      }(code.code);

      var done = false;
      var shiftNext = false;
      var unshift = shiftNext;
      var removeLastCharacter = true;
      var multiplier = 0;
      var rawResult = [];
      var result = []; // TODO: i think this should be string only, but it creates problems if it is

      while (!done) {
        unshift = shiftNext;
        shiftNext = false;
        code = this._decodeCode(code.end, code.correction);

        if (code !== null) {
          if (code.code !== this.STOP_CODE) {
            removeLastCharacter = true;
          }

          if (code.code !== this.STOP_CODE) {
            rawResult.push(code.code);
            multiplier++;
            checksum += multiplier * code.code;
          }

          decodedCodes.push(code);

          switch (codeset) {
            case this.CODE_A:
              if (code.code < 64) {
                result.push(String.fromCharCode(32 + code.code));
              } else if (code.code < 96) {
                result.push(String.fromCharCode(code.code - 64));
              } else {
                if (code.code !== this.STOP_CODE) {
                  removeLastCharacter = false;
                }

                switch (code.code) {
                  case this.CODE_SHIFT:
                    shiftNext = true;
                    codeset = this.CODE_B;
                    break;

                  case this.CODE_B:
                    codeset = this.CODE_B;
                    break;

                  case this.CODE_C:
                    codeset = this.CODE_C;
                    break;

                  case this.STOP_CODE:
                    done = true;
                    break;
                }
              }

              break;

            case this.CODE_B:
              if (code.code < 96) {
                result.push(String.fromCharCode(32 + code.code));
              } else {
                if (code.code !== this.STOP_CODE) {
                  removeLastCharacter = false;
                }

                switch (code.code) {
                  case this.CODE_SHIFT:
                    shiftNext = true;
                    codeset = this.CODE_A;
                    break;

                  case this.CODE_A:
                    codeset = this.CODE_A;
                    break;

                  case this.CODE_C:
                    codeset = this.CODE_C;
                    break;

                  case this.STOP_CODE:
                    done = true;
                    break;
                }
              }

              break;

            case this.CODE_C:
              if (code.code < 100) {
                result.push(code.code < 10 ? '0' + code.code : code.code);
              } else {
                if (code.code !== this.STOP_CODE) {
                  removeLastCharacter = false;
                }

                switch (code.code) {
                  case this.CODE_A:
                    codeset = this.CODE_A;
                    break;

                  case this.CODE_B:
                    codeset = this.CODE_B;
                    break;

                  case this.STOP_CODE:
                    done = true;
                    break;
                }
              }

              break;
          }
        } else {
          done = true;
        }

        if (unshift) {
          codeset = codeset === this.CODE_A ? this.CODE_B : this.CODE_A;
        }
      }

      if (code === null) {
        return null;
      }

      code.end = this._nextUnset(this._row, code.end);

      if (!this._verifyTrailingWhitespace(code)) {
        return null;
      }

      checksum -= multiplier * rawResult[rawResult.length - 1];

      if (checksum % 103 !== rawResult[rawResult.length - 1]) {
        return null;
      }

      if (!result.length) {
        return null;
      } // remove last code from result (checksum)


      if (removeLastCharacter) {
        result.splice(result.length - 1, 1);
      }

      return {
        code: result.join(''),
        start: startInfo.start,
        end: code.end,
        codeset: codeset,
        startInfo: startInfo,
        decodedCodes: decodedCodes,
        endInfo: code,
        format: this.FORMAT
      };
    }
  }, {
    key: "_verifyTrailingWhitespace",
    value: function _verifyTrailingWhitespace(endInfo) {
      var self = this,
          trailingWhitespaceEnd;
      trailingWhitespaceEnd = endInfo.end + (endInfo.end - endInfo.start) / 2;

      if (trailingWhitespaceEnd < self._row.length) {
        if (self._matchRange(endInfo.end, trailingWhitespaceEnd, 0)) {
          return endInfo;
        }
      }

      return null;
    }
  }, {
    key: "calculateCorrection",
    value: function calculateCorrection(expected, normalized, indices) {
      var length = indices.length,
          sumNormalized = 0,
          sumExpected = 0;

      while (length--) {
        sumExpected += expected[indices[length]];
        sumNormalized += normalized[indices[length]];
      }

      return sumExpected / sumNormalized;
    }
  }]);

  return Code128Reader;
}(barcode_reader);

/* harmony default export */ var code_128_reader = (code_128_reader_Code128Reader);
// CONCATENATED MODULE: ./src/reader/ean_reader.ts








function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function ean_reader_createSuper(Derived) { var hasNativeReflectConstruct = ean_reader_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function ean_reader_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }


 // const CODE_L_START = 0;

var CODE_G_START = 10;

var START_PATTERN = [1, 1, 1];
var MIDDLE_PATTERN = [1, 1, 1, 1, 1];

var EXTENSION_START_PATTERN = [1, 1, 2];
var CODE_PATTERN = [[3, 2, 1, 1], [2, 2, 2, 1], [2, 1, 2, 2], [1, 4, 1, 1], [1, 1, 3, 2], [1, 2, 3, 1], [1, 1, 1, 4], [1, 3, 1, 2], [1, 2, 1, 3], [3, 1, 1, 2], [1, 1, 2, 3], [1, 2, 2, 2], [2, 2, 1, 2], [1, 1, 4, 1], [2, 3, 1, 1], [1, 3, 2, 1], [4, 1, 1, 1], [2, 1, 3, 1], [3, 1, 2, 1], [2, 1, 1, 3]];
var CODE_FREQUENCY = [0, 11, 13, 14, 19, 25, 28, 21, 22, 26]; // const SINGLE_CODE_ERROR = 0.70;

var AVG_CODE_ERROR = 0.48;

var ean_reader_EANReader = /*#__PURE__*/function (_BarcodeReader) {
  inherits_default()(EANReader, _BarcodeReader);

  var _super = ean_reader_createSuper(EANReader);

  // TODO: does this need to be in the class?
  function EANReader(config, supplements) {
    var _this;

    classCallCheck_default()(this, EANReader);

    _this = _super.call(this, merge_default()({
      supplements: []
    }, config), supplements);

    defineProperty_default()(assertThisInitialized_default()(_this), "FORMAT", 'ean_13');

    defineProperty_default()(assertThisInitialized_default()(_this), "SINGLE_CODE_ERROR", 0.70);

    defineProperty_default()(assertThisInitialized_default()(_this), "STOP_PATTERN", [1, 1, 1]);

    return _this;
  }

  createClass_default()(EANReader, [{
    key: "_findPattern",
    value: function _findPattern(pattern, offset, isWhite, tryHarder) {
      var counter = new Array(pattern.length).fill(0);
      var bestMatch = {
        error: Number.MAX_VALUE,
        start: 0,
        end: 0
      };
      var epsilon = AVG_CODE_ERROR; // console.warn('* findPattern', pattern, offset, isWhite, tryHarder, epsilon);

      var counterPos = 0;

      if (!offset) {
        offset = this._nextSet(this._row);
      }

      var found = false;

      for (var i = offset; i < this._row.length; i++) {
        // console.warn(`* loop i=${offset} len=${this._row.length} isWhite=${isWhite} counterPos=${counterPos}`);
        if (this._row[i] ^ (isWhite ? 1 : 0)) {
          counter[counterPos] += 1;
        } else {
          if (counterPos === counter.length - 1) {
            var error = this._matchPattern(counter, pattern); // console.warn('* matchPattern', error, counter, pattern);


            if (error < epsilon && bestMatch.error && error < bestMatch.error) {
              found = true;
              bestMatch.error = error;
              bestMatch.start = i - counter.reduce(function (sum, value) {
                return sum + value;
              }, 0);
              bestMatch.end = i; // console.warn('* return bestMatch', JSON.stringify(bestMatch));

              return bestMatch;
            }

            if (tryHarder) {
              for (var j = 0; j < counter.length - 2; j++) {
                counter[j] = counter[j + 2];
              }

              counter[counter.length - 2] = 0;
              counter[counter.length - 1] = 0;
              counterPos--;
            }
          } else {
            counterPos++;
          }

          counter[counterPos] = 1;
          isWhite = !isWhite;
        }
      }

      if (found) {// console.warn('* return bestMatch', JSON.stringify(bestMatch));
      } else {// console.warn('* return null');
      }

      return found ? bestMatch : null;
    } // TODO: findPattern and decodeCode appear to share quite similar code, can it be reduced?

  }, {
    key: "_decodeCode",
    value: function _decodeCode(start, coderange) {
      // console.warn('* decodeCode', start, coderange);
      var counter = [0, 0, 0, 0];
      var offset = start;
      var bestMatch = {
        error: Number.MAX_VALUE,
        code: -1,
        start: start,
        end: start
      };
      var epsilon = AVG_CODE_ERROR;
      var isWhite = !this._row[offset];
      var counterPos = 0;

      if (!coderange) {
        // console.warn('* decodeCode before length');
        coderange = CODE_PATTERN.length; // console.warn('* decodeCode after length');
      }

      var found = false;

      for (var i = offset; i < this._row.length; i++) {
        if (this._row[i] ^ (isWhite ? 1 : 0)) {
          counter[counterPos]++;
        } else {
          if (counterPos === counter.length - 1) {
            for (var code = 0; code < coderange; code++) {
              var error = this._matchPattern(counter, CODE_PATTERN[code]);

              bestMatch.end = i;

              if (error < bestMatch.error) {
                bestMatch.code = code;
                bestMatch.error = error;
              }
            }

            if (bestMatch.error > epsilon) {
              // console.warn('* return null');
              return null;
            } // console.warn('* return bestMatch', JSON.stringify(bestMatch));


            return bestMatch;
          } else {
            counterPos++;
          }

          counter[counterPos] = 1;
          isWhite = !isWhite;
        }
      }

      return found ? bestMatch : null;
    }
  }, {
    key: "_findStart",
    value: function _findStart() {
      // console.warn('* findStart');
      var offset = this._nextSet(this._row);

      var startInfo = null;

      while (!startInfo) {
        startInfo = this._findPattern(START_PATTERN, offset, false, true); // console.warn('* startInfo=', JSON.stringify(startInfo));

        if (!startInfo) {
          return null;
        }

        var leadingWhitespaceStart = startInfo.start - (startInfo.end - startInfo.start);

        if (leadingWhitespaceStart >= 0) {
          if (this._matchRange(leadingWhitespaceStart, startInfo.start, 0)) {
            // console.warn('* returning startInfo');
            return startInfo;
          }
        }

        offset = startInfo.end;
        startInfo = null;
      } // console.warn('* returning null');


      return null;
    }
  }, {
    key: "_calculateFirstDigit",
    value: function _calculateFirstDigit(codeFrequency) {
      // console.warn('* calculateFirstDigit', codeFrequency);
      for (var i = 0; i < CODE_FREQUENCY.length; i++) {
        if (codeFrequency === CODE_FREQUENCY[i]) {
          // console.warn('* returning', i);
          return i;
        }
      } // console.warn('* return null');


      return null;
    }
  }, {
    key: "_decodePayload",
    value: function _decodePayload(inCode, result, decodedCodes) {
      // console.warn('* decodePayload', inCode, result, decodedCodes);
      var outCode = _objectSpread({}, inCode);

      var codeFrequency = 0x0;

      for (var i = 0; i < 6; i++) {
        outCode = this._decodeCode(outCode.end); // console.warn('* decodeCode=', outCode);

        if (!outCode) {
          // console.warn('* return null');
          return null;
        }

        if (outCode.code >= CODE_G_START) {
          outCode.code -= CODE_G_START;
          codeFrequency |= 1 << 5 - i;
        } else {
          codeFrequency |= 0 << 5 - i;
        }

        result.push(outCode.code);
        decodedCodes.push(outCode);
      }

      var firstDigit = this._calculateFirstDigit(codeFrequency); // console.warn('* firstDigit=', firstDigit);


      if (firstDigit === null) {
        // console.warn('* return null');
        return null;
      }

      result.unshift(firstDigit);

      var middlePattern = this._findPattern(MIDDLE_PATTERN, outCode.end, true, false); // console.warn('* findPattern=', JSON.stringify(middlePattern));


      if (middlePattern === null || !middlePattern.end) {
        // console.warn('* return null');
        return null;
      }

      decodedCodes.push(middlePattern);

      for (var _i = 0; _i < 6; _i++) {
        middlePattern = this._decodeCode(middlePattern.end, CODE_G_START); // console.warn('* decodeCode=', JSON.stringify(middlePattern));

        if (!middlePattern) {
          // console.warn('* return null');
          return null;
        }

        decodedCodes.push(middlePattern);
        result.push(middlePattern.code);
      } // console.warn('* end code=', JSON.stringify(middlePattern));
      // console.warn('* end result=', JSON.stringify(result));
      // console.warn('* end decodedCodes=', decodedCodes);


      return middlePattern;
    }
  }, {
    key: "_verifyTrailingWhitespace",
    value: function _verifyTrailingWhitespace(endInfo) {
      // console.warn('* verifyTrailingWhitespace', JSON.stringify(endInfo));
      var trailingWhitespaceEnd = endInfo.end + (endInfo.end - endInfo.start);

      if (trailingWhitespaceEnd < this._row.length) {
        if (this._matchRange(endInfo.end, trailingWhitespaceEnd, 0)) {
          // console.warn('* returning', JSON.stringify(endInfo));
          return endInfo;
        }
      } // console.warn('* return null');


      return null;
    }
  }, {
    key: "_findEnd",
    value: function _findEnd(offset, isWhite) {
      // console.warn('* findEnd', offset, isWhite);
      var endInfo = this._findPattern(this.STOP_PATTERN, offset, isWhite, false);

      return endInfo !== null ? this._verifyTrailingWhitespace(endInfo) : null;
    }
  }, {
    key: "_checksum",
    value: function _checksum(result) {
      // console.warn('* _checksum', result);
      var sum = 0;

      for (var i = result.length - 2; i >= 0; i -= 2) {
        sum += result[i];
      }

      sum *= 3;

      for (var _i2 = result.length - 1; _i2 >= 0; _i2 -= 2) {
        sum += result[_i2];
      } // console.warn('* end checksum', sum % 10 === 0);


      return sum % 10 === 0;
    }
  }, {
    key: "_decodeExtensions",
    value: function _decodeExtensions(offset) {
      var start = this._nextSet(this._row, offset);

      var startInfo = this._findPattern(EXTENSION_START_PATTERN, start, false, false);

      if (startInfo === null) {
        return null;
      } // console.warn('* decodeExtensions', this.supplements);
      // console.warn('* there are ', this.supplements.length, ' supplements');


      for (var i = 0; i < this.supplements.length; i++) {
        // console.warn('* extensions loop', i, this.supplements[i], this.supplements[i]._decode);
        try {
          var result = this.supplements[i].decode(this._row, startInfo.end); // console.warn('* decode result=', result);

          if (result !== null) {
            return {
              code: result.code,
              start: start,
              startInfo: startInfo,
              end: result.end,
              decodedCodes: result.decodedCodes,
              format: this.supplements[i].FORMAT
            };
          }
        } catch (err) {
          console.error('* decodeExtensions error in ', this.supplements[i], ': ', err);
        }
      } // console.warn('* end decodeExtensions');


      return null;
    }
  }, {
    key: "decode",
    value: function decode(row, start) {
      // console.warn('* decode', row);
      // console.warn('* decode', start);
      var result = new Array();
      var decodedCodes = new Array();
      var resultInfo = {};

      var startInfo = this._findStart();

      if (!startInfo) {
        return null;
      }

      var code = {
        start: startInfo.start,
        end: startInfo.end
      };
      decodedCodes.push(code);
      code = this._decodePayload(code, result, decodedCodes);

      if (!code) {
        return null;
      }

      code = this._findEnd(code.end, false);

      if (!code) {
        return null;
      }

      decodedCodes.push(code); // Checksum

      if (!this._checksum(result)) {
        return null;
      } // console.warn('* this.supplements=', this.supplements);


      if (this.supplements.length > 0) {
        var supplement = this._decodeExtensions(code.end); // console.warn('* decodeExtensions returns', supplement);


        if (!supplement) {
          return null;
        }

        if (!supplement.decodedCodes) {
          return null;
        }

        var lastCode = supplement.decodedCodes[supplement.decodedCodes.length - 1];
        var endInfo = {
          start: lastCode.start + ((lastCode.end - lastCode.start) / 2 | 0),
          end: lastCode.end
        };

        if (!this._verifyTrailingWhitespace(endInfo)) {
          return null;
        }

        resultInfo = {
          supplement: supplement,
          code: result.join('') + supplement.code
        };
      }

      return _objectSpread(_objectSpread({
        code: result.join(''),
        start: startInfo.start,
        end: code.end,
        startInfo: startInfo,
        decodedCodes: decodedCodes
      }, resultInfo), {}, {
        format: this.FORMAT
      });
    }
  }]);

  return EANReader;
}(barcode_reader);

/* harmony default export */ var ean_reader = (ean_reader_EANReader);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/toConsumableArray.js
var toConsumableArray = __webpack_require__(34);
var toConsumableArray_default = /*#__PURE__*/__webpack_require__.n(toConsumableArray);

// CONCATENATED MODULE: ./src/reader/code_39_reader.ts









function code_39_reader_createSuper(Derived) { var hasNativeReflectConstruct = code_39_reader_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function code_39_reader_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }



var ALPHABETH_STRING = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. *$/+%';
var ALPHABET = new Uint16Array(toConsumableArray_default()(ALPHABETH_STRING).map(function (_char) {
  return _char.charCodeAt(0);
}));
var CHARACTER_ENCODINGS = new Uint16Array([0x034, 0x121, 0x061, 0x160, 0x031, 0x130, 0x070, 0x025, 0x124, 0x064, 0x109, 0x049, 0x148, 0x019, 0x118, 0x058, 0x00D, 0x10C, 0x04C, 0x01C, 0x103, 0x043, 0x142, 0x013, 0x112, 0x052, 0x007, 0x106, 0x046, 0x016, 0x181, 0x0C1, 0x1C0, 0x091, 0x190, 0x0D0, 0x085, 0x184, 0x0C4, 0x094, 0x0A8, 0x0A2, 0x08A, 0x02A]);
var ASTERISK = 0x094;

var code_39_reader_Code39Reader = /*#__PURE__*/function (_BarcodeReader) {
  inherits_default()(Code39Reader, _BarcodeReader);

  var _super = code_39_reader_createSuper(Code39Reader);

  function Code39Reader() {
    var _this;

    classCallCheck_default()(this, Code39Reader);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    defineProperty_default()(assertThisInitialized_default()(_this), "FORMAT", 'code_39');

    return _this;
  }

  createClass_default()(Code39Reader, [{
    key: "_findStart",
    value: function _findStart() {
      var offset = this._nextSet(this._row);

      var patternStart = offset;
      var counter = new Uint16Array([0, 0, 0, 0, 0, 0, 0, 0, 0]);
      var counterPos = 0;
      var isWhite = false;

      for (var i = offset; i < this._row.length; i++) {
        if (this._row[i] ^ (isWhite ? 1 : 0)) {
          counter[counterPos]++;
        } else {
          if (counterPos === counter.length - 1) {
            // find start pattern
            if (this._toPattern(counter) === ASTERISK) {
              var whiteSpaceMustStart = Math.floor(Math.max(0, patternStart - (i - patternStart) / 4));

              if (this._matchRange(whiteSpaceMustStart, patternStart, 0)) {
                return {
                  start: patternStart,
                  end: i
                };
              }
            }

            patternStart += counter[0] + counter[1];

            for (var j = 0; j < 7; j++) {
              counter[j] = counter[j + 2];
            }

            counter[7] = 0;
            counter[8] = 0;
            counterPos--;
          } else {
            counterPos++;
          }

          counter[counterPos] = 1;
          isWhite = !isWhite;
        }
      }

      return null;
    }
  }, {
    key: "_toPattern",
    value: function _toPattern(counters) {
      var numCounters = counters.length;
      var maxNarrowWidth = 0;
      var numWideBars = numCounters;
      var wideBarWidth = 0;

      while (numWideBars > 3) {
        maxNarrowWidth = this._findNextWidth(counters, maxNarrowWidth);
        numWideBars = 0;
        var pattern = 0;

        for (var i = 0; i < numCounters; i++) {
          if (counters[i] > maxNarrowWidth) {
            pattern |= 1 << numCounters - 1 - i;
            numWideBars++;
            wideBarWidth += counters[i];
          }
        }

        if (numWideBars === 3) {
          for (var _i = 0; _i < numCounters && numWideBars > 0; _i++) {
            if (counters[_i] > maxNarrowWidth) {
              numWideBars--;

              if (counters[_i] * 2 >= wideBarWidth) {
                return -1;
              }
            }
          }

          return pattern;
        }
      }

      return -1;
    }
  }, {
    key: "_findNextWidth",
    value: function _findNextWidth(counters, current) {
      var minWidth = Number.MAX_VALUE;

      for (var i = 0; i < counters.length; i++) {
        if (counters[i] < minWidth && counters[i] > current) {
          minWidth = counters[i];
        }
      }

      return minWidth;
    }
  }, {
    key: "_patternToChar",
    value: function _patternToChar(pattern) {
      for (var i = 0; i < CHARACTER_ENCODINGS.length; i++) {
        if (CHARACTER_ENCODINGS[i] === pattern) {
          return String.fromCharCode(ALPHABET[i]);
        }
      }

      return null;
    }
  }, {
    key: "_verifyTrailingWhitespace",
    value: function _verifyTrailingWhitespace(lastStart, nextStart, counters) {
      var patternSize = array_helper["a" /* default */].sum(counters);
      var trailingWhitespaceEnd = nextStart - lastStart - patternSize;

      if (trailingWhitespaceEnd * 3 >= patternSize) {
        return true;
      }

      return false;
    }
  }, {
    key: "decode",
    value: function decode(row, start) {
      var counters = new Uint16Array([0, 0, 0, 0, 0, 0, 0, 0, 0]);
      var result = [];
      start = this._findStart();

      if (!start) {
        return null;
      }

      var nextStart = this._nextSet(this._row, start.end);

      var decodedChar;
      var lastStart;

      do {
        counters = this._toCounters(nextStart, counters);

        var pattern = this._toPattern(counters);

        if (pattern < 0) {
          return null;
        }

        decodedChar = this._patternToChar(pattern);

        if (decodedChar === null) {
          return null;
        }

        result.push(decodedChar);
        lastStart = nextStart;
        nextStart += array_helper["a" /* default */].sum(counters);
        nextStart = this._nextSet(this._row, nextStart);
      } while (decodedChar !== '*');

      result.pop();

      if (!result.length) {
        return null;
      }

      if (!this._verifyTrailingWhitespace(lastStart, nextStart, counters)) {
        return null;
      }

      return {
        code: result.join(''),
        start: start.start,
        end: nextStart,
        startInfo: start,
        decodedCodes: result,
        format: this.FORMAT
      };
    }
  }]);

  return Code39Reader;
}(barcode_reader);

/* harmony default export */ var code_39_reader = (code_39_reader_Code39Reader);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/get.js
var get = __webpack_require__(12);
var get_default = /*#__PURE__*/__webpack_require__.n(get);

// CONCATENATED MODULE: ./src/reader/code_39_vin_reader.ts









function code_39_vin_reader_createSuper(Derived) { var hasNativeReflectConstruct = code_39_vin_reader_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function code_39_vin_reader_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }


var patterns = {
  IOQ: /[IOQ]/g,
  AZ09: /[A-Z0-9]{17}/
};

var code_39_vin_reader_Code39VINReader = /*#__PURE__*/function (_Code39Reader) {
  inherits_default()(Code39VINReader, _Code39Reader);

  var _super = code_39_vin_reader_createSuper(Code39VINReader);

  function Code39VINReader() {
    var _this;

    classCallCheck_default()(this, Code39VINReader);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    defineProperty_default()(assertThisInitialized_default()(_this), "FORMAT", 'code_39_vin');

    return _this;
  }

  createClass_default()(Code39VINReader, [{
    key: "_checkChecksum",
    value: // TODO (this was todo in original repo, no text was there. sorry.)
    function _checkChecksum(code) {
      return !!code;
    } // Cribbed from:
    // https://github.com/zxing/zxing/blob/master/core/src/main/java/com/google/zxing/client/result/VINResultParser.java

  }, {
    key: "decode",
    value: function decode(row, start) {
      var result = get_default()(getPrototypeOf_default()(Code39VINReader.prototype), "decode", this).call(this, row, start);

      if (!result) {
        return null;
      }

      var code = result.code;

      if (!code) {
        return null;
      }

      code = code.replace(patterns.IOQ, '');

      if (!code.match(patterns.AZ09)) {
        if (false) {}

        return null;
      }

      if (!this._checkChecksum(code)) {
        return null;
      }

      result.code = code;
      return result;
    }
  }]);

  return Code39VINReader;
}(code_39_reader);

/* harmony default export */ var code_39_vin_reader = (code_39_vin_reader_Code39VINReader);
// CONCATENATED MODULE: ./src/reader/codabar_reader.ts








function codabar_reader_createSuper(Derived) { var hasNativeReflectConstruct = codabar_reader_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function codabar_reader_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

 // const ALPHABETH_STRING = '0123456789-$:/.+ABCD';

var codabar_reader_ALPHABET = [48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 45, 36, 58, 47, 46, 43, 65, 66, 67, 68];
var codabar_reader_CHARACTER_ENCODINGS = [0x003, 0x006, 0x009, 0x060, 0x012, 0x042, 0x021, 0x024, 0x030, 0x048, 0x00c, 0x018, 0x045, 0x051, 0x054, 0x015, 0x01A, 0x029, 0x00B, 0x00E];
var START_END = [0x01A, 0x029, 0x00B, 0x00E];
var MIN_ENCODED_CHARS = 4;
var MAX_ACCEPTABLE = 2.0;
var PADDING = 1.5;
;
;

var codabar_reader_NewCodabarReader = /*#__PURE__*/function (_BarcodeReader) {
  inherits_default()(NewCodabarReader, _BarcodeReader);

  var _super = codabar_reader_createSuper(NewCodabarReader);

  function NewCodabarReader() {
    var _this;

    classCallCheck_default()(this, NewCodabarReader);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    defineProperty_default()(assertThisInitialized_default()(_this), "_counters", []);

    defineProperty_default()(assertThisInitialized_default()(_this), "FORMAT", 'codabar');

    return _this;
  }

  createClass_default()(NewCodabarReader, [{
    key: "_computeAlternatingThreshold",
    value: function _computeAlternatingThreshold(offset, end) {
      var min = Number.MAX_VALUE;
      var max = 0;
      var counter = 0;

      for (var i = offset; i < end; i += 2) {
        counter = this._counters[i];

        if (counter > max) {
          max = counter;
        }

        if (counter < min) {
          min = counter;
        }
      }

      return (min + max) / 2.0 | 0;
    }
  }, {
    key: "_toPattern",
    value: function _toPattern(offset) {
      var numCounters = 7;
      var end = offset + numCounters;

      if (end > this._counters.length) {
        return -1;
      }

      var barThreshold = this._computeAlternatingThreshold(offset, end);

      var spaceThreshold = this._computeAlternatingThreshold(offset + 1, end);

      var bitmask = 1 << numCounters - 1;
      var threshold = 0;
      var pattern = 0;

      for (var i = 0; i < numCounters; i++) {
        threshold = (i & 1) === 0 ? barThreshold : spaceThreshold;

        if (this._counters[offset + i] > threshold) {
          pattern |= bitmask;
        }

        bitmask >>= 1;
      }

      return pattern;
    }
  }, {
    key: "_isStartEnd",
    value: function _isStartEnd(pattern) {
      for (var i = 0; i < START_END.length; i++) {
        if (START_END[i] === pattern) {
          return true;
        }
      }

      return false;
    }
  }, {
    key: "_sumCounters",
    value: function _sumCounters(start, end) {
      var sum = 0;

      for (var i = start; i < end; i++) {
        sum += this._counters[i];
      }

      return sum;
    }
  }, {
    key: "_findStart",
    value: function _findStart() {
      var start = this._nextUnset(this._row);

      var end = start;

      for (var i = 1; i < this._counters.length; i++) {
        var pattern = this._toPattern(i);

        if (pattern !== -1 && this._isStartEnd(pattern)) {
          // TODO: Look for whitespace ahead
          start += this._sumCounters(0, i);
          end = start + this._sumCounters(i, i + 8);
          return {
            start: start,
            end: end,
            startCounter: i,
            endCounter: i + 8
          };
        }
      }

      return null;
    }
  }, {
    key: "_patternToChar",
    value: function _patternToChar(pattern) {
      for (var i = 0; i < codabar_reader_CHARACTER_ENCODINGS.length; i++) {
        if (codabar_reader_CHARACTER_ENCODINGS[i] === pattern) {
          return String.fromCharCode(codabar_reader_ALPHABET[i]);
        }
      }

      return null;
    }
  }, {
    key: "_calculatePatternLength",
    value: function _calculatePatternLength(offset) {
      var sum = 0;

      for (var i = offset; i < offset + 7; i++) {
        sum += this._counters[i];
      }

      return sum;
    }
  }, {
    key: "_verifyWhitespace",
    value: function _verifyWhitespace(startCounter, endCounter) {
      if (startCounter - 1 <= 0 || this._counters[startCounter - 1] >= this._calculatePatternLength(startCounter) / 2.0) {
        if (endCounter + 8 >= this._counters.length || this._counters[endCounter + 7] >= this._calculatePatternLength(endCounter) / 2.0) {
          return true;
        }
      }

      return false;
    }
  }, {
    key: "_charToPattern",
    value: function _charToPattern(_char) {
      var charCode = _char.charCodeAt(0);

      for (var i = 0; i < codabar_reader_ALPHABET.length; i++) {
        if (codabar_reader_ALPHABET[i] === charCode) {
          return codabar_reader_CHARACTER_ENCODINGS[i];
        }
      }

      return 0x0;
    }
  }, {
    key: "_thresholdResultPattern",
    value: function _thresholdResultPattern(result, startCounter) {
      var categorization = {
        space: {
          narrow: {
            size: 0,
            counts: 0,
            min: 0,
            max: Number.MAX_VALUE
          },
          wide: {
            size: 0,
            counts: 0,
            min: 0,
            max: Number.MAX_VALUE
          }
        },
        bar: {
          narrow: {
            size: 0,
            counts: 0,
            min: 0,
            max: Number.MAX_VALUE
          },
          wide: {
            size: 0,
            counts: 0,
            min: 0,
            max: Number.MAX_VALUE
          }
        }
      };
      var pos = startCounter;
      var pattern;

      for (var i = 0; i < result.length; i++) {
        pattern = this._charToPattern(result[i]);

        for (var j = 6; j >= 0; j--) {
          var kind = (j & 1) === 2 ? categorization.bar : categorization.space;
          var cat = (pattern & 1) === 1 ? kind.wide : kind.narrow;
          cat.size += this._counters[pos + j];
          cat.counts++;
          pattern >>= 1;
        }

        pos += 8;
      }

      ['space', 'bar'].forEach(function (key) {
        var newkind = categorization[key];
        newkind.wide.min = Math.floor((newkind.narrow.size / newkind.narrow.counts + newkind.wide.size / newkind.wide.counts) / 2);
        newkind.narrow.max = Math.ceil(newkind.wide.min);
        newkind.wide.max = Math.ceil((newkind.wide.size * MAX_ACCEPTABLE + PADDING) / newkind.wide.counts);
      });
      return categorization;
    }
  }, {
    key: "_validateResult",
    value: function _validateResult(result, startCounter) {
      var thresholds = this._thresholdResultPattern(result, startCounter);

      var pos = startCounter;
      var pattern;

      for (var i = 0; i < result.length; i++) {
        pattern = this._charToPattern(result[i]);

        for (var j = 6; j >= 0; j--) {
          var kind = (j & 1) === 0 ? thresholds.bar : thresholds.space;
          var cat = (pattern & 1) === 1 ? kind.wide : kind.narrow;
          var size = this._counters[pos + j];

          if (size < cat.min || size > cat.max) {
            return false;
          }

          pattern >>= 1;
        }

        pos += 8;
      }

      return true;
    }
  }, {
    key: "decode",
    value: function decode(row, start) {
      this._counters = this._fillCounters();
      start = this._findStart();

      if (!start) {
        return null;
      }

      var nextStart = start.startCounter;
      var result = [];
      var pattern;

      do {
        pattern = this._toPattern(nextStart);

        if (pattern < 0) {
          return null;
        }

        var decodedChar = this._patternToChar(pattern);

        if (decodedChar === null) {
          return null;
        }

        result.push(decodedChar);
        nextStart += 8;

        if (result.length > 1 && this._isStartEnd(pattern)) {
          break;
        }
      } while (nextStart < this._counters.length); // verify end


      if (result.length - 2 < MIN_ENCODED_CHARS || !this._isStartEnd(pattern)) {
        return null;
      } // verify end white space


      if (!this._verifyWhitespace(start.startCounter, nextStart - 8)) {
        return null;
      }

      if (!this._validateResult(result, start.startCounter)) {
        return null;
      }

      nextStart = nextStart > this._counters.length ? this._counters.length : nextStart;

      var end = start.start + this._sumCounters(start.startCounter, nextStart - 8);

      return {
        code: result.join(''),
        start: start.start,
        end: end,
        startInfo: start,
        decodedCodes: result,
        format: this.FORMAT // TODO: i think it should not be required to return format from this, as barcode_reader force sets the format anyway

      };
    }
  }]);

  return NewCodabarReader;
}(barcode_reader);

/* harmony default export */ var codabar_reader = (codabar_reader_NewCodabarReader);
// CONCATENATED MODULE: ./src/reader/upc_reader.ts








function upc_reader_createSuper(Derived) { var hasNativeReflectConstruct = upc_reader_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function upc_reader_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }



var upc_reader_UPCReader = /*#__PURE__*/function (_EANReader) {
  inherits_default()(UPCReader, _EANReader);

  var _super = upc_reader_createSuper(UPCReader);

  function UPCReader() {
    var _this;

    classCallCheck_default()(this, UPCReader);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    defineProperty_default()(assertThisInitialized_default()(_this), "FORMAT", 'upc_a');

    return _this;
  }

  createClass_default()(UPCReader, [{
    key: "decode",
    value: function decode(row, start) {
      var result = ean_reader.prototype.decode.call(this);

      if (result && result.code && result.code.length === 13 && result.code.charAt(0) === '0') {
        result.code = result.code.substring(1);
        return result;
      }

      return null;
    }
  }]);

  return UPCReader;
}(ean_reader);

/* harmony default export */ var upc_reader = (upc_reader_UPCReader);
// CONCATENATED MODULE: ./src/reader/ean_8_reader.ts








function ean_8_reader_createSuper(Derived) { var hasNativeReflectConstruct = ean_8_reader_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function ean_8_reader_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }



var ean_8_reader_EAN8Reader = /*#__PURE__*/function (_EANReader) {
  inherits_default()(EAN8Reader, _EANReader);

  var _super = ean_8_reader_createSuper(EAN8Reader);

  function EAN8Reader() {
    var _this;

    classCallCheck_default()(this, EAN8Reader);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    defineProperty_default()(assertThisInitialized_default()(_this), "FORMAT", 'ean_8');

    return _this;
  }

  createClass_default()(EAN8Reader, [{
    key: "_decodePayload",
    value: function _decodePayload(inCode, result, decodedCodes) {
      var code = inCode;

      for (var i = 0; i < 4; i++) {
        code = this._decodeCode(code.end, CODE_G_START);

        if (!code) {
          return null;
        }

        result.push(code.code);
        decodedCodes.push(code);
      }

      code = this._findPattern(MIDDLE_PATTERN, code.end, true, false);

      if (code === null) {
        return null;
      }

      decodedCodes.push(code);

      for (var _i = 0; _i < 4; _i++) {
        code = this._decodeCode(code.end, CODE_G_START);

        if (!code) {
          return null;
        }

        decodedCodes.push(code);
        result.push(code.code);
      }

      return code;
    }
  }]);

  return EAN8Reader;
}(ean_reader);

/* harmony default export */ var ean_8_reader = (ean_8_reader_EAN8Reader);
// CONCATENATED MODULE: ./src/reader/ean_2_reader.ts








function ean_2_reader_createSuper(Derived) { var hasNativeReflectConstruct = ean_2_reader_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function ean_2_reader_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }



var ean_2_reader_EAN2Reader = /*#__PURE__*/function (_EANReader) {
  inherits_default()(EAN2Reader, _EANReader);

  var _super = ean_2_reader_createSuper(EAN2Reader);

  function EAN2Reader() {
    var _this;

    classCallCheck_default()(this, EAN2Reader);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    defineProperty_default()(assertThisInitialized_default()(_this), "FORMAT", 'ean_2');

    return _this;
  }

  createClass_default()(EAN2Reader, [{
    key: "decode",
    value: function decode(row, start) {
      if (row) {
        this._row = row;
      }

      var codeFrequency = 0;
      var offset = start;
      var end = this._row.length;
      var result = [];
      var decodedCodes = [];
      var code = null;

      if (offset === undefined) {
        return null;
      }

      for (var i = 0; i < 2 && offset < end; i++) {
        code = this._decodeCode(offset);

        if (!code) {
          return null;
        }

        decodedCodes.push(code);
        result.push(code.code % 10);

        if (code.code >= CODE_G_START) {
          codeFrequency |= 1 << 1 - i;
        }

        if (i !== 1) {
          offset = this._nextSet(this._row, code.end);
          offset = this._nextUnset(this._row, offset);
        }
      }

      if (result.length !== 2 || parseInt(result.join('')) % 4 !== codeFrequency) {
        return null;
      }

      var startInfo = this._findStart();

      return {
        code: result.join(''),
        decodedCodes: decodedCodes,
        end: code.end,
        format: this.FORMAT,
        startInfo: startInfo,
        start: startInfo.start
      };
    }
  }]);

  return EAN2Reader;
}(ean_reader);

;
/* harmony default export */ var ean_2_reader = (ean_2_reader_EAN2Reader);
// CONCATENATED MODULE: ./src/reader/ean_5_reader.ts








function ean_5_reader_createSuper(Derived) { var hasNativeReflectConstruct = ean_5_reader_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function ean_5_reader_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }


var CHECK_DIGIT_ENCODINGS = [24, 20, 18, 17, 12, 6, 3, 10, 9, 5];

function determineCheckDigit(codeFrequency) {
  for (var i = 0; i < 10; i++) {
    if (codeFrequency === CHECK_DIGIT_ENCODINGS[i]) {
      return i;
    }
  }

  return null;
}

function extensionChecksum(result) {
  var length = result.length;
  var sum = 0;

  for (var i = length - 2; i >= 0; i -= 2) {
    sum += result[i];
  }

  sum *= 3;

  for (var _i = length - 1; _i >= 0; _i -= 2) {
    sum += result[_i];
  }

  sum *= 3;
  return sum % 10;
}

var ean_5_reader_EAN5Reader = /*#__PURE__*/function (_EANReader) {
  inherits_default()(EAN5Reader, _EANReader);

  var _super = ean_5_reader_createSuper(EAN5Reader);

  function EAN5Reader() {
    var _this;

    classCallCheck_default()(this, EAN5Reader);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    defineProperty_default()(assertThisInitialized_default()(_this), "FORMAT", 'ean_5');

    return _this;
  }

  createClass_default()(EAN5Reader, [{
    key: "decode",
    value: function decode(row, start) {
      if (start === undefined) {
        return null;
      }

      if (row) {
        this._row = row;
      }

      var codeFrequency = 0;
      var offset = start;
      var end = this._row.length;
      var code = null;
      var result = [];
      var decodedCodes = [];

      for (var i = 0; i < 5 && offset < end; i++) {
        code = this._decodeCode(offset);

        if (!code) {
          return null;
        }

        decodedCodes.push(code);
        result.push(code.code % 10);

        if (code.code >= CODE_G_START) {
          codeFrequency |= 1 << 4 - i;
        }

        if (i !== 4) {
          offset = this._nextSet(this._row, code.end);
          offset = this._nextUnset(this._row, offset);
        }
      }

      if (result.length !== 5) {
        return null;
      }

      if (extensionChecksum(result) !== determineCheckDigit(codeFrequency)) {
        return null;
      }

      var startInfo = this._findStart();

      return {
        code: result.join(''),
        decodedCodes: decodedCodes,
        end: code.end,
        format: this.FORMAT,
        startInfo: startInfo,
        start: startInfo.start
      };
    }
  }]);

  return EAN5Reader;
}(ean_reader);

;
/* harmony default export */ var ean_5_reader = (ean_5_reader_EAN5Reader);
// CONCATENATED MODULE: ./src/reader/upc_e_reader.ts









function upc_e_reader_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function upc_e_reader_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { upc_e_reader_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { upc_e_reader_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function upc_e_reader_createSuper(Derived) { var hasNativeReflectConstruct = upc_e_reader_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function upc_e_reader_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }



var upc_e_reader_UPCEReader = /*#__PURE__*/function (_EANReader) {
  inherits_default()(UPCEReader, _EANReader);

  var _super = upc_e_reader_createSuper(UPCEReader);

  function UPCEReader() {
    var _this;

    classCallCheck_default()(this, UPCEReader);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    defineProperty_default()(assertThisInitialized_default()(_this), "CODE_FREQUENCY", [[56, 52, 50, 49, 44, 38, 35, 42, 41, 37], [7, 11, 13, 14, 19, 25, 28, 21, 22, 26]]);

    defineProperty_default()(assertThisInitialized_default()(_this), "STOP_PATTERN", [1 / 6 * 7, 1 / 6 * 7, 1 / 6 * 7, 1 / 6 * 7, 1 / 6 * 7, 1 / 6 * 7]);

    defineProperty_default()(assertThisInitialized_default()(_this), "FORMAT", 'upc_e');

    return _this;
  }

  createClass_default()(UPCEReader, [{
    key: "_decodePayload",
    value: function _decodePayload(inCode, result, decodedCodes) {
      var outCode = upc_e_reader_objectSpread({}, inCode);

      var codeFrequency = 0x0;

      for (var i = 0; i < 6; i++) {
        outCode = this._decodeCode(outCode.end);

        if (!outCode) {
          return null;
        }

        if (outCode.code >= CODE_G_START) {
          outCode.code = outCode.code - CODE_G_START;
          codeFrequency |= 1 << 5 - i;
        }

        result.push(outCode.code);
        decodedCodes.push(outCode);
      }

      if (!this._determineParity(codeFrequency, result)) {
        return null;
      }

      return outCode;
    }
  }, {
    key: "_determineParity",
    value: function _determineParity(codeFrequency, result) {
      for (var nrSystem = 0; nrSystem < this.CODE_FREQUENCY.length; nrSystem++) {
        for (var i = 0; i < this.CODE_FREQUENCY[nrSystem].length; i++) {
          if (codeFrequency === this.CODE_FREQUENCY[nrSystem][i]) {
            result.unshift(nrSystem);
            result.push(i);
            return true;
          }
        }
      }

      return false;
    }
  }, {
    key: "_convertToUPCA",
    value: function _convertToUPCA(result) {
      var upca = [result[0]];
      var lastDigit = result[result.length - 2];

      if (lastDigit <= 2) {
        upca = upca.concat(result.slice(1, 3)).concat([lastDigit, 0, 0, 0, 0]).concat(result.slice(3, 6));
      } else if (lastDigit === 3) {
        upca = upca.concat(result.slice(1, 4)).concat([0, 0, 0, 0, 0]).concat(result.slice(4, 6));
      } else if (lastDigit === 4) {
        upca = upca.concat(result.slice(1, 5)).concat([0, 0, 0, 0, 0, result[5]]);
      } else {
        upca = upca.concat(result.slice(1, 6)).concat([0, 0, 0, 0, lastDigit]);
      }

      upca.push(result[result.length - 1]);
      return upca;
    }
  }, {
    key: "_checksum",
    value: function _checksum(result) {
      return get_default()(getPrototypeOf_default()(UPCEReader.prototype), "_checksum", this).call(this, this._convertToUPCA(result));
    }
  }, {
    key: "_findEnd",
    value: function _findEnd(offset, isWhite) {
      return get_default()(getPrototypeOf_default()(UPCEReader.prototype), "_findEnd", this).call(this, offset, true);
    }
  }, {
    key: "_verifyTrailingWhitespace",
    value: function _verifyTrailingWhitespace(endInfo) {
      var trailingWhitespaceEnd = endInfo.end + (endInfo.end - endInfo.start) / 2;

      if (trailingWhitespaceEnd < this._row.length) {
        if (this._matchRange(endInfo.end, trailingWhitespaceEnd, 0)) {
          return endInfo;
        }
      }

      return null;
    }
  }]);

  return UPCEReader;
}(ean_reader);

/* harmony default export */ var upc_e_reader = (upc_e_reader_UPCEReader);
// CONCATENATED MODULE: ./src/reader/i2of5_reader.ts









function i2of5_reader_createSuper(Derived) { var hasNativeReflectConstruct = i2of5_reader_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function i2of5_reader_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

// TODO: i2of5_reader and 2of5_reader share very similar code, make use of that


var N = 1;
var W = 3;

var i2of5_reader_I2of5Reader = /*#__PURE__*/function (_BarcodeReader) {
  inherits_default()(I2of5Reader, _BarcodeReader);

  var _super = i2of5_reader_createSuper(I2of5Reader);

  function I2of5Reader(opts) {
    var _this;

    classCallCheck_default()(this, I2of5Reader);

    _this = _super.call(this, merge_default()({
      normalizeBarSpaceWidth: false
    }, opts));

    defineProperty_default()(assertThisInitialized_default()(_this), "barSpaceRatio", [1, 1]);

    defineProperty_default()(assertThisInitialized_default()(_this), "SINGLE_CODE_ERROR", 0.78);

    defineProperty_default()(assertThisInitialized_default()(_this), "AVG_CODE_ERROR", 0.38);

    defineProperty_default()(assertThisInitialized_default()(_this), "START_PATTERN", [N, N, N, N]);

    defineProperty_default()(assertThisInitialized_default()(_this), "STOP_PATTERN", [N, N, W]);

    defineProperty_default()(assertThisInitialized_default()(_this), "CODE_PATTERN", [[N, N, W, W, N], [W, N, N, N, W], [N, W, N, N, W], [W, W, N, N, N], [N, N, W, N, W], [W, N, W, N, N], [N, W, W, N, N], [N, N, N, W, W], [W, N, N, W, N], [N, W, N, W, N]]);

    defineProperty_default()(assertThisInitialized_default()(_this), "MAX_CORRECTION_FACTOR", 5);

    defineProperty_default()(assertThisInitialized_default()(_this), "FORMAT", 'i2of5');

    if (opts.normalizeBarSpaceWidth) {
      _this.SINGLE_CODE_ERROR = 0.38;
      _this.AVG_CODE_ERROR = 0.09;
    }

    _this.config = opts;
    return possibleConstructorReturn_default()(_this, assertThisInitialized_default()(_this));
  }

  createClass_default()(I2of5Reader, [{
    key: "_matchPattern",
    value: function _matchPattern(counter, code) {
      if (this.config.normalizeBarSpaceWidth) {
        var counterSum = [0, 0];
        var codeSum = [0, 0];
        var correction = [0, 0];
        var correctionRatio = this.MAX_CORRECTION_FACTOR;
        var correctionRatioInverse = 1 / correctionRatio;

        for (var i = 0; i < counter.length; i++) {
          counterSum[i % 2] += counter[i];
          codeSum[i % 2] += code[i];
        }

        correction[0] = codeSum[0] / counterSum[0];
        correction[1] = codeSum[1] / counterSum[1];
        correction[0] = Math.max(Math.min(correction[0], correctionRatio), correctionRatioInverse);
        correction[1] = Math.max(Math.min(correction[1], correctionRatio), correctionRatioInverse);
        this.barSpaceRatio = correction;

        for (var _i = 0; _i < counter.length; _i++) {
          counter[_i] *= this.barSpaceRatio[_i % 2];
        }
      }

      return get_default()(getPrototypeOf_default()(I2of5Reader.prototype), "_matchPattern", this).call(this, counter, code);
    }
  }, {
    key: "_findPattern",
    value: function _findPattern(pattern, offset) {
      var isWhite = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var tryHarder = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
      var counter = new Array(pattern.length).fill(0);
      var counterPos = 0;
      var bestMatch = {
        error: Number.MAX_VALUE,
        start: 0,
        end: 0
      };
      var epsilon = this.AVG_CODE_ERROR;
      isWhite = isWhite || false;
      tryHarder = tryHarder || false;

      if (!offset) {
        offset = this._nextSet(this._row);
      }

      for (var i = offset; i < this._row.length; i++) {
        if (this._row[i] ^ (isWhite ? 1 : 0)) {
          counter[counterPos]++;
        } else {
          if (counterPos === counter.length - 1) {
            var sum = counter.reduce(function (prev, next) {
              return prev + next;
            }, 0);

            var error = this._matchPattern(counter, pattern);

            if (error < epsilon) {
              bestMatch.error = error;
              bestMatch.start = i - sum;
              bestMatch.end = i;
              return bestMatch;
            }

            if (tryHarder) {
              for (var j = 0; j < counter.length - 2; j++) {
                counter[j] = counter[j + 2];
              }

              counter[counter.length - 2] = 0;
              counter[counter.length - 1] = 0;
              counterPos--;
            } else {
              return null;
            }
          } else {
            counterPos++;
          }

          counter[counterPos] = 1;
          isWhite = !isWhite;
        }
      }

      return null;
    }
  }, {
    key: "_findStart",
    value: function _findStart() {
      var leadingWhitespaceStart = 0;

      var offset = this._nextSet(this._row);

      var startInfo = null;
      var narrowBarWidth = 1;

      while (!startInfo) {
        startInfo = this._findPattern(this.START_PATTERN, offset, false, true);

        if (!startInfo) {
          return null;
        }

        narrowBarWidth = Math.floor((startInfo.end - startInfo.start) / 4);
        leadingWhitespaceStart = startInfo.start - narrowBarWidth * 10;

        if (leadingWhitespaceStart >= 0) {
          if (this._matchRange(leadingWhitespaceStart, startInfo.start, 0)) {
            return startInfo;
          }
        }

        offset = startInfo.end;
        startInfo = null;
      }

      return null;
    }
  }, {
    key: "_verifyTrailingWhitespace",
    value: function _verifyTrailingWhitespace(endInfo) {
      var trailingWhitespaceEnd = endInfo.end + (endInfo.end - endInfo.start) / 2;

      if (trailingWhitespaceEnd < this._row.length) {
        if (this._matchRange(endInfo.end, trailingWhitespaceEnd, 0)) {
          return endInfo;
        }
      }

      return null;
    }
  }, {
    key: "_findEnd",
    value: function _findEnd() {
      this._row.reverse();

      var endInfo = this._findPattern(this.STOP_PATTERN);

      this._row.reverse();

      if (endInfo === null) {
        return null;
      } // reverse numbers


      var tmp = endInfo.start;
      endInfo.start = this._row.length - endInfo.end;
      endInfo.end = this._row.length - tmp;
      return endInfo !== null ? this._verifyTrailingWhitespace(endInfo) : null;
    }
  }, {
    key: "_decodePair",
    value: function _decodePair(counterPair) {
      var codes = [];

      for (var i = 0; i < counterPair.length; i++) {
        var code = this._decodeCode(counterPair[i]);

        if (!code) {
          return null;
        }

        codes.push(code);
      }

      return codes;
    }
  }, {
    key: "_decodeCode",
    value: function _decodeCode(counter) {
      var epsilon = this.AVG_CODE_ERROR;
      var bestMatch = {
        error: Number.MAX_VALUE,
        code: -1,
        start: 0,
        end: 0
      };

      for (var code = 0; code < this.CODE_PATTERN.length; code++) {
        var error = this._matchPattern(counter, this.CODE_PATTERN[code]);

        if (error < bestMatch.error) {
          bestMatch.code = code;
          bestMatch.error = error;
        }
      }

      if (bestMatch.error < epsilon) {
        return bestMatch;
      }

      return null;
    }
  }, {
    key: "_decodePayload",
    value: function _decodePayload(counters, result, decodedCodes) {
      var pos = 0;
      var counterLength = counters.length;
      var counterPair = [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0]];
      var codes = null;

      while (pos < counterLength) {
        for (var i = 0; i < 5; i++) {
          counterPair[0][i] = counters[pos] * this.barSpaceRatio[0];
          counterPair[1][i] = counters[pos + 1] * this.barSpaceRatio[1];
          pos += 2;
        }

        codes = this._decodePair(counterPair);

        if (!codes) {
          return null;
        }

        for (var _i2 = 0; _i2 < codes.length; _i2++) {
          result.push(codes[_i2].code + '');
          decodedCodes.push(codes[_i2]);
        }
      }

      return codes;
    }
  }, {
    key: "_verifyCounterLength",
    value: function _verifyCounterLength(counters) {
      return counters.length % 10 === 0;
    }
  }, {
    key: "decode",
    value: function decode(row, start) {
      var result = new Array();
      var decodedCodes = new Array();

      var startInfo = this._findStart();

      if (!startInfo) {
        return null;
      }

      decodedCodes.push(startInfo);

      var endInfo = this._findEnd();

      if (!endInfo) {
        return null;
      }

      var counters = this._fillCounters(startInfo.end, endInfo.start, false);

      if (!this._verifyCounterLength(counters)) {
        return null;
      }

      var code = this._decodePayload(counters, result, decodedCodes);

      if (!code) {
        return null;
      }

      if (result.length % 2 !== 0 || result.length < 6) {
        return null;
      }

      decodedCodes.push(endInfo);
      return {
        code: result.join(''),
        start: startInfo.start,
        end: endInfo.end,
        startInfo: startInfo,
        decodedCodes: decodedCodes,
        format: this.FORMAT
      };
    }
  }]);

  return I2of5Reader;
}(barcode_reader);

/* harmony default export */ var i2of5_reader = (i2of5_reader_I2of5Reader);
// CONCATENATED MODULE: ./src/reader/2of5_reader.ts








function _2of5_reader_createSuper(Derived) { var hasNativeReflectConstruct = _2of5_reader_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function _2of5_reader_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }


var _2of5_reader_N = 1;
var _2of5_reader_W = 3;
var _2of5_reader_START_PATTERN = [_2of5_reader_W, _2of5_reader_N, _2of5_reader_W, _2of5_reader_N, _2of5_reader_N, _2of5_reader_N];
var STOP_PATTERN = [_2of5_reader_W, _2of5_reader_N, _2of5_reader_N, _2of5_reader_N, _2of5_reader_W];
var _2of5_reader_CODE_PATTERN = [[_2of5_reader_N, _2of5_reader_N, _2of5_reader_W, _2of5_reader_W, _2of5_reader_N], [_2of5_reader_W, _2of5_reader_N, _2of5_reader_N, _2of5_reader_N, _2of5_reader_W], [_2of5_reader_N, _2of5_reader_W, _2of5_reader_N, _2of5_reader_N, _2of5_reader_W], [_2of5_reader_W, _2of5_reader_W, _2of5_reader_N, _2of5_reader_N, _2of5_reader_N], [_2of5_reader_N, _2of5_reader_N, _2of5_reader_W, _2of5_reader_N, _2of5_reader_W], [_2of5_reader_W, _2of5_reader_N, _2of5_reader_W, _2of5_reader_N, _2of5_reader_N], [_2of5_reader_N, _2of5_reader_W, _2of5_reader_W, _2of5_reader_N, _2of5_reader_N], [_2of5_reader_N, _2of5_reader_N, _2of5_reader_N, _2of5_reader_W, _2of5_reader_W], [_2of5_reader_W, _2of5_reader_N, _2of5_reader_N, _2of5_reader_W, _2of5_reader_N], [_2of5_reader_N, _2of5_reader_W, _2of5_reader_N, _2of5_reader_W, _2of5_reader_N]];
var START_PATTERN_LENGTH = _2of5_reader_START_PATTERN.reduce(function (sum, val) {
  return sum + val;
}, 0);

var _2of5_reader_TwoOfFiveReader = /*#__PURE__*/function (_BarcodeReader) {
  inherits_default()(TwoOfFiveReader, _BarcodeReader);

  var _super = _2of5_reader_createSuper(TwoOfFiveReader);

  function TwoOfFiveReader() {
    var _this;

    classCallCheck_default()(this, TwoOfFiveReader);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    defineProperty_default()(assertThisInitialized_default()(_this), "barSpaceRatio", [1, 1]);

    defineProperty_default()(assertThisInitialized_default()(_this), "FORMAT", '2of5');

    defineProperty_default()(assertThisInitialized_default()(_this), "SINGLE_CODE_ERROR", 0.78);

    defineProperty_default()(assertThisInitialized_default()(_this), "AVG_CODE_ERROR", 0.30);

    return _this;
  }

  createClass_default()(TwoOfFiveReader, [{
    key: "_findPattern",
    value: function _findPattern(pattern, offset) {
      var isWhite = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var tryHarder = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
      var counter = [];
      var counterPos = 0;
      var bestMatch = {
        error: Number.MAX_VALUE,
        code: -1,
        start: 0,
        end: 0
      };
      var sum = 0;
      var error = 0;
      var epsilon = this.AVG_CODE_ERROR;

      if (!offset) {
        offset = this._nextSet(this._row);
      }

      for (var i = 0; i < pattern.length; i++) {
        counter[i] = 0;
      }

      for (var _i = offset; _i < this._row.length; _i++) {
        if (this._row[_i] ^ (isWhite ? 1 : 0)) {
          counter[counterPos]++;
        } else {
          if (counterPos === counter.length - 1) {
            sum = 0;

            for (var j = 0; j < counter.length; j++) {
              sum += counter[j];
            }

            error = this._matchPattern(counter, pattern);

            if (error < epsilon) {
              bestMatch.error = error;
              bestMatch.start = _i - sum;
              bestMatch.end = _i;
              return bestMatch;
            }

            if (tryHarder) {
              for (var _j = 0; _j < counter.length - 2; _j++) {
                counter[_j] = counter[_j + 2];
              }

              counter[counter.length - 2] = 0;
              counter[counter.length - 1] = 0;
              counterPos--;
            } else {
              return null;
            }
          } else {
            counterPos++;
          }

          counter[counterPos] = 1;
          isWhite = !isWhite;
        }
      }

      return null;
    }
  }, {
    key: "_findStart",
    value: function _findStart() {
      var startInfo = null;

      var offset = this._nextSet(this._row);

      var narrowBarWidth = 1;
      var leadingWhitespaceStart = 0;

      while (!startInfo) {
        startInfo = this._findPattern(_2of5_reader_START_PATTERN, offset, false, true);

        if (!startInfo) {
          return null;
        }

        narrowBarWidth = Math.floor((startInfo.end - startInfo.start) / START_PATTERN_LENGTH);
        leadingWhitespaceStart = startInfo.start - narrowBarWidth * 5;

        if (leadingWhitespaceStart >= 0) {
          if (this._matchRange(leadingWhitespaceStart, startInfo.start, 0)) {
            return startInfo;
          }
        }

        offset = startInfo.end;
        startInfo = null;
      }

      return startInfo;
    }
  }, {
    key: "_verifyTrailingWhitespace",
    value: function _verifyTrailingWhitespace(endInfo) {
      var trailingWhitespaceEnd = endInfo.end + (endInfo.end - endInfo.start) / 2;

      if (trailingWhitespaceEnd < this._row.length) {
        if (this._matchRange(endInfo.end, trailingWhitespaceEnd, 0)) {
          return endInfo;
        }
      }

      return null;
    }
  }, {
    key: "_findEnd",
    value: function _findEnd() {
      // TODO: reverse, followed by some calcs, followed by another reverse? really?
      this._row.reverse();

      var offset = this._nextSet(this._row);

      var endInfo = this._findPattern(STOP_PATTERN, offset, false, true);

      this._row.reverse();

      if (endInfo === null) {
        return null;
      } // reverse numbers


      var tmp = endInfo.start;
      endInfo.start = this._row.length - endInfo.end;
      endInfo.end = this._row.length - tmp;
      return endInfo !== null ? this._verifyTrailingWhitespace(endInfo) : null;
    }
  }, {
    key: "_verifyCounterLength",
    value: function _verifyCounterLength(counters) {
      return counters.length % 10 === 0;
    }
  }, {
    key: "_decodeCode",
    value: function _decodeCode(counter) {
      var epsilon = this.AVG_CODE_ERROR;
      var bestMatch = {
        error: Number.MAX_VALUE,
        code: -1,
        start: 0,
        end: 0
      };

      for (var code = 0; code < _2of5_reader_CODE_PATTERN.length; code++) {
        var error = this._matchPattern(counter, _2of5_reader_CODE_PATTERN[code]);

        if (error < bestMatch.error) {
          bestMatch.code = code;
          bestMatch.error = error;
        }
      }

      if (bestMatch.error < epsilon) {
        return bestMatch;
      }

      return null;
    }
  }, {
    key: "_decodePayload",
    value: function _decodePayload(counters, result, decodedCodes) {
      var pos = 0;
      var counterLength = counters.length;
      var counter = [0, 0, 0, 0, 0];
      var code = null;

      while (pos < counterLength) {
        for (var i = 0; i < 5; i++) {
          counter[i] = counters[pos] * this.barSpaceRatio[0];
          pos += 2;
        }

        code = this._decodeCode(counter);

        if (!code) {
          return null;
        }

        result.push("".concat(code.code));
        decodedCodes.push(code);
      }

      return code;
    }
  }, {
    key: "decode",
    value: function decode(row, start) {
      var startInfo = this._findStart();

      if (!startInfo) {
        return null;
      }

      var endInfo = this._findEnd();

      if (!endInfo) {
        return null;
      }

      var counters = this._fillCounters(startInfo.end, endInfo.start, false);

      if (!this._verifyCounterLength(counters)) {
        return null;
      }

      var decodedCodes = [];
      decodedCodes.push(startInfo);
      var result = [];

      var code = this._decodePayload(counters, result, decodedCodes);

      if (!code) {
        return null;
      }

      if (result.length < 5) {
        return null;
      }

      decodedCodes.push(endInfo);
      return {
        code: result.join(''),
        start: startInfo.start,
        end: endInfo.end,
        startInfo: startInfo,
        decodedCodes: decodedCodes,
        format: this.FORMAT
      };
    }
  }]);

  return TwoOfFiveReader;
}(barcode_reader);

/* harmony default export */ var _2of5_reader = (_2of5_reader_TwoOfFiveReader);
// CONCATENATED MODULE: ./src/reader/code_93_reader.ts









function code_93_reader_createSuper(Derived) { var hasNativeReflectConstruct = code_93_reader_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function code_93_reader_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }



var code_93_reader_ALPHABETH_STRING = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%abcd*';
var code_93_reader_ALPHABET = new Uint16Array(toConsumableArray_default()(code_93_reader_ALPHABETH_STRING).map(function (_char) {
  return _char.charCodeAt(0);
}));
var code_93_reader_CHARACTER_ENCODINGS = new Uint16Array([0x114, 0x148, 0x144, 0x142, 0x128, 0x124, 0x122, 0x150, 0x112, 0x10A, 0x1A8, 0x1A4, 0x1A2, 0x194, 0x192, 0x18A, 0x168, 0x164, 0x162, 0x134, 0x11A, 0x158, 0x14C, 0x146, 0x12C, 0x116, 0x1B4, 0x1B2, 0x1AC, 0x1A6, 0x196, 0x19A, 0x16C, 0x166, 0x136, 0x13A, 0x12E, 0x1D4, 0x1D2, 0x1CA, 0x16E, 0x176, 0x1AE, 0x126, 0x1DA, 0x1D6, 0x132, 0x15E]);
var code_93_reader_ASTERISK = 0x15E;

var code_93_reader_Code93Reader = /*#__PURE__*/function (_BarcodeReader) {
  inherits_default()(Code93Reader, _BarcodeReader);

  var _super = code_93_reader_createSuper(Code93Reader);

  function Code93Reader() {
    var _this;

    classCallCheck_default()(this, Code93Reader);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    defineProperty_default()(assertThisInitialized_default()(_this), "FORMAT", 'code_93');

    return _this;
  }

  createClass_default()(Code93Reader, [{
    key: "_patternToChar",
    value: function _patternToChar(pattern) {
      for (var i = 0; i < code_93_reader_CHARACTER_ENCODINGS.length; i++) {
        if (code_93_reader_CHARACTER_ENCODINGS[i] === pattern) {
          return String.fromCharCode(code_93_reader_ALPHABET[i]);
        }
      }

      return null;
    }
  }, {
    key: "_toPattern",
    value: function _toPattern(counters) {
      var numCounters = counters.length;
      var sum = counters.reduce(function (prev, next) {
        return prev + next;
      }, 0);
      var pattern = 0;

      for (var i = 0; i < numCounters; i++) {
        var normalized = Math.round(counters[i] * 9 / sum);

        if (normalized < 1 || normalized > 4) {
          return -1;
        }

        if ((i & 1) === 0) {
          for (var j = 0; j < normalized; j++) {
            pattern = pattern << 1 | 1;
          }
        } else {
          pattern <<= normalized;
        }
      }

      return pattern;
    }
  }, {
    key: "_findStart",
    value: function _findStart() {
      var offset = this._nextSet(this._row);

      var patternStart = offset;
      var counter = new Uint16Array([0, 0, 0, 0, 0, 0]);
      var counterPos = 0;
      var isWhite = false;

      for (var i = offset; i < this._row.length; i++) {
        if (this._row[i] ^ (isWhite ? 1 : 0)) {
          counter[counterPos]++;
        } else {
          if (counterPos === counter.length - 1) {
            // find start pattern
            if (this._toPattern(counter) === code_93_reader_ASTERISK) {
              var whiteSpaceMustStart = Math.floor(Math.max(0, patternStart - (i - patternStart) / 4));

              if (this._matchRange(whiteSpaceMustStart, patternStart, 0)) {
                return {
                  start: patternStart,
                  end: i
                };
              }
            }

            patternStart += counter[0] + counter[1];

            for (var j = 0; j < 4; j++) {
              counter[j] = counter[j + 2];
            }

            counter[4] = 0;
            counter[5] = 0;
            counterPos--;
          } else {
            counterPos++;
          }

          counter[counterPos] = 1;
          isWhite = !isWhite;
        }
      }

      return null;
    }
  }, {
    key: "_verifyEnd",
    value: function _verifyEnd(lastStart, nextStart) {
      if (lastStart === nextStart || !this._row[nextStart]) {
        return false;
      }

      return true;
    }
  }, {
    key: "_decodeExtended",
    value: function _decodeExtended(charArray) {
      var length = charArray.length;
      var result = [];

      for (var i = 0; i < length; i++) {
        var _char2 = charArray[i];

        if (_char2 >= 'a' && _char2 <= 'd') {
          if (i > length - 2) {
            return null;
          }

          var nextChar = charArray[++i];
          var nextCharCode = nextChar.charCodeAt(0);
          var decodedChar = void 0;

          switch (_char2) {
            case 'a':
              if (nextChar >= 'A' && nextChar <= 'Z') {
                decodedChar = String.fromCharCode(nextCharCode - 64);
              } else {
                return null;
              }

              break;

            case 'b':
              if (nextChar >= 'A' && nextChar <= 'E') {
                decodedChar = String.fromCharCode(nextCharCode - 38);
              } else if (nextChar >= 'F' && nextChar <= 'J') {
                decodedChar = String.fromCharCode(nextCharCode - 11);
              } else if (nextChar >= 'K' && nextChar <= 'O') {
                decodedChar = String.fromCharCode(nextCharCode + 16);
              } else if (nextChar >= 'P' && nextChar <= 'S') {
                decodedChar = String.fromCharCode(nextCharCode + 43);
              } else if (nextChar >= 'T' && nextChar <= 'Z') {
                decodedChar = String.fromCharCode(127);
              } else {
                return null;
              }

              break;

            case 'c':
              if (nextChar >= 'A' && nextChar <= 'O') {
                decodedChar = String.fromCharCode(nextCharCode - 32);
              } else if (nextChar === 'Z') {
                decodedChar = ':';
              } else {
                return null;
              }

              break;

            case 'd':
              if (nextChar >= 'A' && nextChar <= 'Z') {
                decodedChar = String.fromCharCode(nextCharCode + 32);
              } else {
                return null;
              }

              break;

            default:
              console.warn('* code_93_reader _decodeExtended hit default case, this may be an error', decodedChar);
              return null;
          }

          result.push(decodedChar);
        } else {
          result.push(_char2);
        }
      }

      return result;
    }
  }, {
    key: "_matchCheckChar",
    value: function _matchCheckChar(charArray, index, maxWeight) {
      var arrayToCheck = charArray.slice(0, index);
      var length = arrayToCheck.length;
      var weightedSums = arrayToCheck.reduce(function (sum, _char3, i) {
        var weight = (i * -1 + (length - 1)) % maxWeight + 1;
        var value = code_93_reader_ALPHABET.indexOf(_char3.charCodeAt(0));
        return sum + weight * value;
      }, 0);
      var checkChar = code_93_reader_ALPHABET[weightedSums % 47];
      return checkChar === charArray[index].charCodeAt(0);
    }
  }, {
    key: "_verifyChecksums",
    value: function _verifyChecksums(charArray) {
      return this._matchCheckChar(charArray, charArray.length - 2, 20) && this._matchCheckChar(charArray, charArray.length - 1, 15);
    }
  }, {
    key: "decode",
    value: function decode(row, start) {
      start = this._findStart();

      if (!start) {
        return null;
      }

      var counters = new Uint16Array([0, 0, 0, 0, 0, 0]);
      var result = [];

      var nextStart = this._nextSet(this._row, start.end);

      var lastStart;
      var decodedChar;

      do {
        counters = this._toCounters(nextStart, counters);

        var pattern = this._toPattern(counters);

        if (pattern < 0) {
          return null;
        }

        decodedChar = this._patternToChar(pattern);

        if (decodedChar === null) {
          return null;
        }

        result.push(decodedChar);
        lastStart = nextStart;
        nextStart += array_helper["a" /* default */].sum(counters);
        nextStart = this._nextSet(this._row, nextStart);
      } while (decodedChar !== '*');

      result.pop();

      if (!result.length) {
        return null;
      }

      if (!this._verifyEnd(lastStart, nextStart)) {
        return null;
      }

      if (!this._verifyChecksums(result)) {
        return null;
      }

      result = result.slice(0, result.length - 2); // yes, this is an assign inside an if.

      if ((result = this._decodeExtended(result)) === null) {
        return null;
      }

      return {
        code: result.join(''),
        start: start.start,
        end: nextStart,
        startInfo: start,
        decodedCodes: result,
        format: this.FORMAT
      };
    }
  }]);

  return Code93Reader;
}(barcode_reader);

/* harmony default export */ var code_93_reader = (code_93_reader_Code93Reader);
// CONCATENATED MODULE: ./src/reader/code_32_reader.ts









function code_32_reader_createSuper(Derived) { var hasNativeReflectConstruct = code_32_reader_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function code_32_reader_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }


var code_32_reader_patterns = {
  AEIO: /[AEIO]/g,
  AZ09: /[A-Z0-9]/
};
var code32set = '0123456789BCDFGHJKLMNPQRSTUVWXYZ';

var code_32_reader_Code32Reader = /*#__PURE__*/function (_Code39Reader) {
  inherits_default()(Code32Reader, _Code39Reader);

  var _super = code_32_reader_createSuper(Code32Reader);

  function Code32Reader() {
    var _this;

    classCallCheck_default()(this, Code32Reader);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    defineProperty_default()(assertThisInitialized_default()(_this), "FORMAT", 'code_32_reader');

    return _this;
  }

  createClass_default()(Code32Reader, [{
    key: "_decodeCode32",
    value: function _decodeCode32(code) {
      if (/[^0-9BCDFGHJKLMNPQRSTUVWXYZ]/.test(code)) {
        return null;
      }

      var res = 0;

      for (var i = 0; i < code.length; i++) {
        res = res * 32 + code32set.indexOf(code[i]);
      }

      var code32 = '' + res;

      if (code32.length < 9) {
        code32 = ('000000000' + code32).slice(-9);
      }

      return 'A' + code32;
    } // TODO (this was todo in original repo, no text was there. sorry.)

  }, {
    key: "_checkChecksum",
    value: function _checkChecksum(code) {
      return !!code;
    }
  }, {
    key: "decode",
    value: function decode(row, start) {
      var result = get_default()(getPrototypeOf_default()(Code32Reader.prototype), "decode", this).call(this, row, start);

      if (!result) {
        return null;
      }

      var code = result.code;

      if (!code) {
        return null;
      }

      code = code.replace(code_32_reader_patterns.AEIO, '');

      if (!this._checkChecksum(code)) {
        return null;
      }

      var code32 = this._decodeCode32(code);

      if (!code32) {
        return null;
      }

      result.code = code32;
      return result;
    }
  }]);

  return Code32Reader;
}(code_39_reader);

/* harmony default export */ var code_32_reader = (code_32_reader_Code32Reader);
// CONCATENATED MODULE: ./src/decoder/barcode_decoder.js

















var READERS = {
  code_128_reader: code_128_reader,
  ean_reader: ean_reader,
  ean_5_reader: ean_5_reader,
  ean_2_reader: ean_2_reader,
  ean_8_reader: ean_8_reader,
  code_39_reader: code_39_reader,
  code_39_vin_reader: code_39_vin_reader,
  codabar_reader: codabar_reader,
  upc_reader: upc_reader,
  upc_e_reader: upc_e_reader,
  i2of5_reader: i2of5_reader,
  '2of5_reader': _2of5_reader,
  code_93_reader: code_93_reader,
  code_32_reader: code_32_reader
};
/* harmony default export */ var barcode_decoder = ({
  registerReader: function registerReader(name, reader) {
    READERS[name] = reader;
  },
  create: function create(config, inputImageWrapper) {
    var _canvas = {
      ctx: {
        frequency: null,
        pattern: null,
        overlay: null
      },
      dom: {
        frequency: null,
        pattern: null,
        overlay: null
      }
    };
    var _barcodeReaders = [];
    initCanvas();
    initReaders();
    initConfig();

    function initCanvas() {
      if (false) { var $debug; }
    }

    function initReaders() {
      config.readers.forEach(function (readerConfig) {
        var reader;
        var configuration = {};
        var supplements = [];

        if (typeof_default()(readerConfig) === 'object') {
          reader = readerConfig.format;
          configuration = readerConfig.config;
        } else if (typeof readerConfig === 'string') {
          reader = readerConfig;
        }

        if (false) {}

        if (configuration.supplements) {
          supplements = configuration.supplements.map(function (supplement) {
            return new READERS[supplement]();
          });
        }

        try {
          var readerObj = new READERS[reader](configuration, supplements);

          _barcodeReaders.push(readerObj);
        } catch (err) {
          console.error('* Error constructing reader ', reader, err);
          throw err;
        }
      });

      if (false) {}
    }

    function initConfig() {
      if (false) { var vis, i; }
    }
    /**
     * extend the line on both ends
     * @param {Array} line
     * @param {Number} angle
     */


    function getExtendedLine(line, angle, ext) {
      function extendLine(amount) {
        var extension = {
          y: amount * Math.sin(angle),
          x: amount * Math.cos(angle)
        };
        /* eslint-disable no-param-reassign */

        line[0].y -= extension.y;
        line[0].x -= extension.x;
        line[1].y += extension.y;
        line[1].x += extension.x;
        /* eslint-enable no-param-reassign */
      } // check if inside image


      extendLine(ext);

      while (ext > 1 && (!inputImageWrapper.inImageWithBorder(line[0]) || !inputImageWrapper.inImageWithBorder(line[1]))) {
        // eslint-disable-next-line no-param-reassign
        ext -= Math.ceil(ext / 2);
        extendLine(-ext);
      }

      return line;
    }

    function getLine(box) {
      return [{
        x: (box[1][0] - box[0][0]) / 2 + box[0][0],
        y: (box[1][1] - box[0][1]) / 2 + box[0][1]
      }, {
        x: (box[3][0] - box[2][0]) / 2 + box[2][0],
        y: (box[3][1] - box[2][1]) / 2 + box[2][1]
      }];
    }

    function tryDecode(line) {
      var result = null;
      var i;
      var barcodeLine = bresenham.getBarcodeLine(inputImageWrapper, line[0], line[1]);

      if (false) {}

      bresenham.toBinaryLine(barcodeLine);

      if (false) {}

      for (i = 0; i < _barcodeReaders.length && result === null; i++) {
        result = _barcodeReaders[i].decodePattern(barcodeLine.line);
      }

      if (result === null) {
        return null;
      }

      return {
        codeResult: result,
        barcodeLine: barcodeLine
      };
    }
    /**
     * This method slices the given area apart and tries to detect a barcode-pattern
     * for each slice. It returns the decoded barcode, or null if nothing was found
     * @param {Array} box
     * @param {Array} line
     * @param {Number} lineAngle
     */


    function tryDecodeBruteForce(box, line, lineAngle) {
      var sideLength = Math.sqrt(Math.pow(box[1][0] - box[0][0], 2) + Math.pow(box[1][1] - box[0][1], 2));
      var i;
      var slices = 16;
      var result = null;
      var dir;
      var extension;
      var xdir = Math.sin(lineAngle);
      var ydir = Math.cos(lineAngle);

      for (i = 1; i < slices && result === null; i++) {
        // move line perpendicular to angle
        // eslint-disable-next-line no-mixed-operators
        dir = sideLength / slices * i * (i % 2 === 0 ? -1 : 1);
        extension = {
          y: dir * xdir,
          x: dir * ydir
        };
        /* eslint-disable no-param-reassign */

        line[0].y += extension.x;
        line[0].x -= extension.y;
        line[1].y += extension.x;
        line[1].x -= extension.y;
        /* eslint-enable no-param-reassign */

        result = tryDecode(line);
      }

      return result;
    }

    function getLineLength(line) {
      return Math.sqrt(Math.pow(Math.abs(line[1].y - line[0].y), 2) + Math.pow(Math.abs(line[1].x - line[0].x), 2));
    }

    function _decodeFromImage(imageWrapper) {
      var result = null;

      for (var i = 0; i < _barcodeReaders.length && result === null; i++) {
        result = _barcodeReaders[i].decodeImage ? _barcodeReaders[i].decodeImage(imageWrapper) : null;
      }

      return result;
    }
    /**
     * With the help of the configured readers (Code128 or EAN) this function tries to detect a
     * valid barcode pattern within the given area.
     * @param {Object} box The area to search in
     * @returns {Object} the result {codeResult, line, angle, pattern, threshold}
     */


    function _decodeFromBoundingBox(box) {
      var line;
      var ctx = _canvas.ctx.overlay;
      var result;

      if (false) {}

      line = getLine(box);
      var lineLength = getLineLength(line);
      var lineAngle = Math.atan2(line[1].y - line[0].y, line[1].x - line[0].x);
      line = getExtendedLine(line, lineAngle, Math.floor(lineLength * 0.1));

      if (line === null) {
        return null;
      }

      result = tryDecode(line);

      if (result === null) {
        result = tryDecodeBruteForce(box, line, lineAngle);
      }

      if (result === null) {
        return null;
      }

      if (false) {}

      return {
        codeResult: result.codeResult,
        line: line,
        angle: lineAngle,
        pattern: result.barcodeLine.line,
        threshold: result.barcodeLine.threshold
      };
    }

    return {
      decodeFromBoundingBox: function decodeFromBoundingBox(box) {
        return _decodeFromBoundingBox(box);
      },
      decodeFromBoundingBoxes: function decodeFromBoundingBoxes(boxes) {
        var i;
        var result;
        var barcodes = [];
        var multiple = config.multiple;

        for (i = 0; i < boxes.length; i++) {
          var box = boxes[i];
          result = _decodeFromBoundingBox(box) || {};
          result.box = box;

          if (multiple) {
            barcodes.push(result);
          } else if (result.codeResult) {
            return result;
          }
        }

        if (multiple) {
          return {
            barcodes: barcodes
          };
        }
      },
      decodeFromImage: function decodeFromImage(inputImageWrapper) {
        var result = _decodeFromImage(inputImageWrapper);

        return result;
      },
      registerReader: function registerReader(name, reader) {
        if (READERS[name]) {
          throw new Error('cannot register existing reader', name);
        }

        READERS[name] = reader;
      },
      setReaders: function setReaders(readers) {
        // eslint-disable-next-line no-param-reassign
        config.readers = readers;
        _barcodeReaders.length = 0;
        initReaders();
      }
    };
  }
});
// CONCATENATED MODULE: ./src/reader/index.ts
















// CONCATENATED MODULE: ./src/common/events.ts
/* harmony default export */ var events = ((function EventInterface() {
  var events = {};

  function getEvent(eventName) {
    if (!events[eventName]) {
      events[eventName] = {
        subscribers: []
      };
    }

    return events[eventName];
  }

  function clearEvents() {
    events = {};
  }

  function publishSubscription(subscription, data) {
    if (subscription.async) {
      setTimeout(function () {
        subscription.callback(data);
      }, 4);
    } else {
      subscription.callback(data);
    }
  }

  function _subscribe(event, callback, async) {
    var subscription;

    if (typeof callback === 'function') {
      subscription = {
        callback: callback,
        async: async
      };
    } else {
      subscription = callback;

      if (!subscription.callback) {
        throw new Error('Callback was not specified on options');
      }
    }

    getEvent(event).subscribers.push(subscription);
  }

  return {
    subscribe: function subscribe(event, callback, async) {
      return _subscribe(event, callback, async);
    },
    publish: function publish(eventName, data) {
      var event = getEvent(eventName);
      var subscribers = event.subscribers; // Publish one-time subscriptions

      subscribers.filter(function (subscriber) {
        return !!subscriber.once;
      }).forEach(function (subscriber) {
        publishSubscription(subscriber, data);
      }); // remove them from the subscriber

      event.subscribers = subscribers.filter(function (subscriber) {
        return !subscriber.once;
      }); // publish the rest

      event.subscribers.forEach(function (subscriber) {
        publishSubscription(subscriber, data);
      });
    },
    once: function once(event, callback) {
      var async = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

      _subscribe(event, {
        callback: callback,
        async: async,
        once: true
      });
    },
    unsubscribe: function unsubscribe(eventName, callback) {
      if (eventName) {
        var _event = getEvent(eventName);

        if (_event && callback) {
          _event.subscribers = _event.subscribers.filter(function (subscriber) {
            return subscriber.callback !== callback;
          });
        } else {
          _event.subscribers = [];
        }
      } else {
        clearEvents();
      }
    }
  };
})());
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/asyncToGenerator.js
var asyncToGenerator = __webpack_require__(20);
var asyncToGenerator_default = /*#__PURE__*/__webpack_require__.n(asyncToGenerator);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/regenerator/index.js
var regenerator = __webpack_require__(11);
var regenerator_default = /*#__PURE__*/__webpack_require__.n(regenerator);

// EXTERNAL MODULE: ./node_modules/lodash/pick.js
var pick = __webpack_require__(85);
var pick_default = /*#__PURE__*/__webpack_require__.n(pick);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/wrapNativeSuper.js
var wrapNativeSuper = __webpack_require__(86);
var wrapNativeSuper_default = /*#__PURE__*/__webpack_require__.n(wrapNativeSuper);

// CONCATENATED MODULE: ./src/quagga/Exception.ts








function Exception_createSuper(Derived) { var hasNativeReflectConstruct = Exception_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function Exception_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var Exception_Exception = /*#__PURE__*/function (_Error) {
  inherits_default()(Exception, _Error);

  var _super = Exception_createSuper(Exception);

  function Exception(m, code) {
    var _this;

    classCallCheck_default()(this, Exception);

    _this = _super.call(this, m);

    defineProperty_default()(assertThisInitialized_default()(_this), "code", void 0);

    _this.code = code;
    Object.setPrototypeOf(assertThisInitialized_default()(_this), Exception.prototype);
    return _this;
  }

  return Exception;
}( /*#__PURE__*/wrapNativeSuper_default()(Error));
// CONCATENATED MODULE: ./src/common/mediaDevices.ts

var ERROR_DESC = 'This may mean that the user has declined camera access, or the browser does not support media APIs. If you are running in iOS, you must use Safari.';
function enumerateDevices() {
  try {
    return navigator.mediaDevices.enumerateDevices();
  } catch (err) {
    var error = new Exception_Exception("enumerateDevices is not defined. ".concat(ERROR_DESC), -1);
    return Promise.reject(error);
  }
}
function getUserMedia(constraints) {
  try {
    return navigator.mediaDevices.getUserMedia(constraints);
  } catch (err) {
    var error = new Exception_Exception("getUserMedia is not defined. ".concat(ERROR_DESC), -1);
    return Promise.reject(error);
  }
}
// CONCATENATED MODULE: ./src/input/camera_access.ts





var streamRef;

function waitForVideo(video) {
  return new Promise(function (resolve, reject) {
    var attempts = 10;

    function checkVideo() {
      if (attempts > 0) {
        if (video.videoWidth > 10 && video.videoHeight > 10) {
          if (false) {}

          resolve();
        } else {
          window.setTimeout(checkVideo, 500);
        }
      } else {
        reject(new Exception_Exception('Unable to play video stream. Is webcam working?', -1)); // TODO: add error code
      }

      attempts--;
    }

    checkVideo();
  });
}
/**
 * Tries to attach the camera-stream to a given video-element
 * and calls the callback function when the content is ready
 * @param {Object} constraints
 * @param {Object} video
 */


function initCamera(_x, _x2) {
  return _initCamera.apply(this, arguments);
}

function _initCamera() {
  _initCamera = asyncToGenerator_default()( /*#__PURE__*/regenerator_default.a.mark(function _callee2(video, constraints) {
    var stream;
    return regenerator_default.a.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.next = 2;
            return getUserMedia(constraints);

          case 2:
            stream = _context2.sent;
            streamRef = stream;

            if (!video) {
              _context2.next = 11;
              break;
            }

            video.setAttribute('autoplay', 'true');
            video.setAttribute('muted', 'true');
            video.setAttribute('playsinline', 'true'); // not listed on MDN...
            // eslint-disable-next-line no-param-reassign

            video.srcObject = stream;
            video.addEventListener('loadedmetadata', function () {
              video.play();
            });
            return _context2.abrupt("return", waitForVideo(video));

          case 11:
            return _context2.abrupt("return", Promise.resolve());

          case 12:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _initCamera.apply(this, arguments);
}

function deprecatedConstraints(videoConstraints) {
  var normalized = pick_default()(videoConstraints, ['width', 'height', 'facingMode', 'aspectRatio', 'deviceId']);

  if (typeof videoConstraints.minAspectRatio !== 'undefined' && videoConstraints.minAspectRatio > 0) {
    normalized.aspectRatio = videoConstraints.minAspectRatio;
    console.log('WARNING: Constraint \'minAspectRatio\' is deprecated; Use \'aspectRatio\' instead');
  }

  if (typeof videoConstraints.facing !== 'undefined') {
    normalized.facingMode = videoConstraints.facing;
    console.log('WARNING: Constraint \'facing\' is deprecated. Use \'facingMode\' instead\'');
  }

  return normalized;
} // TODO: #192 I don't think there's any good reason pickConstraints should return a Promise,
// I think it was just that way so it could be chained to other functions that did return a Promise.
// That's not necessary with async functions being a thing, so that should be fixed.


function pickConstraints() {
  var videoConstraints = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var video = deprecatedConstraints(videoConstraints);

  if (video && video.deviceId && video.facingMode) {
    delete video.facingMode;
  }

  return Promise.resolve({
    audio: false,
    video: video
  });
}

function enumerateVideoDevices() {
  return _enumerateVideoDevices.apply(this, arguments);
}

function _enumerateVideoDevices() {
  _enumerateVideoDevices = asyncToGenerator_default()( /*#__PURE__*/regenerator_default.a.mark(function _callee3() {
    var devices;
    return regenerator_default.a.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            _context3.next = 2;
            return enumerateDevices();

          case 2:
            devices = _context3.sent;
            return _context3.abrupt("return", devices.filter(function (device) {
              return device.kind === 'videoinput';
            }));

          case 4:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));
  return _enumerateVideoDevices.apply(this, arguments);
}

function getActiveTrack() {
  if (!streamRef) {
    return null;
  }

  var tracks = streamRef.getVideoTracks();
  return tracks && tracks !== null && tracks !== void 0 && tracks.length ? tracks[0] : null;
}
/**
 * Used for accessing information about the active stream track and available video devices.
 */


var QuaggaJSCameraAccess = {
  requestedVideoElement: null,
  request: function request(video, videoConstraints) {
    return asyncToGenerator_default()( /*#__PURE__*/regenerator_default.a.mark(function _callee() {
      var newConstraints;
      return regenerator_default.a.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              QuaggaJSCameraAccess.requestedVideoElement = video;
              _context.next = 3;
              return pickConstraints(videoConstraints);

            case 3:
              newConstraints = _context.sent;
              return _context.abrupt("return", initCamera(video, newConstraints));

            case 5:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }))();
  },
  release: function release() {
    var tracks = streamRef && streamRef.getVideoTracks();

    if (QuaggaJSCameraAccess.requestedVideoElement !== null) {
      QuaggaJSCameraAccess.requestedVideoElement.pause();
    }

    return new Promise(function (resolve) {
      setTimeout(function () {
        if (tracks && tracks.length) {
          tracks[0].stop();
        }

        streamRef = null;
        QuaggaJSCameraAccess.requestedVideoElement = null;
        resolve();
      }, 0);
    });
  },
  enumerateVideoDevices: enumerateVideoDevices,
  getActiveStreamLabel: function getActiveStreamLabel() {
    var track = getActiveTrack();
    return track ? track.label : '';
  },
  getActiveTrack: getActiveTrack
};
/* harmony default export */ var camera_access = (QuaggaJSCameraAccess);
// CONCATENATED MODULE: ./src/analytics/result_collector.ts


function contains(codeResult, list) {
  return list && list.some(function (item) {
    var keys = Object.keys(item);
    return keys.every(function (key) {
      return item[key] === codeResult[key];
    });
  });
}

function passesFilter(codeResult, filter) {
  return typeof filter === 'function' ? filter(codeResult) : true;
}

/* harmony default export */ var result_collector = ({
  create: function create(config) {
    var _config$capacity;

    var canvas = document.createElement('canvas');
    var ctx = canvas.getContext('2d');
    var results = [];
    var capacity = (_config$capacity = config.capacity) !== null && _config$capacity !== void 0 ? _config$capacity : 20;
    var capture = config.capture === true;

    function matchesConstraints(codeResult) {
      return !!capacity && codeResult && !contains(codeResult, config.blacklist) && passesFilter(codeResult, config.filter);
    }

    return {
      addResult: function addResult(data, imageSize, codeResult) {
        var result = {}; // this is 'any' to avoid having to construct a whole QuaggaJSCodeResult :|

        if (matchesConstraints(codeResult)) {
          capacity--;
          result.codeResult = codeResult;

          if (capture) {
            canvas.width = imageSize.x;
            canvas.height = imageSize.y;
            image_debug["a" /* default */].drawImage(data, imageSize, ctx);
            result.frame = canvas.toDataURL();
          }

          results.push(result);
        }
      },
      getResults: function getResults() {
        return results;
      }
    };
  }
});
// CONCATENATED MODULE: ./src/config/config.dev.ts
var DevConfig = {
  inputStream: {
    name: 'Live',
    type: 'LiveStream',
    constraints: {
      width: 640,
      height: 480,
      // aspectRatio: 640/480, // optional
      facingMode: 'environment' // or user
      // deviceId: "38745983457387598375983759834"

    },
    area: {
      top: '0%',
      right: '0%',
      left: '0%',
      bottom: '0%'
    },
    singleChannel: false // true: only the red color-channel is read

  },
  locate: true,
  numOfWorkers: 0,
  decoder: {
    readers: ['code_128_reader'],
    debug: {
      drawBoundingBox: false,
      showFrequency: false,
      drawScanline: false,
      showPattern: false
    }
  },
  locator: {
    halfSample: true,
    patchSize: 'medium',
    // x-small, small, medium, large, x-large
    debug: {
      showCanvas: false,
      showPatches: false,
      showFoundPatches: false,
      showSkeleton: false,
      showLabels: false,
      showPatchLabels: false,
      showRemainingPatchLabels: false,
      boxFromPatches: {
        showTransformed: false,
        showTransformedBox: false,
        showBB: false
      }
    }
  }
};
/* harmony default export */ var config_dev = (DevConfig);
// CONCATENATED MODULE: ./src/config/config.node.ts
var NodeConfig = {
  inputStream: {
    type: 'ImageStream',
    sequence: false,
    size: 800,
    area: {
      top: '0%',
      right: '0%',
      left: '0%',
      bottom: '0%'
    },
    singleChannel: false // true: only the red color-channel is read

  },
  locate: true,
  numOfWorkers: 0,
  decoder: {
    readers: ['code_128_reader']
  },
  locator: {
    halfSample: true,
    patchSize: 'medium' // x-small, small, medium, large, x-large

  }
};
/* harmony default export */ var config_node = (NodeConfig);
// CONCATENATED MODULE: ./src/config/config.prod.ts
var ProdConfig = {
  inputStream: {
    name: 'Live',
    type: 'LiveStream',
    constraints: {
      width: 640,
      height: 480,
      // aspectRatio: 640/480, // optional
      facingMode: 'environment' // or user
      // deviceId: "38745983457387598375983759834"

    },
    area: {
      top: '0%',
      right: '0%',
      left: '0%',
      bottom: '0%'
    },
    singleChannel: false // true: only the red color-channel is read

  },
  locate: true,
  numOfWorkers: 4,
  decoder: {
    readers: ['code_128_reader']
  },
  locator: {
    halfSample: true,
    patchSize: 'medium' // x-small, small, medium, large, x-large

  }
};
/* harmony default export */ var config_prod = (ProdConfig);
// CONCATENATED MODULE: ./src/config/config.ts


 // @ts-ignore // TODO: this produces a bizarre typescript error
// eslint-disable-next-line no-nested-ternary

var QuaggaConfig =  false ? undefined :  true ? config_node : undefined;
/* harmony default export */ var config_config = (QuaggaConfig);
// EXTERNAL MODULE: ./node_modules/gl-vec2/index.js
var gl_vec2 = __webpack_require__(7);

// CONCATENATED MODULE: ./src/QuaggaContext.ts


var QuaggaContext_QuaggaContext = function QuaggaContext() {
  classCallCheck_default()(this, QuaggaContext);

  defineProperty_default()(this, "config", void 0);

  defineProperty_default()(this, "inputStream", void 0);

  defineProperty_default()(this, "framegrabber", void 0);

  defineProperty_default()(this, "inputImageWrapper", void 0);

  defineProperty_default()(this, "stopped", false);

  defineProperty_default()(this, "boxSize", void 0);

  defineProperty_default()(this, "resultCollector", void 0);

  defineProperty_default()(this, "decoder", void 0);

  defineProperty_default()(this, "workerPool", []);

  defineProperty_default()(this, "onUIThread", true);

  defineProperty_default()(this, "canvasContainer", new QuaggaContext_CanvasContainer());
};
var QuaggaContext_CanvasInfo = function CanvasInfo() {
  classCallCheck_default()(this, CanvasInfo);

  defineProperty_default()(this, "image", void 0);

  defineProperty_default()(this, "overlay", void 0);
};
var QuaggaContext_CanvasContainer = function CanvasContainer() {
  classCallCheck_default()(this, CanvasContainer);

  defineProperty_default()(this, "ctx", void 0);

  defineProperty_default()(this, "dom", void 0);

  this.ctx = new QuaggaContext_CanvasInfo();
  this.dom = new QuaggaContext_CanvasInfo();
};
// EXTERNAL MODULE: ./src/locator/barcode_locator.js
var barcode_locator = __webpack_require__(23);

// CONCATENATED MODULE: ./src/quagga/initBuffers.ts



// TODO: need typescript def for BarcodeLocator
function initBuffers_initBuffers(inputStream, imageWrapper, locator) {
  var inputImageWrapper = imageWrapper || new image_wrapper["a" /* default */]({
    x: inputStream.getWidth(),
    y: inputStream.getHeight(),
    type: 'XYSize'
  });

  if (false) {}

  var boxSize = [Object(gl_vec2["clone"])([0, 0]), Object(gl_vec2["clone"])([0, inputImageWrapper.size.y]), Object(gl_vec2["clone"])([inputImageWrapper.size.x, inputImageWrapper.size.y]), Object(gl_vec2["clone"])([inputImageWrapper.size.x, 0])];
  barcode_locator["a" /* default */].init(inputImageWrapper, locator);
  return {
    inputImageWrapper: inputImageWrapper,
    boxSize: boxSize
  };
}
// CONCATENATED MODULE: ./src/quagga/getViewPort.ts
function getViewPort_getViewPort(target) {
  if (typeof document === 'undefined') {
    return null;
  } // Check if target is already a DOM element


  if (target instanceof HTMLElement && target.nodeName && target.nodeType === 1) {
    return target;
  } // Use '#interactive.viewport' as a fallback selector (backwards compatibility)


  var selector = typeof target === 'string' ? target : '#interactive.viewport';
  return document.querySelector(selector);
}
// CONCATENATED MODULE: ./src/quagga/initCanvas.ts


function findOrCreateCanvas(selector, className) {
  var canvas = document.querySelector(selector);

  if (!canvas) {
    canvas = document.createElement('canvas');
    canvas.className = className;
  }

  return canvas;
}

function getCanvasAndContext(selector, className) {
  var canvas = findOrCreateCanvas(selector, className);
  var context = canvas.getContext('2d');
  return {
    canvas: canvas,
    context: context
  };
}

function initCanvases(canvasSize) {
  if (typeof document !== 'undefined') {
    var image = getCanvasAndContext('canvas.imgBuffer', 'imgBuffer');
    var overlay = getCanvasAndContext('canvas.drawingBuffer', 'drawingBuffer');
    image.canvas.width = overlay.canvas.width = canvasSize.x;
    image.canvas.height = overlay.canvas.height = canvasSize.y;
    return {
      dom: {
        image: image.canvas,
        overlay: overlay.canvas
      },
      ctx: {
        image: image.context,
        overlay: overlay.context
      }
    };
  }

  return null;
}

function initCanvas_initCanvas(context) {
  var _context$config, _context$config$input, _context$config2, _context$config2$inpu;

  var viewport = getViewPort_getViewPort(context === null || context === void 0 ? void 0 : (_context$config = context.config) === null || _context$config === void 0 ? void 0 : (_context$config$input = _context$config.inputStream) === null || _context$config$input === void 0 ? void 0 : _context$config$input.target);
  var type = context === null || context === void 0 ? void 0 : (_context$config2 = context.config) === null || _context$config2 === void 0 ? void 0 : (_context$config2$inpu = _context$config2.inputStream) === null || _context$config2$inpu === void 0 ? void 0 : _context$config2$inpu.type;
  if (!type) return null;
  var container = initCanvases(context.inputStream.getCanvasSize());
  if (!container) return {
    dom: {
      image: null,
      overlay: null
    },
    ctx: {
      image: null,
      overlay: null
    }
  };
  var dom = container.dom;

  if (typeof document !== 'undefined') {
    if (viewport) {
      if (type === 'ImageStream' && !viewport.contains(dom.image)) {
        viewport.appendChild(dom.image);
      }

      if (!viewport.contains(dom.overlay)) {
        viewport.appendChild(dom.overlay);
      }
    }
  }

  return container;
}
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/slicedToArray.js
var slicedToArray = __webpack_require__(33);
var slicedToArray_default = /*#__PURE__*/__webpack_require__.n(slicedToArray);

// EXTERNAL MODULE: external "get-pixels"
var external_get_pixels_ = __webpack_require__(89);
var external_get_pixels_default = /*#__PURE__*/__webpack_require__.n(external_get_pixels_);

// CONCATENATED MODULE: ./src/input/input_stream/input_stream.ts

// TODO: It's pretty likely that this shares code with the browser version, investigate that
// FOR ANYONE IN HERE IN THE FUTURE: This is the default input_stream module used for the Node bundle.
// webpack.config.js *replaces* this with input_stream_browser.ts when the bundle is being built for browser.

var inputStreamFactory = {
  createVideoStream: function createVideoStream() {
    throw new Error('createVideoStream not available');
  },
  createLiveStream: function createLiveStream() {
    throw new Error('createLiveStream not available');
  },
  createImageStream: function createImageStream() {
    var _config = null;
    var width = 0;
    var height = 0;
    var loaded = false; // TODO: frame should be a type NdArray, but NdArray doesn't have ts definitions
    // TODO: there is a ts-ndarray that might work, though

    var frame = null;
    var baseUrl;
    var _ended = false;
    var calculatedWidth;
    var calculatedHeight;
    var _eventNames = ['canrecord', 'ended'];
    var _eventHandlers = {};
    var _topRight = {
      x: 0,
      y: 0,
      type: 'Point'
    };
    var _canvasSize = {
      x: 0,
      y: 0,
      type: 'XYSize'
    };
    /* eslint-disable no-unused-vars */
    // false eslint errors? weird.
    // @ts-ignore

    var size = 0; // @ts-ignore

    var frameIdx = 0; // @ts-ignore

    var paused = false;
    /* eslint-enable no-unused-vars */

    function loadImages() {
      var _config2;

      loaded = false;
      /* eslint-disable new-cap */

      external_get_pixels_default()(baseUrl, (_config2 = _config) === null || _config2 === void 0 ? void 0 : _config2.mime, function (err, pixels) {
        var _config3, _config4;

        if (err) {
          console.error('**** quagga loadImages error:', err);
          throw new Error('error decoding pixels in loadImages');
        }

        loaded = true;

        if (false) {} // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment


        frame = pixels; // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-member-access

        var _pixels$shape = slicedToArray_default()(pixels.shape, 2);

        width = _pixels$shape[0];
        height = _pixels$shape[1];
        // eslint-disable-next-line no-nested-ternary
        calculatedWidth = (_config3 = _config) !== null && _config3 !== void 0 && _config3.size ? width / height > 1 ? _config.size : Math.floor(width / height * _config.size) : width; // eslint-disable-next-line no-nested-ternary

        calculatedHeight = (_config4 = _config) !== null && _config4 !== void 0 && _config4.size ? width / height > 1 ? Math.floor(height / width * _config.size) : _config.size : height;
        _canvasSize.x = calculatedWidth;
        _canvasSize.y = calculatedHeight;
        setTimeout(function () {
          // eslint-disable-next-line @typescript-eslint/no-use-before-define
          publishEvent('canrecord', []);
        }, 0);
      });
    }

    function publishEvent(eventName, args) {
      var handlers = _eventHandlers[eventName];

      if (handlers && handlers.length > 0) {
        for (var j = 0; j < handlers.length; j++) {
          // eslint-disable-next-line @typescript-eslint/no-use-before-define
          handlers[j].apply(inputStream, args);
        }
      }
    } // eslint-disable-next-line no-var,vars-on-top


    var inputStream = {
      trigger: publishEvent,
      getWidth: function getWidth() {
        return calculatedWidth;
      },
      getHeight: function getHeight() {
        return calculatedHeight;
      },
      setWidth: function setWidth(w) {
        calculatedWidth = w;
      },
      setHeight: function setHeight(h) {
        calculatedHeight = h;
      },
      getRealWidth: function getRealWidth() {
        return width;
      },
      getRealHeight: function getRealHeight() {
        return height;
      },
      setInputStream: function setInputStream(stream) {
        var _config5;

        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        _config = stream; // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-member-access

        baseUrl = (_config5 = _config) === null || _config5 === void 0 ? void 0 : _config5.src;
        size = 1;
        loadImages();
      },
      ended: function ended() {
        return _ended;
      },
      setAttribute: function setAttribute() {},
      getConfig: function getConfig() {
        return _config;
      },
      pause: function pause() {
        paused = true;
      },
      play: function play() {
        paused = false;
      },
      setCurrentTime: function setCurrentTime(time) {
        frameIdx = time;
      },
      addEventListener: function addEventListener(event, f) {
        if (_eventNames.indexOf(event) !== -1) {
          if (!_eventHandlers[event]) {
            _eventHandlers[event] = [];
          }

          _eventHandlers[event].push(f);
        }
      },
      clearEventHandlers: function clearEventHandlers() {
        Object.keys(_eventHandlers).forEach(function (ind) {
          return delete _eventHandlers[ind];
        });
      },
      setTopRight: function setTopRight(topRight) {
        _topRight.x = topRight.x;
        _topRight.y = topRight.y;
      },
      getTopRight: function getTopRight() {
        return _topRight;
      },
      setCanvasSize: function setCanvasSize(sz) {
        _canvasSize.x = sz.x;
        _canvasSize.y = sz.y;
      },
      getCanvasSize: function getCanvasSize() {
        return _canvasSize;
      },
      getFrame: function getFrame() {
        if (!loaded) {
          return null;
        } // eslint-disable-next-line @typescript-eslint/no-unsafe-return


        return frame;
      }
    };
    return inputStream;
  }
};
/* harmony default export */ var input_stream = (inputStreamFactory);
// EXTERNAL MODULE: ./src/input/frame_grabber.js
var frame_grabber = __webpack_require__(90);
var frame_grabber_default = /*#__PURE__*/__webpack_require__.n(frame_grabber);

// CONCATENATED MODULE: ./src/quagga/qworker.ts


function qworker_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function qworker_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { qworker_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { qworker_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/* Worker functions. These are straight from the original quagga.js file.
 * Not presently used, as worker support is non-functional.  Keeping them around temporarily
 * to refer to until it is re-implemented. We may be able to fix/use some of this.
 */
// TODO: need a typescript interface for FrameGrabber
var workerPool = [];
function updateWorkers(frameGrabber) {
  var availableWorker;

  if (workerPool.length) {
    availableWorker = workerPool.filter(function (workerThread) {
      return !workerThread.busy;
    })[0];

    if (availableWorker) {
      frameGrabber.attachData(availableWorker.imageData);

      if (frameGrabber.grab()) {
        availableWorker.busy = true;
        availableWorker.worker.postMessage({
          cmd: 'process',
          imageData: availableWorker.imageData
        }, [availableWorker.imageData.buffer]);
      }

      return true;
    } else {
      return false;
    }
  }

  return null;
}

function configForWorker(config) {
  return qworker_objectSpread(qworker_objectSpread({}, config), {}, {
    inputStream: qworker_objectSpread(qworker_objectSpread({}, config.inputStream), {}, {
      target: null
    })
  });
} // @ts-ignore


function workerInterface(factory) {
  if (factory) {
    var Quagga = factory()["default"];

    if (!Quagga) {
      // @ts-ignore
      self.postMessage({
        'event': 'error',
        message: 'Quagga could not be created'
      });
      return;
    }
  } // @ts-ignore


  var imageWrapper; // @ts-ignore

  function onProcessed(result) {
    self.postMessage({
      'event': 'processed',
      // @ts-ignore
      imageData: imageWrapper.data,
      result: result // @ts-ignore

    }, [imageWrapper.data.buffer]);
  }

  function workerInterfaceReady() {
    self.postMessage({
      'event': 'initialized',
      // @ts-ignore
      imageData: imageWrapper.data // @ts-ignore

    }, [imageWrapper.data.buffer]);
  } // @ts-ignore


  self.onmessage = function (e) {
    if (e.data.cmd === 'init') {
      var config = e.data.config;
      config.numOfWorkers = 0;
      imageWrapper = new Quagga.ImageWrapper({
        x: e.data.size.x,
        y: e.data.size.y
      }, new Uint8Array(e.data.imageData));
      Quagga.init(config, workerInterfaceReady, imageWrapper);
      Quagga.onProcessed(onProcessed);
    } else if (e.data.cmd === 'process') {
      // @ts-ignore
      imageWrapper.data = new Uint8Array(e.data.imageData);
      Quagga.start();
    } else if (e.data.cmd === 'setReaders') {
      Quagga.setReaders(e.data.readers);
    } else if (e.data.cmd === 'registerReader') {
      Quagga.registerReader(e.data.name, e.data.reader);
    }
  };
}

function generateWorkerBlob() {
  var blob, factorySource;
  /* jshint ignore:start */
  // @ts-ignore

  if (typeof __factorySource__ !== 'undefined') {
    // @ts-ignore
    factorySource = __factorySource__; // eslint-disable-line no-undef
  }
  /* jshint ignore:end */


  blob = new Blob(['(' + workerInterface.toString() + ')(' + factorySource + ');'], {
    type: 'text/javascript'
  });
  return window.URL.createObjectURL(blob);
}

function initWorker(config, inputStream, cb) {
  var blobURL = generateWorkerBlob();
  var worker = new Worker(blobURL);
  var workerThread = {
    worker: worker,
    imageData: new Uint8Array(inputStream.getWidth() * inputStream.getHeight()),
    busy: true
  };

  workerThread.worker.onmessage = function (e) {
    if (e.data.event === 'initialized') {
      URL.revokeObjectURL(blobURL);
      workerThread.busy = false;
      workerThread.imageData = new Uint8Array(e.data.imageData);

      if (false) {}

      cb(workerThread);
    } else if (e.data.event === 'processed') {
      workerThread.imageData = new Uint8Array(e.data.imageData);
      workerThread.busy = false; // TODO: how to thread publishResult into here?
      // publishResult(e.data.result, workerThread.imageData);
    } else if (e.data.event === 'error') {
      if (false) {}
    }
  };

  workerThread.worker.postMessage({
    cmd: 'init',
    size: {
      x: inputStream.getWidth(),
      y: inputStream.getHeight()
    },
    imageData: workerThread.imageData,
    config: configForWorker(config)
  }, [workerThread.imageData.buffer]);
}
function adjustWorkerPool(capacity, config, inputStream, cb) {
  var increaseBy = capacity - workerPool.length;

  if (increaseBy === 0 && cb) {
    cb();
  } else if (increaseBy < 0) {
    var workersToTerminate = workerPool.slice(increaseBy);
    workersToTerminate.forEach(function (workerThread) {
      workerThread.worker.terminate();

      if (false) {}
    });
    workerPool = workerPool.slice(0, increaseBy);

    if (cb) {
      cb();
    }
  } else {
    var workerInitialized = function workerInitialized(workerThread) {
      workerPool.push(workerThread);

      if (workerPool.length >= capacity && cb) {
        cb();
      }
    };

    if (config) {
      for (var i = 0; i < increaseBy; i++) {
        initWorker(config, inputStream, workerInitialized);
      }
    }
  }
}
function qworker_setReaders(readers) {
  workerPool.forEach(function (workerThread) {
    return workerThread.worker.postMessage({
      cmd: 'setReaders',
      readers: readers
    });
  });
}
function qworker_registerReader(name, reader) {
  workerPool.forEach(function (workerThread) {
    return workerThread.worker.postMessage({
      cmd: 'registerReader',
      name: name,
      reader: reader
    });
  });
}
// CONCATENATED MODULE: ./src/quagga/setupInputStream.ts
// TODO: need to create an InputStream typescript interface, so we don't have an "any" in the next line
function setupInputStream() {
  var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'LiveStream';
  var viewport = arguments.length > 1 ? arguments[1] : undefined;
  var InputStream = arguments.length > 2 ? arguments[2] : undefined;

  switch (type) {
    case 'VideoStream':
      {
        var video = document.createElement('video');
        return {
          video: video,
          inputStream: InputStream.createVideoStream(video)
        };
      }

    case 'ImageStream':
      return {
        inputStream: InputStream.createImageStream()
      };

    case 'LiveStream':
      {
        var _video = null;

        if (viewport) {
          _video = viewport.querySelector('video');

          if (!_video) {
            _video = document.createElement('video');
            viewport.appendChild(_video);
          }
        }

        return {
          video: _video,
          inputStream: InputStream.createLiveStream(_video)
        };
      }

    default:
      console.error("* setupInputStream invalid type ".concat(type));
      return {
        video: null,
        inputStream: null
      };
  }
}
// CONCATENATED MODULE: ./src/quagga/transform.ts
/* eslint-disable no-param-reassign */
function moveBox(box, xOffset, yOffset) {
  var corner = box.length;

  while (corner--) {
    box[corner][0] += xOffset;
    box[corner][1] += yOffset;
  }
}
function moveLine(line, xOffset, yOffset) {
  line[0].x += xOffset;
  line[0].y += yOffset;
  line[1].x += xOffset;
  line[1].y += yOffset;
}
// CONCATENATED MODULE: ./src/quagga/quagga.ts




















var quagga_Quagga = /*#__PURE__*/function () {
  function Quagga() {
    var _this = this;

    classCallCheck_default()(this, Quagga);

    defineProperty_default()(this, "context", new QuaggaContext_QuaggaContext());

    defineProperty_default()(this, "canRecord", function (callback) {
      var _this$context$config;

      if (!_this.context.config) {
        return;
      }

      barcode_locator["a" /* default */].checkImageConstraints(_this.context.inputStream, (_this$context$config = _this.context.config) === null || _this$context$config === void 0 ? void 0 : _this$context$config.locator);

      _this.initCanvas();

      _this.context.framegrabber = frame_grabber_default.a.create(_this.context.inputStream, _this.context.canvasContainer.dom.image);

      if (_this.context.config.numOfWorkers === undefined) {
        _this.context.config.numOfWorkers = 0;
      }

      adjustWorkerPool(_this.context.config.numOfWorkers, _this.context.config, _this.context.inputStream, function () {
        var _this$context$config2;

        if (((_this$context$config2 = _this.context.config) === null || _this$context$config2 === void 0 ? void 0 : _this$context$config2.numOfWorkers) === 0) {
          _this.initializeData();
        }

        _this.ready(callback);
      });
    });

    defineProperty_default()(this, "update", function () {
      if (_this.context.onUIThread) {
        var workersUpdated = updateWorkers(_this.context.framegrabber);

        if (!workersUpdated) {
          var _this$context$inputIm;

          _this.context.framegrabber.attachData((_this$context$inputIm = _this.context.inputImageWrapper) === null || _this$context$inputIm === void 0 ? void 0 : _this$context$inputIm.data);

          if (_this.context.framegrabber.grab()) {
            if (!workersUpdated) {
              _this.locateAndDecode();
            }
          }
        }
      } else {
        var _this$context$inputIm2;

        _this.context.framegrabber.attachData((_this$context$inputIm2 = _this.context.inputImageWrapper) === null || _this$context$inputIm2 === void 0 ? void 0 : _this$context$inputIm2.data);

        _this.context.framegrabber.grab();

        _this.locateAndDecode();
      }
    });
  }

  createClass_default()(Quagga, [{
    key: "initBuffers",
    value: function initBuffers(imageWrapper) {
      if (!this.context.config) {
        return;
      }

      var _initBuffers2 = initBuffers_initBuffers(this.context.inputStream, imageWrapper, this.context.config.locator),
          inputImageWrapper = _initBuffers2.inputImageWrapper,
          boxSize = _initBuffers2.boxSize;

      this.context.inputImageWrapper = inputImageWrapper;
      this.context.boxSize = boxSize;
    }
  }, {
    key: "initializeData",
    value: function initializeData(imageWrapper) {
      if (!this.context.config) {
        return;
      }

      this.initBuffers(imageWrapper);
      this.context.decoder = barcode_decoder.create(this.context.config.decoder, this.context.inputImageWrapper);
    }
  }, {
    key: "getViewPort",
    value: function getViewPort() {
      if (!this.context.config || !this.context.config.inputStream) {
        return null;
      }

      var target = this.context.config.inputStream.target;
      return getViewPort_getViewPort(target);
    }
  }, {
    key: "ready",
    value: function ready(callback) {
      this.context.inputStream.play();
      callback();
    }
  }, {
    key: "initCanvas",
    value: function initCanvas() {
      var container = initCanvas_initCanvas(this.context);

      if (!container) {
        return;
      }

      var ctx = container.ctx,
          dom = container.dom;
      this.context.canvasContainer.dom.image = dom.image;
      this.context.canvasContainer.dom.overlay = dom.overlay;
      this.context.canvasContainer.ctx.image = ctx.image;
      this.context.canvasContainer.ctx.overlay = ctx.overlay;
    }
  }, {
    key: "initInputStream",
    value: function initInputStream(callback) {
      if (!this.context.config || !this.context.config.inputStream) {
        return;
      }

      var _this$context$config$ = this.context.config.inputStream,
          inputType = _this$context$config$.type,
          constraints = _this$context$config$.constraints;

      var _setupInputStream = setupInputStream(inputType, this.getViewPort(), input_stream),
          video = _setupInputStream.video,
          inputStream = _setupInputStream.inputStream;

      if (inputType === 'LiveStream' && video) {
        camera_access.request(video, constraints).then(function () {
          return inputStream.trigger('canrecord');
        })["catch"](function (err) {
          return callback(err);
        });
      }

      inputStream.setAttribute('preload', 'auto');
      inputStream.setInputStream(this.context.config.inputStream);
      inputStream.addEventListener('canrecord', this.canRecord.bind(undefined, callback));
      this.context.inputStream = inputStream;
    }
  }, {
    key: "getBoundingBoxes",
    value: function getBoundingBoxes() {
      var _this$context$config3;

      return (_this$context$config3 = this.context.config) !== null && _this$context$config3 !== void 0 && _this$context$config3.locate ? barcode_locator["a" /* default */].locate() : [[Object(gl_vec2["clone"])(this.context.boxSize[0]), Object(gl_vec2["clone"])(this.context.boxSize[1]), Object(gl_vec2["clone"])(this.context.boxSize[2]), Object(gl_vec2["clone"])(this.context.boxSize[3])]];
    } // TODO: need a typescript type for result here.
    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types

  }, {
    key: "transformResult",
    value: function transformResult(result) {
      var _this2 = this;

      var topRight = this.context.inputStream.getTopRight();
      var xOffset = topRight.x;
      var yOffset = topRight.y;

      if (xOffset === 0 && yOffset === 0) {
        return;
      }

      if (result.barcodes) {
        // TODO: BarcodeInfo may not be the right type here.
        result.barcodes.forEach(function (barcode) {
          return _this2.transformResult(barcode);
        });
      }

      if (result.line && result.line.length === 2) {
        moveLine(result.line, xOffset, yOffset);
      }

      if (result.box) {
        moveBox(result.box, xOffset, yOffset);
      }

      if (result.boxes && result.boxes.length > 0) {
        for (var i = 0; i < result.boxes.length; i++) {
          moveBox(result.boxes[i], xOffset, yOffset);
        }
      }
    }
  }, {
    key: "addResult",
    value: function addResult(result, imageData) {
      var _this3 = this;

      if (!imageData || !this.context.resultCollector) {
        return;
      } // TODO: Figure out what data structure holds a "barcodes" result, if any...


      if (result.barcodes) {
        result.barcodes.filter(function (barcode) {
          return barcode.codeResult;
        }).forEach(function (barcode) {
          return _this3.addResult(barcode, imageData);
        });
      } else if (result.codeResult) {
        this.context.resultCollector.addResult(imageData, this.context.inputStream.getCanvasSize(), result.codeResult);
      }
    } // eslint-disable-next-line class-methods-use-this

  }, {
    key: "hasCodeResult",
    value: function hasCodeResult(result) {
      return !!(result && (result.barcodes ? result.barcodes.some(function (barcode) {
        return barcode.codeResult;
      }) : result.codeResult));
    } // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types

  }, {
    key: "publishResult",
    value: function publishResult() {
      var result = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var imageData = arguments.length > 1 ? arguments[1] : undefined;
      var resultToPublish = result;

      if (result && this.context.onUIThread) {
        this.transformResult(result);
        this.addResult(result, imageData);
        resultToPublish = result.barcodes || result;
      }

      events.publish('processed', resultToPublish);

      if (this.hasCodeResult(result)) {
        events.publish('detected', resultToPublish);
      }
    }
  }, {
    key: "locateAndDecode",
    value: function locateAndDecode() {
      var boxes = this.getBoundingBoxes();

      if (boxes) {
        var _this$context$inputIm3;

        var decodeResult = this.context.decoder.decodeFromBoundingBoxes(boxes) || {};
        decodeResult.boxes = boxes;
        this.publishResult(decodeResult, (_this$context$inputIm3 = this.context.inputImageWrapper) === null || _this$context$inputIm3 === void 0 ? void 0 : _this$context$inputIm3.data);
      } else {
        var imageResult = this.context.decoder.decodeFromImage(this.context.inputImageWrapper);

        if (imageResult) {
          var _this$context$inputIm4;

          this.publishResult(imageResult, (_this$context$inputIm4 = this.context.inputImageWrapper) === null || _this$context$inputIm4 === void 0 ? void 0 : _this$context$inputIm4.data);
        } else {
          this.publishResult();
        }
      }
    }
  }, {
    key: "startContinuousUpdate",
    value: function startContinuousUpdate() {
      var _this$context$config4,
          _this4 = this;

      var next = null;
      var delay = 1000 / (((_this$context$config4 = this.context.config) === null || _this$context$config4 === void 0 ? void 0 : _this$context$config4.frequency) || 60);
      this.context.stopped = false;
      var context = this.context;

      var newFrame = function newFrame(timestamp) {
        next = next || timestamp;

        if (!context.stopped) {
          if (timestamp >= next) {
            next += delay;

            _this4.update();
          }

          window.requestAnimationFrame(newFrame);
        }
      };

      newFrame(performance.now());
    }
  }, {
    key: "start",
    value: function start() {
      var _this$context$config5, _this$context$config6;

      if (this.context.onUIThread && ((_this$context$config5 = this.context.config) === null || _this$context$config5 === void 0 ? void 0 : (_this$context$config6 = _this$context$config5.inputStream) === null || _this$context$config6 === void 0 ? void 0 : _this$context$config6.type) === 'LiveStream') {
        this.startContinuousUpdate();
      } else {
        this.update();
      }
    }
  }, {
    key: "stop",
    value: function () {
      var _stop = asyncToGenerator_default()( /*#__PURE__*/regenerator_default.a.mark(function _callee() {
        var _this$context$config7;

        return regenerator_default.a.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                this.context.stopped = true;
                adjustWorkerPool(0);

                if (!((_this$context$config7 = this.context.config) !== null && _this$context$config7 !== void 0 && _this$context$config7.inputStream && this.context.config.inputStream.type === 'LiveStream')) {
                  _context.next = 6;
                  break;
                }

                _context.next = 5;
                return camera_access.release();

              case 5:
                this.context.inputStream.clearEventHandlers();

              case 6:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function stop() {
        return _stop.apply(this, arguments);
      }

      return stop;
    }()
  }, {
    key: "setReaders",
    value: function setReaders(readers) {
      if (this.context.decoder) {
        this.context.decoder.setReaders(readers);
      }

      qworker_setReaders(readers);
    }
  }, {
    key: "registerReader",
    value: function registerReader(name, reader) {
      barcode_decoder.registerReader(name, reader);

      if (this.context.decoder) {
        this.context.decoder.registerReader(name, reader);
      }

      qworker_registerReader(name, reader);
    }
  }]);

  return Quagga;
}();


// CONCATENATED MODULE: ./src/quagga.js


 // eslint-disable-line no-unused-vars










var instance = new quagga_Quagga();
var quagga_context = instance.context;
var QuaggaJSStaticInterface = {
  init: function init(config, cb, imageWrapper) {
    var quaggaInstance = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : instance;
    var promise;

    if (!cb) {
      promise = new Promise(function (resolve, reject) {
        cb = function cb(err) {
          err ? reject(err) : resolve();
        };
      });
    }

    quaggaInstance.context.config = merge_default()({}, config_config, config); // TODO #179: pending restructure in Issue #179, we are temp disabling workers

    if (quaggaInstance.context.config.numOfWorkers > 0) {
      quaggaInstance.context.config.numOfWorkers = 0;
    }

    if (imageWrapper) {
      quaggaInstance.context.onUIThread = false;
      quaggaInstance.initializeData(imageWrapper);

      if (cb) {
        cb();
      }
    } else {
      quaggaInstance.initInputStream(cb);
    }

    return promise;
  },
  start: function start() {
    return instance.start();
  },
  stop: function stop() {
    return instance.stop();
  },
  pause: function pause() {
    quagga_context.stopped = true;
  },
  onDetected: function onDetected(callback) {
    if (!callback || typeof callback !== 'function' && (typeof_default()(callback) !== 'object' || !callback.callback)) {
      console.trace('* warning: Quagga.onDetected called with invalid callback, ignoring');
      return;
    }

    events.subscribe('detected', callback);
  },
  offDetected: function offDetected(callback) {
    events.unsubscribe('detected', callback);
  },
  onProcessed: function onProcessed(callback) {
    if (!callback || typeof callback !== 'function' && (typeof_default()(callback) !== 'object' || !callback.callback)) {
      console.trace('* warning: Quagga.onProcessed called with invalid callback, ignoring');
      return;
    }

    events.subscribe('processed', callback);
  },
  offProcessed: function offProcessed(callback) {
    events.unsubscribe('processed', callback);
  },
  setReaders: function setReaders(readers) {
    if (!readers) {
      console.trace('* warning: Quagga.setReaders called with no readers, ignoring');
      return;
    }

    instance.setReaders(readers);
  },
  registerReader: function registerReader(name, reader) {
    if (!name) {
      console.trace('* warning: Quagga.registerReader called with no name, ignoring');
      return;
    }

    if (!reader) {
      console.trace('* warning: Quagga.registerReader called with no reader, ignoring');
      return;
    }

    instance.registerReader(name, reader);
  },
  registerResultCollector: function registerResultCollector(resultCollector) {
    if (resultCollector && typeof resultCollector.addResult === 'function') {
      quagga_context.resultCollector = resultCollector;
    }
  },

  get canvas() {
    return quagga_context.canvasContainer;
  },

  decodeSingle: function decodeSingle(config, resultCallback) {
    var _this = this;

    var quaggaInstance = new quagga_Quagga();
    config = merge_default()({
      inputStream: {
        type: 'ImageStream',
        sequence: false,
        size: 800,
        src: config.src
      },
      numOfWorkers:  false ? undefined : 1,
      locator: {
        halfSample: false
      }
    }, config); // TODO #175: restructure worker support so that it will work with typescript using worker-loader
    // https://webpack.js.org/loaders/worker-loader/

    if (config.numOfWorkers > 0) {
      config.numOfWorkers = 0;
    } // workers require Worker and Blob support presently, so if no Blob or Worker then set
    // workers to 0.


    if (config.numOfWorkers > 0 && (typeof Blob === 'undefined' || typeof Worker === 'undefined')) {
      console.warn('* no Worker and/or Blob support - forcing numOfWorkers to 0');
      config.numOfWorkers = 0;
    }

    return new Promise(function (resolve, reject) {
      try {
        _this.init(config, function () {
          events.once('processed', function (result) {
            quaggaInstance.stop();

            if (resultCallback) {
              resultCallback.call(null, result);
            }

            resolve(result);
          }, true);
          quaggaInstance.start();
        }, null, quaggaInstance);
      } catch (err) {
        reject(err);
      }
    });
  },

  // add the usually expected "default" for use with require, build step won't allow us to
  // write to module.exports so do it here.
  get default() {
    return QuaggaJSStaticInterface;
  },

  Readers: reader_namespaceObject,
  CameraAccess: camera_access,
  ImageDebug: image_debug["a" /* default */],
  ImageWrapper: image_wrapper["a" /* default */],
  ResultCollector: result_collector
};
/* harmony default export */ var quagga = __webpack_exports__["default"] = (QuaggaJSStaticInterface); // export BarcodeReader and other utilities for external plugins



/***/ })
/******/ ])["default"]));
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXNzZXJ0VGhpc0luaXRpYWxpemVkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2dldFByb3RvdHlwZU9mLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW5oZXJpdHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbW1vbi9hcnJheV9oZWxwZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbW1vbi9pbWFnZV93cmFwcGVyLnRzIiwid2VicGFjazovLy8uL3NyYy9jb21tb24vY2x1c3Rlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvY29tbW9uL2N2X3V0aWxzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9yZWdlbmVyYXRvci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9nZXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc09iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzQXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbW1vbi9pbWFnZV9kZWJ1Zy50cyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL21lcmdlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3Jvb3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc09iamVjdExpa2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvdHlwZW9mLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2FzeW5jVG9HZW5lcmF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2xvY2F0b3IvdHJhY2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VHZXRUYWcuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2xvY2F0b3IvYmFyY29kZV9sb2NhdG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX0xpc3RDYWNoZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hc3NvY0luZGV4T2YuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9lcS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19TeW1ib2wuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbmF0aXZlQ3JlYXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldE1hcERhdGEuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0FyZ3VtZW50cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pc0luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nhc3RQYXRoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3NsaWNlZFRvQXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvdG9Db25zdW1hYmxlQXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLW1hdDIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0TmF0aXZlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNGdW5jdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlQXNzaWduVmFsdWUuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL21vZHVsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzQXJyYXlMaWtlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNMZW5ndGguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvc2V0UHJvdG90eXBlT2YuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc1N5bWJvbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL190b0tleS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19NYXAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZnJlZUdsb2JhbC5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX01hcENhY2hlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Fzc2lnbk1lcmdlVmFsdWUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZGVmaW5lUHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0UHJvdG90eXBlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzUHJvdG90eXBlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNCdWZmZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc1R5cGVkQXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc2FmZUdldC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hc3NpZ25WYWx1ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL2tleXNJbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lkZW50aXR5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX292ZXJSZXN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3NldFRvU3RyaW5nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2FycmF5TGlrZVRvQXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvZXBzaWxvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9jcmVhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvc3VidHJhY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvbXVsdGlwbHkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvZGl2aWRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL2Rpc3RhbmNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL3NxdWFyZWREaXN0YW5jZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9sZW5ndGguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvc3F1YXJlZExlbmd0aC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9lcHNpbG9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL2NyZWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9mcm9tVmFsdWVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL25vcm1hbGl6ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9kb3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvc3VidHJhY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvbXVsdGlwbHkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvZGl2aWRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL2Rpc3RhbmNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL3NxdWFyZWREaXN0YW5jZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9sZW5ndGguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvc3F1YXJlZExlbmd0aC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL3BpY2suanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvd3JhcE5hdGl2ZVN1cGVyLmpzIiwid2VicGFjazovLy8uL3NyYy9sb2NhdG9yL3Jhc3Rlcml6ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2xvY2F0b3Ivc2tlbGV0b25pemVyLmpzIiwid2VicGFjazovLy9leHRlcm5hbCBcImdldC1waXhlbHNcIiIsIndlYnBhY2s6Ly8vLi9zcmMvaW5wdXQvZnJhbWVfZ3JhYmJlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlTWVyZ2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fU3RhY2suanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbGlzdENhY2hlQ2xlYXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbGlzdENhY2hlRGVsZXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZUdldC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19saXN0Q2FjaGVIYXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbGlzdENhY2hlU2V0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0YWNrQ2xlYXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RhY2tEZWxldGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RhY2tHZXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RhY2tIYXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RhY2tTZXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzTmF0aXZlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldFJhd1RhZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19vYmplY3RUb1N0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pc01hc2tlZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jb3JlSnNEYXRhLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3RvU291cmNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldFZhbHVlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlQ2xlYXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fSGFzaC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19oYXNoQ2xlYXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzaERlbGV0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19oYXNoR2V0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc2hIYXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzaFNldC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19tYXBDYWNoZURlbGV0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pc0tleWFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwQ2FjaGVHZXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwQ2FjaGVIYXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwQ2FjaGVTZXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUZvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jcmVhdGVCYXNlRm9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VNZXJnZURlZXAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY2xvbmVCdWZmZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY2xvbmVUeXBlZEFycmF5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nsb25lQXJyYXlCdWZmZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fVWludDhBcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jb3B5QXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faW5pdENsb25lT2JqZWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VDcmVhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fb3ZlckFyZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNBcmd1bWVudHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0FycmF5TGlrZU9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL3N0dWJGYWxzZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzUGxhaW5PYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzVHlwZWRBcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlVW5hcnkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbm9kZVV0aWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC90b1BsYWluT2JqZWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NvcHlPYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlMaWtlS2V5cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlVGltZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUtleXNJbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19uYXRpdmVLZXlzSW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY3JlYXRlQXNzaWduZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVJlc3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXBwbHkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVNldFRvU3RyaW5nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvY29uc3RhbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc2hvcnRPdXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faXNJdGVyYXRlZUNhbGwuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbW1vbi90eXBlZGVmcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hcnJheVdpdGhIb2xlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pdGVyYWJsZVRvQXJyYXlMaW1pdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9ub25JdGVyYWJsZVJlc3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvY2xvbmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvZnJvbVZhbHVlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9jb3B5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL3NldC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9lcXVhbHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvZXhhY3RFcXVhbHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvYWRkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL3N1Yi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9tdWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvZGl2LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL2ludmVyc2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvbWluLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL21heC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9yb3RhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvZmxvb3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvY2VpbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9yb3VuZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9zY2FsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9zY2FsZUFuZEFkZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9kaXN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL3NxckRpc3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvbGVuLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL3Nxckxlbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9uZWdhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvbm9ybWFsaXplLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL2RvdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9jcm9zcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9sZXJwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL3JhbmRvbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi90cmFuc2Zvcm1NYXQyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL3RyYW5zZm9ybU1hdDJkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL3RyYW5zZm9ybU1hdDMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvdHJhbnNmb3JtTWF0NC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9mb3JFYWNoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL2xpbWl0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL2Nsb25lLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL2FuZ2xlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL2NvcHkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvc2V0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL2VxdWFscy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9leGFjdEVxdWFscy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9hZGQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvc3ViLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL211bC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9kaXYuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvbWluLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL21heC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9mbG9vci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9jZWlsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL3JvdW5kLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL3NjYWxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL3NjYWxlQW5kQWRkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL2Rpc3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvc3FyRGlzdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9sZW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvc3FyTGVuLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL25lZ2F0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9pbnZlcnNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL2Nyb3NzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL2xlcnAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvcmFuZG9tLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL3RyYW5zZm9ybU1hdDQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvdHJhbnNmb3JtTWF0My5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy90cmFuc2Zvcm1RdWF0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL3JvdGF0ZVguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvcm90YXRlWS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9yb3RhdGVaLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL2ZvckVhY2guanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXJyYXlXaXRob3V0SG9sZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvaXRlcmFibGVUb0FycmF5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL25vbkl0ZXJhYmxlU3ByZWFkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3N1cGVyUHJvcEJhc2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlUGljay5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlUGlja0J5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VHZXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faXNLZXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RyaW5nVG9QYXRoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21lbW9pemVDYXBwZWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9tZW1vaXplLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvdG9TdHJpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVRvU3RyaW5nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5TWFwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VTZXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9oYXNJbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSGFzSW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzUGF0aC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19mbGF0UmVzdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL2ZsYXR0ZW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUZsYXR0ZW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlQdXNoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzRmxhdHRlbmFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvaXNOYXRpdmVGdW5jdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jb25zdHJ1Y3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC1tYXQyL2RldGVybWluYW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC1tYXQyL3RyYW5zcG9zZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2wtbWF0Mi9tdWx0aXBseS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2wtbWF0Mi9pZGVudGl0eS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2wtbWF0Mi9hZGpvaW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC1tYXQyL3JvdGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2wtbWF0Mi9pbnZlcnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLW1hdDIvY3JlYXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC1tYXQyL3NjYWxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC1tYXQyL2NvcHkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLW1hdDIvZnJvYi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2wtbWF0Mi9sZHUuanMiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwibmRhcnJheVwiIiwid2VicGFjazovLy9leHRlcm5hbCBcIm5kYXJyYXktbGluZWFyLWludGVycG9sYXRlXCIiLCJ3ZWJwYWNrOi8vLy4vc3JjL2RlY29kZXIvYnJlc2VuaGFtLmpzIiwid2VicGFjazovLy8uL3NyYy9yZWFkZXIvYmFyY29kZV9yZWFkZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3JlYWRlci9jb2RlXzEyOF9yZWFkZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3JlYWRlci9lYW5fcmVhZGVyLnRzIiwid2VicGFjazovLy8uL3NyYy9yZWFkZXIvY29kZV8zOV9yZWFkZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3JlYWRlci9jb2RlXzM5X3Zpbl9yZWFkZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3JlYWRlci9jb2RhYmFyX3JlYWRlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvcmVhZGVyL3VwY19yZWFkZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3JlYWRlci9lYW5fOF9yZWFkZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3JlYWRlci9lYW5fMl9yZWFkZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3JlYWRlci9lYW5fNV9yZWFkZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3JlYWRlci91cGNfZV9yZWFkZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3JlYWRlci9pMm9mNV9yZWFkZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3JlYWRlci8yb2Y1X3JlYWRlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvcmVhZGVyL2NvZGVfOTNfcmVhZGVyLnRzIiwid2VicGFjazovLy8uL3NyYy9yZWFkZXIvY29kZV8zMl9yZWFkZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2RlY29kZXIvYmFyY29kZV9kZWNvZGVyLmpzIiwid2VicGFjazovLy8uL3NyYy9yZWFkZXIvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbW1vbi9ldmVudHMudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3F1YWdnYS9FeGNlcHRpb24udHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbW1vbi9tZWRpYURldmljZXMudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2lucHV0L2NhbWVyYV9hY2Nlc3MudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FuYWx5dGljcy9yZXN1bHRfY29sbGVjdG9yLnRzIiwid2VicGFjazovLy8uL3NyYy9jb25maWcvY29uZmlnLmRldi50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29uZmlnL2NvbmZpZy5ub2RlLnRzIiwid2VicGFjazovLy8uL3NyYy9jb25maWcvY29uZmlnLnByb2QudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbmZpZy9jb25maWcudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL1F1YWdnYUNvbnRleHQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3F1YWdnYS9pbml0QnVmZmVycy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvcXVhZ2dhL2dldFZpZXdQb3J0LnRzIiwid2VicGFjazovLy8uL3NyYy9xdWFnZ2EvaW5pdENhbnZhcy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvaW5wdXQvaW5wdXRfc3RyZWFtL2lucHV0X3N0cmVhbS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvcXVhZ2dhL3F3b3JrZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3F1YWdnYS9zZXR1cElucHV0U3RyZWFtLnRzIiwid2VicGFjazovLy8uL3NyYy9xdWFnZ2EvdHJhbnNmb3JtLnRzIiwid2VicGFjazovLy8uL3NyYy9xdWFnZ2EvcXVhZ2dhLnRzIiwid2VicGFjazovLy8uL3NyYy9xdWFnZ2EuanMiXSwibmFtZXMiOlsiX2RlZmluZVByb3BlcnR5Iiwib2JqIiwia2V5IiwidmFsdWUiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIm1vZHVsZSIsImV4cG9ydHMiLCJfX2VzTW9kdWxlIiwiX2Fzc2VydFRoaXNJbml0aWFsaXplZCIsInNlbGYiLCJSZWZlcmVuY2VFcnJvciIsIl9nZXRQcm90b3R5cGVPZiIsIm8iLCJzZXRQcm90b3R5cGVPZiIsImdldFByb3RvdHlwZU9mIiwiX19wcm90b19fIiwiX2NsYXNzQ2FsbENoZWNrIiwiaW5zdGFuY2UiLCJDb25zdHJ1Y3RvciIsIlR5cGVFcnJvciIsIl9kZWZpbmVQcm9wZXJ0aWVzIiwidGFyZ2V0IiwicHJvcHMiLCJpIiwibGVuZ3RoIiwiZGVzY3JpcHRvciIsIl9jcmVhdGVDbGFzcyIsInByb3RvUHJvcHMiLCJzdGF0aWNQcm9wcyIsInByb3RvdHlwZSIsIl90eXBlb2YiLCJyZXF1aXJlIiwiYXNzZXJ0VGhpc0luaXRpYWxpemVkIiwiX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4iLCJjYWxsIiwiX2luaGVyaXRzIiwic3ViQ2xhc3MiLCJzdXBlckNsYXNzIiwiY3JlYXRlIiwiY29uc3RydWN0b3IiLCJFUFNJTE9OIiwiY2xvbmUiLCJmcm9tVmFsdWVzIiwiY29weSIsInNldCIsImVxdWFscyIsImV4YWN0RXF1YWxzIiwiYWRkIiwic3VidHJhY3QiLCJzdWIiLCJtdWx0aXBseSIsIm11bCIsImRpdmlkZSIsImRpdiIsImludmVyc2UiLCJtaW4iLCJtYXgiLCJyb3RhdGUiLCJmbG9vciIsImNlaWwiLCJyb3VuZCIsInNjYWxlIiwic2NhbGVBbmRBZGQiLCJkaXN0YW5jZSIsImRpc3QiLCJzcXVhcmVkRGlzdGFuY2UiLCJzcXJEaXN0IiwibGVuIiwic3F1YXJlZExlbmd0aCIsInNxckxlbiIsIm5lZ2F0ZSIsIm5vcm1hbGl6ZSIsImRvdCIsImNyb3NzIiwibGVycCIsInJhbmRvbSIsInRyYW5zZm9ybU1hdDIiLCJ0cmFuc2Zvcm1NYXQyZCIsInRyYW5zZm9ybU1hdDMiLCJ0cmFuc2Zvcm1NYXQ0IiwiZm9yRWFjaCIsImxpbWl0IiwiaW5pdCIsImFyciIsInZhbCIsImwiLCJzaHVmZmxlIiwiaiIsIk1hdGgiLCJ4IiwidG9Qb2ludExpc3QiLCJyb3dzIiwicmVkdWNlIiwicCIsIm4iLCJyb3ciLCJqb2luIiwicHVzaCIsInRocmVzaG9sZCIsInNjb3JlRnVuYyIsInF1ZXVlIiwicHJldiIsIm5leHQiLCJhcHBseSIsIm1heEluZGV4Iiwic3VtIiwidmVjMiIsImFzc2VydE51bWJlclBvc2l0aXZlIiwiRXJyb3IiLCJJbWFnZVdyYXBwZXIiLCJzaXplIiwiZGF0YSIsIkFycmF5VHlwZSIsIlVpbnQ4QXJyYXkiLCJpbml0aWFsaXplIiwieSIsIkFycmF5SGVscGVyIiwiaW1nUmVmIiwiYm9yZGVyIiwiaW1hZ2VXcmFwcGVyIiwiZnJvbSIsInNpemVYIiwic2l6ZVkiLCJpbmRleE1hcHBpbmciLCJ3aWR0aCIsImhlaWdodCIsImxhYmVsQ291bnQiLCJ5c3EiLCJsYWJlbFN1bSIsImxhYmVsIiwibXUxMSIsIm11MDIiLCJtdTIwIiwieF8iLCJ5XyIsInRtcCIsInJlc3VsdCIsIlBJIiwiUElfNCIsIm0wMCIsIm0wMSIsIm0xMCIsIm0xMSIsIm0wMiIsIm0yMCIsInRoZXRhIiwicmFkIiwiaXNOYU4iLCJhdGFuIiwidmVjIiwiY29zIiwic2luIiwicmV0IiwiVWludDhDbGFtcGVkQXJyYXkiLCJwaXhlbCIsImN1cnJlbnQiLCJnZXQiLCJjYW52YXMiLCJjdHgiLCJnZXRDb250ZXh0IiwiZnJhbWUiLCJnZXRJbWFnZURhdGEiLCJnZXRBc1JHQkEiLCJuZXdGcmFtZSIsIkltYWdlRGF0YSIsInB1dEltYWdlRGF0YSIsImluU2NhbGUiLCJhZGp1c3RlZFNjYWxlIiwiaHN2IiwicmdiIiwid2hpdGVSZ2IiLCJibGFja1JnYiIsImhzdjJyZ2IiLCJwb3MiLCJwb2ludCIsInBvaW50cyIsImNlbnRlciIsInBvaW50TWFwIiwicG9pbnRUb0FkZCIsImlkIiwidXBkYXRlQ2VudGVyIiwiZml0cyIsIm90aGVyUG9pbnQiLCJzaW1pbGFyaXR5IiwiYWJzIiwiZ2V0UG9pbnRzIiwiZ2V0Q2VudGVyIiwiY3JlYXRlUG9pbnQiLCJuZXdQb2ludCIsInByb3BlcnR5IiwidjJjbG9uZSIsInZlYzMiLCJ2M2Nsb25lIiwiaW1hZ2VSZWYiLCJ0aGF0IiwidG9WZWMyIiwidG9WZWMzIiwiY29tcHV0ZUludGVncmFsSW1hZ2UyIiwiaW50ZWdyYWxXcmFwcGVyIiwiaW1hZ2VEYXRhIiwiaW50ZWdyYWxJbWFnZURhdGEiLCJwb3NBIiwicG9zQiIsInBvc0MiLCJwb3NEIiwiY29tcHV0ZUludGVncmFsSW1hZ2UiLCJ2IiwidSIsInRocmVzaG9sZEltYWdlIiwidGFyZ2V0V3JhcHBlciIsInRhcmdldERhdGEiLCJjb21wdXRlSGlzdG9ncmFtIiwiYml0c1BlclBpeGVsIiwiYml0U2hpZnQiLCJidWNrZXRDbnQiLCJoaXN0IiwiSW50MzJBcnJheSIsInNoYXJwZW5MaW5lIiwibGluZSIsImxlZnQiLCJyaWdodCIsImRldGVybWluZU90c3VUaHJlc2hvbGQiLCJweCIsImVuZCIsIm14IiwiZGV0ZXJtaW5lVGhyZXNob2xkIiwidmV0IiwicDEiLCJwMiIsInAxMiIsIm0xIiwibTIiLCJtMTIiLCJrIiwib3RzdVRocmVzaG9sZCIsImNvbXB1dGVCaW5hcnlJbWFnZSIsImtlcm5lbCIsIkEiLCJCIiwiQyIsIkQiLCJhdmciLCJjbHVzdGVyIiwidGhpc0NsdXN0ZXIiLCJjbHVzdGVycyIsImFkZFRvQ2x1c3RlciIsImZvdW5kIiwiQ2x1c3RlcjIiLCJUcmFjZXIiLCJ0cmFjZSIsIml0ZXJhdGlvbiIsIm1heEl0ZXJhdGlvbnMiLCJ0b3AiLCJjZW50ZXJQb3MiLCJjdXJyZW50UG9zIiwiaWR4IiwiZm9yd2FyZCIsInRvIiwidG9JZHgiLCJwcmVkaWN0ZWRQb3MiLCJ0aHJlc2hvbGRYIiwidGhyZXNob2xkWSIsIm1hdGNoIiwicHJlZGljdGVkIiwiRElMQVRFIiwiRVJPREUiLCJkaWxhdGUiLCJpbkltYWdlV3JhcHBlciIsIm91dEltYWdlV3JhcHBlciIsImluSW1hZ2VEYXRhIiwib3V0SW1hZ2VEYXRhIiwieVN0YXJ0MSIsInlTdGFydDIiLCJ4U3RhcnQxIiwieFN0YXJ0MiIsImVyb2RlIiwiYUltYWdlV3JhcHBlciIsImJJbWFnZVdyYXBwZXIiLCJyZXN1bHRJbWFnZVdyYXBwZXIiLCJhSW1hZ2VEYXRhIiwiYkltYWdlRGF0YSIsImNJbWFnZURhdGEiLCJiaXR3aXNlT3IiLCJjb3VudE5vblplcm8iLCJ0b3BHZW5lcmljIiwibGlzdCIsIm1pbklkeCIsInNjb3JlIiwiaGl0IiwiaXRlbSIsIk51bWJlciIsIk1BWF9WQUxVRSIsImdyYXlBcnJheUZyb21JbWFnZSIsImh0bWxJbWFnZSIsIm9mZnNldFgiLCJhcnJheSIsImRyYXdJbWFnZSIsImN0eERhdGEiLCJjb21wdXRlR3JheSIsImdyYXlBcnJheUZyb21Db250ZXh0Iiwib2Zmc2V0IiwiZ3JheUFuZEhhbGZTYW1wbGVGcm9tQ2FudmFzRGF0YSIsImNhbnZhc0RhdGEiLCJvdXRBcnJheSIsInRvcFJvd0lkeCIsImJvdHRvbVJvd0lkeCIsImVuZElkeCIsIm91dFdpZHRoIiwib3V0SW1nSWR4IiwiaW5XaWR0aCIsImNvbmZpZyIsInNpbmdsZUNoYW5uZWwiLCJsb2FkSW1hZ2VBcnJheSIsInNyYyIsImNhbGxiYWNrIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiaW1nIiwiSW1hZ2UiLCJvbmxvYWQiLCJoYWxmU2FtcGxlIiwiaW5JbWdXcmFwcGVyIiwib3V0SW1nV3JhcHBlciIsImluSW1nIiwib3V0SW1nIiwiaCIsInMiLCJjIiwibSIsInIiLCJnIiwiYiIsIl9jb21wdXRlRGl2aXNvcnMiLCJsYXJnZURpdmlzb3JzIiwiZGl2aXNvcnMiLCJzcXJ0IiwidW5zaGlmdCIsImNvbmNhdCIsIl9jb21wdXRlSW50ZXJzZWN0aW9uIiwiYXJyMSIsImFycjIiLCJjYWxjdWxhdGVQYXRjaFNpemUiLCJwYXRjaFNpemUiLCJpbWdTaXplIiwiZGl2aXNvcnNYIiwiZGl2aXNvcnNZIiwid2lkZVNpZGUiLCJjb21tb24iLCJuck9mUGF0Y2hlc0xpc3QiLCJuck9mUGF0Y2hlc01hcCIsInNtYWxsIiwibWVkaXVtIiwibGFyZ2UiLCJuck9mUGF0Y2hlc0lkeCIsIm5yT2ZQYXRjaGVzIiwiZGVzaXJlZFBhdGNoU2l6ZSIsIm9wdGltYWxQYXRjaFNpemUiLCJmaW5kUGF0Y2hTaXplRm9yRGl2aXNvcnMiLCJfcGFyc2VDU1NEaW1lbnNpb25WYWx1ZXMiLCJkaW1lbnNpb24iLCJwYXJzZUZsb2F0IiwidW5pdCIsImluZGV4T2YiLCJfZGltZW5zaW9uc0NvbnZlcnRlcnMiLCJjb250ZXh0IiwiYm90dG9tIiwiY29tcHV0ZUltYWdlQXJlYSIsImlucHV0V2lkdGgiLCJpbnB1dEhlaWdodCIsImFyZWEiLCJwYXJzZWRBcmVhIiwia2V5cyIsInBhcnNlZCIsImNhbGN1bGF0ZWQiLCJzeCIsInN5Iiwic3ciLCJzaCIsInN1cGVyUHJvcEJhc2UiLCJfZ2V0IiwicmVjZWl2ZXIiLCJSZWZsZWN0IiwiYmFzZSIsImRlc2MiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJpc09iamVjdCIsInR5cGUiLCJpc0FycmF5IiwiQXJyYXkiLCJkcmF3UmVjdCIsInN0eWxlIiwic3Ryb2tlU3R5bGUiLCJjb2xvciIsImZpbGxTdHlsZSIsImxpbmVXaWR0aCIsImJlZ2luUGF0aCIsInN0cm9rZVJlY3QiLCJkcmF3UGF0aCIsInBhdGgiLCJkZWYiLCJtb3ZlVG8iLCJsaW5lVG8iLCJjbG9zZVBhdGgiLCJzdHJva2UiLCJjYW52YXNEYXRhUG9zIiwiaW1hZ2VEYXRhUG9zIiwiYmFzZU1lcmdlIiwiY3JlYXRlQXNzaWduZXIiLCJtZXJnZSIsIm9iamVjdCIsInNvdXJjZSIsInNyY0luZGV4IiwiZnJlZUdsb2JhbCIsImZyZWVTZWxmIiwicm9vdCIsIkZ1bmN0aW9uIiwiaXNPYmplY3RMaWtlIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJhc3luY0dlbmVyYXRvclN0ZXAiLCJnZW4iLCJyZXNvbHZlIiwicmVqZWN0IiwiX25leHQiLCJfdGhyb3ciLCJhcmciLCJpbmZvIiwiZXJyb3IiLCJkb25lIiwiUHJvbWlzZSIsInRoZW4iLCJfYXN5bmNUb0dlbmVyYXRvciIsImZuIiwiYXJncyIsImFyZ3VtZW50cyIsImVyciIsInVuZGVmaW5lZCIsInNlYXJjaERpcmVjdGlvbnMiLCJsYWJlbFdyYXBwZXIiLCJsYWJlbERhdGEiLCJlZGdlbGFiZWwiLCJjeSIsImRpciIsImN4IiwidmVydGV4MkQiLCJjb250b3VyVHJhY2luZyIsIkZ2IiwiQ3YiLCJQIiwibGRpciIsImdldFJhd1RhZyIsIm9iamVjdFRvU3RyaW5nIiwibnVsbFRhZyIsInVuZGVmaW5lZFRhZyIsInN5bVRvU3RyaW5nVGFnIiwidG9TdHJpbmdUYWciLCJiYXNlR2V0VGFnIiwiX2NvbmZpZyIsIl9jdXJyZW50SW1hZ2VXcmFwcGVyIiwiX3NrZWxJbWFnZVdyYXBwZXIiLCJfc3ViSW1hZ2VXcmFwcGVyIiwiX2xhYmVsSW1hZ2VXcmFwcGVyIiwiX3BhdGNoR3JpZCIsIl9wYXRjaExhYmVsR3JpZCIsIl9pbWFnZVRvUGF0Y2hHcmlkIiwiX2JpbmFyeUltYWdlV3JhcHBlciIsIl9wYXRjaFNpemUiLCJfY2FudmFzQ29udGFpbmVyIiwiYmluYXJ5IiwiZG9tIiwiX251bVBhdGNoZXMiLCJfaW5wdXRJbWFnZVdyYXBwZXIiLCJfc2tlbGV0b25pemVyIiwiaW5pdEJ1ZmZlcnMiLCJza2VsZXRvbkltYWdlRGF0YSIsIkFycmF5QnVmZmVyIiwic2tlbGV0b25pemVyIiwid2luZG93IiwiZ2xvYmFsIiwiaW5pdENhbnZhcyIsInVzZVdvcmtlciIsImNsYXNzTmFtZSIsIkVOViIsImJveEZyb21QYXRjaGVzIiwicGF0Y2hlcyIsIm92ZXJBdmciLCJwYXRjaCIsInRyYW5zTWF0IiwibWlueCIsIm1pbnkiLCJtYXh4IiwibWF4eSIsImJveCIsIm1hdDIiLCJiaW5hcml6ZUltYWdlIiwiemVyb0JvcmRlciIsImZpbmRQYXRjaGVzIiwibW9tZW50cyIsInBhdGNoZXNGb3VuZCIsInJhc3Rlcml6ZXIiLCJyYXN0ZXJSZXN1bHQiLCJza2VsZXRvbml6ZSIsIlJhc3Rlcml6ZXIiLCJyYXN0ZXJpemUiLCJjb3VudCIsImRlc2NyaWJlUGF0Y2giLCJmaW5kQmlnZ2VzdENvbm5lY3RlZEFyZWFzIiwibWF4TGFiZWwiLCJsYWJlbEhpc3QiLCJ0b3BMYWJlbHMiLCJtYXAiLCJzb3J0IiwiYSIsImZpbHRlciIsImVsIiwiZmluZEJveGVzIiwiYm94ZXMiLCJzaW1pbGFyTW9tZW50cyIsInRvcENsdXN0ZXIiLCJlIiwic3ViSW1hZ2VBc0NvcHkiLCJwYXRjaFBvcyIsImVsaWdpYmxlTW9tZW50cyIsIm1hdGNoaW5nTW9tZW50cyIsIm1pbkNvbXBvbmVudFdlaWdodCIsImluZGV4IiwicmFzdGVyaXplQW5ndWxhclNpbWlsYXJpdHkiLCJjdXJySWR4Iiwibm90WWV0UHJvY2Vzc2VkIiwiY3VycmVudElkeCIsImN1cnJlbnRQYXRjaCIsImlucHV0SW1hZ2VXcmFwcGVyIiwibG9jYXRlIiwiY2hlY2tJbWFnZUNvbnN0cmFpbnRzIiwiaW5wdXRTdHJlYW0iLCJnZXRXaWR0aCIsImdldEhlaWdodCIsInRoaXNIYWxmU2FtcGxlIiwiZ2V0Q29uZmlnIiwic2V0VG9wUmlnaHQiLCJzZXRDYW52YXNTaXplIiwic2V0V2lkdGgiLCJzZXRIZWlnaHQiLCJsaXN0Q2FjaGVDbGVhciIsImxpc3RDYWNoZURlbGV0ZSIsImxpc3RDYWNoZUdldCIsImxpc3RDYWNoZUhhcyIsImxpc3RDYWNoZVNldCIsIkxpc3RDYWNoZSIsImVudHJpZXMiLCJjbGVhciIsImVudHJ5IiwiaGFzIiwiZXEiLCJhc3NvY0luZGV4T2YiLCJvdGhlciIsImdldE5hdGl2ZSIsIm5hdGl2ZUNyZWF0ZSIsImlzS2V5YWJsZSIsImdldE1hcERhdGEiLCJfX2RhdGFfXyIsImJhc2VJc0FyZ3VtZW50cyIsIm9iamVjdFByb3RvIiwiaGFzT3duUHJvcGVydHkiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsImlzQXJndW1lbnRzIiwiTUFYX1NBRkVfSU5URUdFUiIsInJlSXNVaW50IiwiaXNJbmRleCIsInRlc3QiLCJpc0tleSIsInN0cmluZ1RvUGF0aCIsInRvU3RyaW5nIiwiY2FzdFBhdGgiLCJhcnJheVdpdGhIb2xlcyIsIml0ZXJhYmxlVG9BcnJheUxpbWl0IiwidW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkiLCJub25JdGVyYWJsZVJlc3QiLCJfc2xpY2VkVG9BcnJheSIsImFycmF5V2l0aG91dEhvbGVzIiwiaXRlcmFibGVUb0FycmF5Iiwibm9uSXRlcmFibGVTcHJlYWQiLCJfdG9Db25zdW1hYmxlQXJyYXkiLCJkZXRlcm1pbmFudCIsInRyYW5zcG9zZSIsImlkZW50aXR5IiwiYWRqb2ludCIsImludmVydCIsImZyb2IiLCJsZHUiLCJiYXNlSXNOYXRpdmUiLCJnZXRWYWx1ZSIsImFzeW5jVGFnIiwiZnVuY1RhZyIsImdlblRhZyIsInByb3h5VGFnIiwiaXNGdW5jdGlvbiIsInRhZyIsImJhc2VBc3NpZ25WYWx1ZSIsIndlYnBhY2tQb2x5ZmlsbCIsImRlcHJlY2F0ZSIsInBhdGhzIiwiY2hpbGRyZW4iLCJpc0xlbmd0aCIsImlzQXJyYXlMaWtlIiwiX3NldFByb3RvdHlwZU9mIiwic3ltYm9sVGFnIiwiaXNTeW1ib2wiLCJJTkZJTklUWSIsInRvS2V5IiwiTWFwIiwibWFwQ2FjaGVDbGVhciIsIm1hcENhY2hlRGVsZXRlIiwibWFwQ2FjaGVHZXQiLCJtYXBDYWNoZUhhcyIsIm1hcENhY2hlU2V0IiwiTWFwQ2FjaGUiLCJhc3NpZ25NZXJnZVZhbHVlIiwiZnVuYyIsIm92ZXJBcmciLCJnZXRQcm90b3R5cGUiLCJpc1Byb3RvdHlwZSIsIkN0b3IiLCJwcm90byIsInN0dWJGYWxzZSIsImZyZWVFeHBvcnRzIiwibm9kZVR5cGUiLCJmcmVlTW9kdWxlIiwibW9kdWxlRXhwb3J0cyIsIkJ1ZmZlciIsIm5hdGl2ZUlzQnVmZmVyIiwiaXNCdWZmZXIiLCJiYXNlSXNUeXBlZEFycmF5IiwiYmFzZVVuYXJ5Iiwibm9kZVV0aWwiLCJub2RlSXNUeXBlZEFycmF5IiwiaXNUeXBlZEFycmF5Iiwic2FmZUdldCIsImFzc2lnblZhbHVlIiwib2JqVmFsdWUiLCJhcnJheUxpa2VLZXlzIiwiYmFzZUtleXNJbiIsImtleXNJbiIsIm5hdGl2ZU1heCIsIm92ZXJSZXN0Iiwic3RhcnQiLCJ0cmFuc2Zvcm0iLCJvdGhlckFyZ3MiLCJiYXNlU2V0VG9TdHJpbmciLCJzaG9ydE91dCIsInNldFRvU3RyaW5nIiwiYXJyYXlMaWtlVG9BcnJheSIsIl91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSIsIm1pbkxlbiIsInNsaWNlIiwibmFtZSIsIl9hcnJheUxpa2VUb0FycmF5Iiwib3V0IiwiRmxvYXQzMkFycmF5IiwieiIsImFuZ2xlIiwidHJhbnNmb3JtUXVhdCIsInJvdGF0ZVgiLCJyb3RhdGVZIiwicm90YXRlWiIsImJhc2VQaWNrIiwiZmxhdFJlc3QiLCJwaWNrIiwiaXNOYXRpdmVGdW5jdGlvbiIsImNvbnN0cnVjdCIsIl93cmFwTmF0aXZlU3VwZXIiLCJDbGFzcyIsIl9jYWNoZSIsIldyYXBwZXIiLCJjcmVhdGVDb250b3VyMkQiLCJmaXJzdFZlcnRleCIsImluc2lkZUNvbnRvdXJzIiwibmV4dHBlZXIiLCJwcmV2cGVlciIsIkNPTlRPVVJfRElSIiwiQ1dfRElSIiwiQ0NXX0RJUiIsIlVOS05PV05fRElSIiwiRElSIiwiT1VUU0lERV9FREdFIiwiSU5TSURFX0VER0UiLCJ0cmFjZXIiLCJkZXB0aGxhYmVsIiwiYmMiLCJsYyIsImxhYmVsaW5kZXgiLCJjb2xvck1hcCIsInZlcnRleCIsImNjIiwic2MiLCJjb25uZWN0ZWRDb3VudCIsImRlYnVnIiwiZHJhd0NvbnRvdXIiLCJmaXJzdENvbnRvdXIiLCJwcSIsImlxIiwicSIsIlNrZWxldG9uaXplciIsInN0ZGxpYiIsImZvcmVpZ24iLCJidWZmZXIiLCJpbWFnZXMiLCJpbXVsIiwiaW5JbWFnZVB0ciIsIm91dEltYWdlUHRyIiwiYUltYWdlUHRyIiwiYkltYWdlUHRyIiwiaW1hZ2VQdHIiLCJtZW1jcHkiLCJzcmNJbWFnZVB0ciIsImRzdEltYWdlUHRyIiwic3ViSW1hZ2VQdHIiLCJlcm9kZWRJbWFnZVB0ciIsInRlbXBJbWFnZVB0ciIsInNrZWxJbWFnZVB0ciIsIkNWVXRpbHMiLCJOZGFycmF5IiwiSW50ZXJwMkQiLCJkMiIsIkZyYW1lR3JhYmJlciIsIl90aGF0IiwiX3ZpZGVvU2l6ZSIsImdldFJlYWxXaWR0aCIsImdldFJlYWxIZWlnaHQiLCJfY2FudmFzU2l6ZSIsImdldENhbnZhc1NpemUiLCJfc2l6ZSIsIl90b3BSaWdodCIsImdldFRvcFJpZ2h0IiwiX2RhdGEiLCJfZ3JheURhdGEiLCJfY2FudmFzRGF0YSIsIl9ncmF5SW1hZ2VBcnJheSIsIl9jYW52YXNJbWFnZUFycmF5IiwiX3RhcmdldEltYWdlQXJyYXkiLCJoaSIsImxvIiwiX3N0ZXBTaXplWCIsIl9zdGVwU2l6ZVkiLCJhdHRhY2hEYXRhIiwiZ2V0RGF0YSIsImdyYWIiLCJnZXRGcmFtZSIsInNjYWxlQW5kQ3JvcCIsInNoYXBlIiwiZ2V0U2l6ZSIsIlN0YWNrIiwiYmFzZUZvciIsImJhc2VNZXJnZURlZXAiLCJjdXN0b21pemVyIiwic3RhY2siLCJzcmNWYWx1ZSIsIm5ld1ZhbHVlIiwic3RhY2tDbGVhciIsInN0YWNrRGVsZXRlIiwic3RhY2tHZXQiLCJzdGFja0hhcyIsInN0YWNrU2V0IiwiYXJyYXlQcm90byIsInNwbGljZSIsImxhc3RJbmRleCIsInBvcCIsIkxBUkdFX0FSUkFZX1NJWkUiLCJwYWlycyIsImlzTWFza2VkIiwidG9Tb3VyY2UiLCJyZVJlZ0V4cENoYXIiLCJyZUlzSG9zdEN0b3IiLCJmdW5jUHJvdG8iLCJmdW5jVG9TdHJpbmciLCJyZUlzTmF0aXZlIiwiUmVnRXhwIiwicmVwbGFjZSIsInBhdHRlcm4iLCJuYXRpdmVPYmplY3RUb1N0cmluZyIsImlzT3duIiwidW5tYXNrZWQiLCJjb3JlSnNEYXRhIiwibWFza1NyY0tleSIsInVpZCIsImV4ZWMiLCJJRV9QUk9UTyIsIkhhc2giLCJoYXNoQ2xlYXIiLCJoYXNoRGVsZXRlIiwiaGFzaEdldCIsImhhc2hIYXMiLCJoYXNoU2V0IiwiSEFTSF9VTkRFRklORUQiLCJjcmVhdGVCYXNlRm9yIiwiZnJvbVJpZ2h0IiwiaXRlcmF0ZWUiLCJrZXlzRnVuYyIsIml0ZXJhYmxlIiwiY2xvbmVCdWZmZXIiLCJjbG9uZVR5cGVkQXJyYXkiLCJjb3B5QXJyYXkiLCJpbml0Q2xvbmVPYmplY3QiLCJpc0FycmF5TGlrZU9iamVjdCIsImlzUGxhaW5PYmplY3QiLCJ0b1BsYWluT2JqZWN0IiwibWVyZ2VGdW5jIiwic3RhY2tlZCIsImlzQ29tbW9uIiwiaXNBcnIiLCJpc0J1ZmYiLCJpc1R5cGVkIiwiYWxsb2NVbnNhZmUiLCJpc0RlZXAiLCJjbG9uZUFycmF5QnVmZmVyIiwidHlwZWRBcnJheSIsImJ5dGVPZmZzZXQiLCJhcnJheUJ1ZmZlciIsImJ5dGVMZW5ndGgiLCJiYXNlQ3JlYXRlIiwib2JqZWN0Q3JlYXRlIiwiYXJnc1RhZyIsIm9iamVjdFRhZyIsIm9iamVjdEN0b3JTdHJpbmciLCJhcnJheVRhZyIsImJvb2xUYWciLCJkYXRlVGFnIiwiZXJyb3JUYWciLCJtYXBUYWciLCJudW1iZXJUYWciLCJyZWdleHBUYWciLCJzZXRUYWciLCJzdHJpbmdUYWciLCJ3ZWFrTWFwVGFnIiwiYXJyYXlCdWZmZXJUYWciLCJkYXRhVmlld1RhZyIsImZsb2F0MzJUYWciLCJmbG9hdDY0VGFnIiwiaW50OFRhZyIsImludDE2VGFnIiwiaW50MzJUYWciLCJ1aW50OFRhZyIsInVpbnQ4Q2xhbXBlZFRhZyIsInVpbnQxNlRhZyIsInVpbnQzMlRhZyIsInR5cGVkQXJyYXlUYWdzIiwiZnJlZVByb2Nlc3MiLCJwcm9jZXNzIiwidHlwZXMiLCJiaW5kaW5nIiwiY29weU9iamVjdCIsImlzTmV3IiwiYmFzZVRpbWVzIiwiaW5oZXJpdGVkIiwiaXNBcmciLCJpc1R5cGUiLCJza2lwSW5kZXhlcyIsIlN0cmluZyIsIm5hdGl2ZUtleXNJbiIsImlzUHJvdG8iLCJiYXNlUmVzdCIsImlzSXRlcmF0ZWVDYWxsIiwiYXNzaWduZXIiLCJzb3VyY2VzIiwiZ3VhcmQiLCJ0aGlzQXJnIiwiY29uc3RhbnQiLCJzdHJpbmciLCJIT1RfQ09VTlQiLCJIT1RfU1BBTiIsIm5hdGl2ZU5vdyIsIkRhdGUiLCJub3ciLCJsYXN0Q2FsbGVkIiwic3RhbXAiLCJyZW1haW5pbmciLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJ3ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJtb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJvUmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwibXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJzZXRUaW1lb3V0IiwiYWgiLCJhbCIsImJoIiwiYmwiLCJhc3NpZ24iLCJuZXh0U291cmNlIiwibmV4dEtleSIsIl9hcnJheVdpdGhIb2xlcyIsIl9pdGVyYWJsZVRvQXJyYXlMaW1pdCIsIl9pIiwiX2FyciIsIl9uIiwiX2QiLCJfcyIsIl9lIiwiX25vbkl0ZXJhYmxlUmVzdCIsImEwIiwiYTEiLCJiMCIsImIxIiwidCIsImF4IiwiYXkiLCJzdHJpZGUiLCJtU3EiLCJ0ZW1wQSIsInRlbXBCIiwiY29zaW5lIiwiYWNvcyIsImEyIiwiYjIiLCJheiIsImJ4IiwiYnkiLCJieiIsInpTY2FsZSIsInciLCJxeCIsInF5IiwicXoiLCJxdyIsIml4IiwiaXkiLCJpeiIsIml3IiwicHkiLCJweiIsIl9hcnJheVdpdGhvdXRIb2xlcyIsIl9pdGVyYWJsZVRvQXJyYXkiLCJpdGVyIiwiX25vbkl0ZXJhYmxlU3ByZWFkIiwiX3N1cGVyUHJvcEJhc2UiLCJydW50aW1lIiwiT3AiLCJoYXNPd24iLCIkU3ltYm9sIiwiaXRlcmF0b3JTeW1ib2wiLCJhc3luY0l0ZXJhdG9yU3ltYm9sIiwiYXN5bmNJdGVyYXRvciIsInRvU3RyaW5nVGFnU3ltYm9sIiwid3JhcCIsImlubmVyRm4iLCJvdXRlckZuIiwidHJ5TG9jc0xpc3QiLCJwcm90b0dlbmVyYXRvciIsIkdlbmVyYXRvciIsImdlbmVyYXRvciIsIkNvbnRleHQiLCJfaW52b2tlIiwibWFrZUludm9rZU1ldGhvZCIsInRyeUNhdGNoIiwiR2VuU3RhdGVTdXNwZW5kZWRTdGFydCIsIkdlblN0YXRlU3VzcGVuZGVkWWllbGQiLCJHZW5TdGF0ZUV4ZWN1dGluZyIsIkdlblN0YXRlQ29tcGxldGVkIiwiQ29udGludWVTZW50aW5lbCIsIkdlbmVyYXRvckZ1bmN0aW9uIiwiR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUiLCJJdGVyYXRvclByb3RvdHlwZSIsImdldFByb3RvIiwiTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUiLCJ2YWx1ZXMiLCJHcCIsImRpc3BsYXlOYW1lIiwiZGVmaW5lSXRlcmF0b3JNZXRob2RzIiwibWV0aG9kIiwiaXNHZW5lcmF0b3JGdW5jdGlvbiIsImdlbkZ1biIsImN0b3IiLCJtYXJrIiwiYXdyYXAiLCJfX2F3YWl0IiwiQXN5bmNJdGVyYXRvciIsIlByb21pc2VJbXBsIiwiaW52b2tlIiwicmVjb3JkIiwidW53cmFwcGVkIiwicHJldmlvdXNQcm9taXNlIiwiZW5xdWV1ZSIsImNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnIiwiYXN5bmMiLCJzdGF0ZSIsImRvbmVSZXN1bHQiLCJkZWxlZ2F0ZSIsImRlbGVnYXRlUmVzdWx0IiwibWF5YmVJbnZva2VEZWxlZ2F0ZSIsInNlbnQiLCJfc2VudCIsImRpc3BhdGNoRXhjZXB0aW9uIiwiYWJydXB0IiwicmVzdWx0TmFtZSIsIm5leHRMb2MiLCJwdXNoVHJ5RW50cnkiLCJsb2NzIiwidHJ5TG9jIiwiY2F0Y2hMb2MiLCJmaW5hbGx5TG9jIiwiYWZ0ZXJMb2MiLCJ0cnlFbnRyaWVzIiwicmVzZXRUcnlFbnRyeSIsImNvbXBsZXRpb24iLCJyZXNldCIsInJldmVyc2UiLCJpdGVyYXRvck1ldGhvZCIsInNraXBUZW1wUmVzZXQiLCJjaGFyQXQiLCJzdG9wIiwicm9vdEVudHJ5Iiwicm9vdFJlY29yZCIsInJ2YWwiLCJleGNlcHRpb24iLCJoYW5kbGUiLCJsb2MiLCJjYXVnaHQiLCJoYXNDYXRjaCIsImhhc0ZpbmFsbHkiLCJmaW5hbGx5RW50cnkiLCJjb21wbGV0ZSIsImZpbmlzaCIsInRocm93biIsImRlbGVnYXRlWWllbGQiLCJyZWdlbmVyYXRvclJ1bnRpbWUiLCJhY2NpZGVudGFsU3RyaWN0TW9kZSIsImJhc2VQaWNrQnkiLCJoYXNJbiIsImJhc2VHZXQiLCJiYXNlU2V0IiwicHJlZGljYXRlIiwicmVJc0RlZXBQcm9wIiwicmVJc1BsYWluUHJvcCIsIm1lbW9pemVDYXBwZWQiLCJyZVByb3BOYW1lIiwicmVFc2NhcGVDaGFyIiwiY2hhckNvZGVBdCIsIm51bWJlciIsInF1b3RlIiwic3ViU3RyaW5nIiwibWVtb2l6ZSIsIk1BWF9NRU1PSVpFX1NJWkUiLCJjYWNoZSIsIkZVTkNfRVJST1JfVEVYVCIsInJlc29sdmVyIiwibWVtb2l6ZWQiLCJDYWNoZSIsImJhc2VUb1N0cmluZyIsImFycmF5TWFwIiwic3ltYm9sUHJvdG8iLCJzeW1ib2xUb1N0cmluZyIsIm5lc3RlZCIsImJhc2VIYXNJbiIsImhhc1BhdGgiLCJoYXNGdW5jIiwiZmxhdHRlbiIsImJhc2VGbGF0dGVuIiwiYXJyYXlQdXNoIiwiaXNGbGF0dGVuYWJsZSIsImRlcHRoIiwiaXNTdHJpY3QiLCJzcHJlYWRhYmxlU3ltYm9sIiwiaXNDb25jYXRTcHJlYWRhYmxlIiwiX2lzTmF0aXZlRnVuY3Rpb24iLCJpc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QiLCJfY29uc3RydWN0IiwiUGFyZW50IiwiYmluZCIsIl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QiLCJzaGFtIiwiUHJveHkiLCJCb29sZWFuIiwidmFsdWVPZiIsImEzIiwiYjMiLCJkZXQiLCJ2MCIsInYxIiwicG93IiwiTCIsIlUiLCJCcmVzZW5oYW0iLCJTbG9wZSIsIlVQIiwiRE9XTiIsImdldEJhcmNvZGVMaW5lIiwieDAiLCJ5MCIsIngxIiwieTEiLCJzdGVlcCIsInJlYWQiLCJkZWx0YVgiLCJkZWx0YVkiLCJ5U3RlcCIsInRvQmluYXJ5TGluZSIsInNsb3BlIiwic2xvcGUyIiwiZXh0cmVtYSIsImN1cnJlbnREaXIiLCJyVGhyZXNob2xkIiwicHJpbnRGcmVxdWVuY3kiLCJwcmludFBhdHRlcm4iLCJmaWxsQ29sb3IiLCJmaWxsUmVjdCIsIkJhcmNvZGVEaXJlY3Rpb24iLCJCYXJjb2RlUmVhZGVyIiwic3VwcGxlbWVudHMiLCJfcm93IiwiY291bnRlciIsImNvZGUiLCJtYXhTaW5nbGVFcnJvciIsInNpbmdsZUVycm9yIiwibW9kdWxvIiwiYmFyV2lkdGgiLCJzY2FsZWQiLCJTSU5HTEVfQ09ERV9FUlJPUiIsImNvcnJlY3Rpb24iLCJpbmRpY2VzIiwiZGVjb2RlIiwiZGlyZWN0aW9uIiwiUmV2ZXJzZSIsIkZvcndhcmQiLCJmb3JtYXQiLCJGT1JNQVQiLCJfbmV4dFVuc2V0IiwiaXNXaGl0ZSIsImNvdW50ZXJzIiwiY291bnRlclBvcyIsIm51bUNvdW50ZXJzIiwiU3RhcnROb3RGb3VuZEV4Y2VwdGlvbiIsIkNvZGVOb3RGb3VuZEV4Y2VwdGlvbiIsIlBhdHRlcm5Ob3RGb3VuZEV4Y2VwdGlvbiIsIkNvZGUxMjhSZWFkZXIiLCJiYXIiLCJzcGFjZSIsImJlc3RNYXRjaCIsIl9jb3JyZWN0IiwiQ09ERV9QQVRURVJOIiwiX21hdGNoUGF0dGVybiIsIkFWR19DT0RFX0VSUk9SIiwiY2FsY3VsYXRlQ29ycmVjdGlvbiIsIk1PRFVMRV9JTkRJQ0VTIiwiX2NvcnJlY3RCYXJzIiwiX25leHRTZXQiLCJTVEFSVF9DT0RFX0EiLCJTVEFSVF9DT0RFX0MiLCJzdGFydEluZm8iLCJfZmluZFN0YXJ0IiwiZGVjb2RlZENvZGVzIiwiY2hlY2tzdW0iLCJjb2Rlc2V0IiwiQ09ERV9BIiwiU1RBUlRfQ09ERV9CIiwiQ09ERV9CIiwiQ09ERV9DIiwic2hpZnROZXh0IiwicmVtb3ZlTGFzdENoYXJhY3RlciIsIm11bHRpcGxpZXIiLCJyYXdSZXN1bHQiLCJfZGVjb2RlQ29kZSIsIlNUT1BfQ09ERSIsImZyb21DaGFyQ29kZSIsIkNPREVfU0hJRlQiLCJfdmVyaWZ5VHJhaWxpbmdXaGl0ZXNwYWNlIiwiZW5kSW5mbyIsInRyYWlsaW5nV2hpdGVzcGFjZUVuZCIsIl9tYXRjaFJhbmdlIiwiZXhwZWN0ZWQiLCJub3JtYWxpemVkIiwic3VtTm9ybWFsaXplZCIsInN1bUV4cGVjdGVkIiwiQ09ERV9HX1NUQVJUIiwiU1RBUlRfUEFUVEVSTiIsIk1JRERMRV9QQVRURVJOIiwiRVhURU5TSU9OX1NUQVJUX1BBVFRFUk4iLCJDT0RFX0ZSRVFVRU5DWSIsIkVBTlJlYWRlciIsInRyeUhhcmRlciIsImZpbGwiLCJlcHNpbG9uIiwiY29kZXJhbmdlIiwiX2ZpbmRQYXR0ZXJuIiwibGVhZGluZ1doaXRlc3BhY2VTdGFydCIsImNvZGVGcmVxdWVuY3kiLCJpbkNvZGUiLCJvdXRDb2RlIiwiZmlyc3REaWdpdCIsIl9jYWxjdWxhdGVGaXJzdERpZ2l0IiwibWlkZGxlUGF0dGVybiIsIlNUT1BfUEFUVEVSTiIsImNvbnNvbGUiLCJyZXN1bHRJbmZvIiwiX2RlY29kZVBheWxvYWQiLCJfZmluZEVuZCIsIl9jaGVja3N1bSIsInN1cHBsZW1lbnQiLCJfZGVjb2RlRXh0ZW5zaW9ucyIsImxhc3RDb2RlIiwiQUxQSEFCRVRIX1NUUklORyIsIkFMUEhBQkVUIiwiVWludDE2QXJyYXkiLCJjaGFyIiwiQ0hBUkFDVEVSX0VOQ09ESU5HUyIsIkFTVEVSSVNLIiwiQ29kZTM5UmVhZGVyIiwicGF0dGVyblN0YXJ0IiwiX3RvUGF0dGVybiIsIndoaXRlU3BhY2VNdXN0U3RhcnQiLCJtYXhOYXJyb3dXaWR0aCIsIm51bVdpZGVCYXJzIiwid2lkZUJhcldpZHRoIiwiX2ZpbmROZXh0V2lkdGgiLCJtaW5XaWR0aCIsImxhc3RTdGFydCIsIm5leHRTdGFydCIsInBhdHRlcm5TaXplIiwiZGVjb2RlZENoYXIiLCJfdG9Db3VudGVycyIsIl9wYXR0ZXJuVG9DaGFyIiwicGF0dGVybnMiLCJJT1EiLCJBWjA5IiwiQ29kZTM5VklOUmVhZGVyIiwiX2NoZWNrQ2hlY2tzdW0iLCJTVEFSVF9FTkQiLCJNSU5fRU5DT0RFRF9DSEFSUyIsIk1BWF9BQ0NFUFRBQkxFIiwiUEFERElORyIsIk5ld0NvZGFiYXJSZWFkZXIiLCJfY291bnRlcnMiLCJiYXJUaHJlc2hvbGQiLCJfY29tcHV0ZUFsdGVybmF0aW5nVGhyZXNob2xkIiwic3BhY2VUaHJlc2hvbGQiLCJiaXRtYXNrIiwiX2lzU3RhcnRFbmQiLCJfc3VtQ291bnRlcnMiLCJzdGFydENvdW50ZXIiLCJlbmRDb3VudGVyIiwiX2NhbGN1bGF0ZVBhdHRlcm5MZW5ndGgiLCJjaGFyQ29kZSIsImNhdGVnb3JpemF0aW9uIiwibmFycm93IiwiY291bnRzIiwid2lkZSIsIl9jaGFyVG9QYXR0ZXJuIiwia2luZCIsImNhdCIsIm5ld2tpbmQiLCJ0aHJlc2hvbGRzIiwiX3RocmVzaG9sZFJlc3VsdFBhdHRlcm4iLCJfZmlsbENvdW50ZXJzIiwiX3ZlcmlmeVdoaXRlc3BhY2UiLCJfdmFsaWRhdGVSZXN1bHQiLCJVUENSZWFkZXIiLCJzdWJzdHJpbmciLCJFQU44UmVhZGVyIiwiRUFOMlJlYWRlciIsInBhcnNlSW50IiwiQ0hFQ0tfRElHSVRfRU5DT0RJTkdTIiwiZGV0ZXJtaW5lQ2hlY2tEaWdpdCIsImV4dGVuc2lvbkNoZWNrc3VtIiwiRUFONVJlYWRlciIsIlVQQ0VSZWFkZXIiLCJfZGV0ZXJtaW5lUGFyaXR5IiwibnJTeXN0ZW0iLCJ1cGNhIiwibGFzdERpZ2l0IiwiX2NvbnZlcnRUb1VQQ0EiLCJOIiwiVyIsIkkyb2Y1UmVhZGVyIiwib3B0cyIsIm5vcm1hbGl6ZUJhclNwYWNlV2lkdGgiLCJjb3VudGVyU3VtIiwiY29kZVN1bSIsImNvcnJlY3Rpb25SYXRpbyIsIk1BWF9DT1JSRUNUSU9OX0ZBQ1RPUiIsImNvcnJlY3Rpb25SYXRpb0ludmVyc2UiLCJiYXJTcGFjZVJhdGlvIiwibmFycm93QmFyV2lkdGgiLCJjb3VudGVyUGFpciIsImNvZGVzIiwiY291bnRlckxlbmd0aCIsIl9kZWNvZGVQYWlyIiwiX3ZlcmlmeUNvdW50ZXJMZW5ndGgiLCJTVEFSVF9QQVRURVJOX0xFTkdUSCIsIlR3b09mRml2ZVJlYWRlciIsIkNvZGU5M1JlYWRlciIsImNoYXJBcnJheSIsIm5leHRDaGFyIiwibmV4dENoYXJDb2RlIiwid2FybiIsIm1heFdlaWdodCIsImFycmF5VG9DaGVjayIsIndlaWdodGVkU3VtcyIsIndlaWdodCIsImNoZWNrQ2hhciIsIl9tYXRjaENoZWNrQ2hhciIsIl92ZXJpZnlFbmQiLCJfdmVyaWZ5Q2hlY2tzdW1zIiwiX2RlY29kZUV4dGVuZGVkIiwiQUVJTyIsImNvZGUzMnNldCIsIkNvZGUzMlJlYWRlciIsInJlcyIsImNvZGUzMiIsIl9kZWNvZGVDb2RlMzIiLCJSRUFERVJTIiwiY29kZV8xMjhfcmVhZGVyIiwiZWFuX3JlYWRlciIsImVhbl81X3JlYWRlciIsImVhbl8yX3JlYWRlciIsImVhbl84X3JlYWRlciIsImNvZGVfMzlfcmVhZGVyIiwiY29kZV8zOV92aW5fcmVhZGVyIiwiY29kYWJhcl9yZWFkZXIiLCJDb2RhYmFyUmVhZGVyIiwidXBjX3JlYWRlciIsInVwY19lX3JlYWRlciIsImkyb2Y1X3JlYWRlciIsImNvZGVfOTNfcmVhZGVyIiwiY29kZV8zMl9yZWFkZXIiLCJyZWdpc3RlclJlYWRlciIsInJlYWRlciIsIl9jYW52YXMiLCJmcmVxdWVuY3kiLCJvdmVybGF5IiwiX2JhcmNvZGVSZWFkZXJzIiwiaW5pdFJlYWRlcnMiLCJpbml0Q29uZmlnIiwicmVhZGVycyIsInJlYWRlckNvbmZpZyIsImNvbmZpZ3VyYXRpb24iLCJyZWFkZXJPYmoiLCJnZXRFeHRlbmRlZExpbmUiLCJleHQiLCJleHRlbmRMaW5lIiwiYW1vdW50IiwiZXh0ZW5zaW9uIiwiaW5JbWFnZVdpdGhCb3JkZXIiLCJnZXRMaW5lIiwidHJ5RGVjb2RlIiwiYmFyY29kZUxpbmUiLCJkZWNvZGVQYXR0ZXJuIiwiY29kZVJlc3VsdCIsInRyeURlY29kZUJydXRlRm9yY2UiLCJsaW5lQW5nbGUiLCJzaWRlTGVuZ3RoIiwic2xpY2VzIiwieGRpciIsInlkaXIiLCJnZXRMaW5lTGVuZ3RoIiwiZGVjb2RlRnJvbUltYWdlIiwiZGVjb2RlSW1hZ2UiLCJkZWNvZGVGcm9tQm91bmRpbmdCb3giLCJsaW5lTGVuZ3RoIiwiYXRhbjIiLCJkZWNvZGVGcm9tQm91bmRpbmdCb3hlcyIsImJhcmNvZGVzIiwibXVsdGlwbGUiLCJzZXRSZWFkZXJzIiwiRXZlbnRJbnRlcmZhY2UiLCJldmVudHMiLCJnZXRFdmVudCIsImV2ZW50TmFtZSIsInN1YnNjcmliZXJzIiwiY2xlYXJFdmVudHMiLCJwdWJsaXNoU3Vic2NyaXB0aW9uIiwic3Vic2NyaXB0aW9uIiwiX3N1YnNjcmliZSIsImV2ZW50Iiwic3Vic2NyaWJlIiwicHVibGlzaCIsInN1YnNjcmliZXIiLCJvbmNlIiwidW5zdWJzY3JpYmUiLCJFeGNlcHRpb24iLCJFUlJPUl9ERVNDIiwiZW51bWVyYXRlRGV2aWNlcyIsIm5hdmlnYXRvciIsIm1lZGlhRGV2aWNlcyIsImdldFVzZXJNZWRpYSIsImNvbnN0cmFpbnRzIiwic3RyZWFtUmVmIiwid2FpdEZvclZpZGVvIiwidmlkZW8iLCJhdHRlbXB0cyIsImNoZWNrVmlkZW8iLCJ2aWRlb1dpZHRoIiwidmlkZW9IZWlnaHQiLCJpbml0Q2FtZXJhIiwic3RyZWFtIiwic2V0QXR0cmlidXRlIiwic3JjT2JqZWN0IiwiYWRkRXZlbnRMaXN0ZW5lciIsInBsYXkiLCJkZXByZWNhdGVkQ29uc3RyYWludHMiLCJ2aWRlb0NvbnN0cmFpbnRzIiwibWluQXNwZWN0UmF0aW8iLCJhc3BlY3RSYXRpbyIsImxvZyIsImZhY2luZyIsImZhY2luZ01vZGUiLCJwaWNrQ29uc3RyYWludHMiLCJkZXZpY2VJZCIsImF1ZGlvIiwiZW51bWVyYXRlVmlkZW9EZXZpY2VzIiwiZGV2aWNlcyIsImRldmljZSIsImdldEFjdGl2ZVRyYWNrIiwidHJhY2tzIiwiZ2V0VmlkZW9UcmFja3MiLCJRdWFnZ2FKU0NhbWVyYUFjY2VzcyIsInJlcXVlc3RlZFZpZGVvRWxlbWVudCIsInJlcXVlc3QiLCJuZXdDb25zdHJhaW50cyIsInJlbGVhc2UiLCJwYXVzZSIsImdldEFjdGl2ZVN0cmVhbUxhYmVsIiwidHJhY2siLCJjb250YWlucyIsInNvbWUiLCJldmVyeSIsInBhc3Nlc0ZpbHRlciIsInJlc3VsdHMiLCJjYXBhY2l0eSIsImNhcHR1cmUiLCJtYXRjaGVzQ29uc3RyYWludHMiLCJibGFja2xpc3QiLCJhZGRSZXN1bHQiLCJpbWFnZVNpemUiLCJJbWFnZURlYnVnIiwidG9EYXRhVVJMIiwiZ2V0UmVzdWx0cyIsIkRldkNvbmZpZyIsIm51bU9mV29ya2VycyIsImRlY29kZXIiLCJkcmF3Qm91bmRpbmdCb3giLCJzaG93RnJlcXVlbmN5IiwiZHJhd1NjYW5saW5lIiwic2hvd1BhdHRlcm4iLCJsb2NhdG9yIiwic2hvd0NhbnZhcyIsInNob3dQYXRjaGVzIiwic2hvd0ZvdW5kUGF0Y2hlcyIsInNob3dTa2VsZXRvbiIsInNob3dMYWJlbHMiLCJzaG93UGF0Y2hMYWJlbHMiLCJzaG93UmVtYWluaW5nUGF0Y2hMYWJlbHMiLCJzaG93VHJhbnNmb3JtZWQiLCJzaG93VHJhbnNmb3JtZWRCb3giLCJzaG93QkIiLCJOb2RlQ29uZmlnIiwic2VxdWVuY2UiLCJQcm9kQ29uZmlnIiwiUXVhZ2dhQ29uZmlnIiwiUXVhZ2dhQ29udGV4dCIsIkNhbnZhc0NvbnRhaW5lciIsIkNhbnZhc0luZm8iLCJib3hTaXplIiwiQmFyY29kZUxvY2F0b3IiLCJnZXRWaWV3UG9ydCIsIkhUTUxFbGVtZW50Iiwibm9kZU5hbWUiLCJzZWxlY3RvciIsInF1ZXJ5U2VsZWN0b3IiLCJmaW5kT3JDcmVhdGVDYW52YXMiLCJnZXRDYW52YXNBbmRDb250ZXh0IiwiaW5pdENhbnZhc2VzIiwiY2FudmFzU2l6ZSIsImltYWdlIiwidmlld3BvcnQiLCJjb250YWluZXIiLCJhcHBlbmRDaGlsZCIsImlucHV0U3RyZWFtRmFjdG9yeSIsImNyZWF0ZVZpZGVvU3RyZWFtIiwiY3JlYXRlTGl2ZVN0cmVhbSIsImNyZWF0ZUltYWdlU3RyZWFtIiwibG9hZGVkIiwiYmFzZVVybCIsImVuZGVkIiwiY2FsY3VsYXRlZFdpZHRoIiwiY2FsY3VsYXRlZEhlaWdodCIsIl9ldmVudE5hbWVzIiwiX2V2ZW50SGFuZGxlcnMiLCJmcmFtZUlkeCIsInBhdXNlZCIsImxvYWRJbWFnZXMiLCJHZXRQaXhlbHMiLCJtaW1lIiwicGl4ZWxzIiwicHVibGlzaEV2ZW50IiwiaGFuZGxlcnMiLCJ0cmlnZ2VyIiwic2V0SW5wdXRTdHJlYW0iLCJzZXRDdXJyZW50VGltZSIsInRpbWUiLCJmIiwiY2xlYXJFdmVudEhhbmRsZXJzIiwiaW5kIiwidG9wUmlnaHQiLCJzeiIsIndvcmtlclBvb2wiLCJ1cGRhdGVXb3JrZXJzIiwiZnJhbWVHcmFiYmVyIiwiYXZhaWxhYmxlV29ya2VyIiwid29ya2VyVGhyZWFkIiwiYnVzeSIsIndvcmtlciIsInBvc3RNZXNzYWdlIiwiY21kIiwiY29uZmlnRm9yV29ya2VyIiwid29ya2VySW50ZXJmYWNlIiwiZmFjdG9yeSIsIlF1YWdnYSIsIm1lc3NhZ2UiLCJvblByb2Nlc3NlZCIsIndvcmtlckludGVyZmFjZVJlYWR5Iiwib25tZXNzYWdlIiwiZ2VuZXJhdGVXb3JrZXJCbG9iIiwiYmxvYiIsImZhY3RvcnlTb3VyY2UiLCJfX2ZhY3RvcnlTb3VyY2VfXyIsIkJsb2IiLCJVUkwiLCJjcmVhdGVPYmplY3RVUkwiLCJpbml0V29ya2VyIiwiY2IiLCJibG9iVVJMIiwiV29ya2VyIiwicmV2b2tlT2JqZWN0VVJMIiwiYWRqdXN0V29ya2VyUG9vbCIsImluY3JlYXNlQnkiLCJ3b3JrZXJzVG9UZXJtaW5hdGUiLCJ0ZXJtaW5hdGUiLCJ3b3JrZXJJbml0aWFsaXplZCIsInNldHVwSW5wdXRTdHJlYW0iLCJJbnB1dFN0cmVhbSIsIm1vdmVCb3giLCJ4T2Zmc2V0IiwieU9mZnNldCIsImNvcm5lciIsIm1vdmVMaW5lIiwiZnJhbWVncmFiYmVyIiwiY2FudmFzQ29udGFpbmVyIiwiUVdvcmtlcnMiLCJpbml0aWFsaXplRGF0YSIsInJlYWR5Iiwib25VSVRocmVhZCIsIndvcmtlcnNVcGRhdGVkIiwibG9jYXRlQW5kRGVjb2RlIiwiX2luaXRCdWZmZXJzIiwiQmFyY29kZURlY29kZXIiLCJfZ2V0Vmlld1BvcnQiLCJfaW5pdENhbnZhcyIsImlucHV0VHlwZSIsIkNhbWVyYUFjY2VzcyIsImNhblJlY29yZCIsImJhcmNvZGUiLCJ0cmFuc2Zvcm1SZXN1bHQiLCJyZXN1bHRDb2xsZWN0b3IiLCJyZXN1bHRUb1B1Ymxpc2giLCJFdmVudHMiLCJoYXNDb2RlUmVzdWx0IiwiZ2V0Qm91bmRpbmdCb3hlcyIsImRlY29kZVJlc3VsdCIsInB1Ymxpc2hSZXN1bHQiLCJpbWFnZVJlc3VsdCIsImRlbGF5Iiwic3RvcHBlZCIsInRpbWVzdGFtcCIsInVwZGF0ZSIsInBlcmZvcm1hbmNlIiwic3RhcnRDb250aW51b3VzVXBkYXRlIiwiX2NvbnRleHQiLCJRdWFnZ2FKU1N0YXRpY0ludGVyZmFjZSIsInF1YWdnYUluc3RhbmNlIiwicHJvbWlzZSIsIkNvbmZpZyIsImluaXRJbnB1dFN0cmVhbSIsIm9uRGV0ZWN0ZWQiLCJvZmZEZXRlY3RlZCIsIm9mZlByb2Nlc3NlZCIsInJlZ2lzdGVyUmVzdWx0Q29sbGVjdG9yIiwiZGVjb2RlU2luZ2xlIiwicmVzdWx0Q2FsbGJhY2siLCJkZWZhdWx0IiwiUmVhZGVycyIsIlJlc3VsdENvbGxlY3RvciJdLCJtYXBwaW5ncyI6IjtRQUFBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBOzs7UUFHQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0EsMENBQTBDLGdDQUFnQztRQUMxRTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBLHdEQUF3RCxrQkFBa0I7UUFDMUU7UUFDQSxpREFBaUQsY0FBYztRQUMvRDs7UUFFQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0EseUNBQXlDLGlDQUFpQztRQUMxRSxnSEFBZ0gsbUJBQW1CLEVBQUU7UUFDckk7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQSwyQkFBMkIsMEJBQTBCLEVBQUU7UUFDdkQsaUNBQWlDLGVBQWU7UUFDaEQ7UUFDQTtRQUNBOztRQUVBO1FBQ0Esc0RBQXNELCtEQUErRDs7UUFFckg7UUFDQTs7O1FBR0E7UUFDQTs7Ozs7OztBQ2xGQSxTQUFTQSxlQUFULENBQXlCQyxHQUF6QixFQUE4QkMsR0FBOUIsRUFBbUNDLEtBQW5DLEVBQTBDO0FBQ3hDLE1BQUlELEdBQUcsSUFBSUQsR0FBWCxFQUFnQjtBQUNkRyxVQUFNLENBQUNDLGNBQVAsQ0FBc0JKLEdBQXRCLEVBQTJCQyxHQUEzQixFQUFnQztBQUM5QkMsV0FBSyxFQUFFQSxLQUR1QjtBQUU5QkcsZ0JBQVUs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OytFQUNBLEc7O3FGQUNNLEc7O3FGQUNBLEc7O3FGQUNBLEc7O2tGQUNILEc7O3FGQUNHLENBQ1AsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxDQUFWLEVBQWEsQ0FBYixFQUFnQixDQUFoQixDQURPLEVBRVAsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxDQUFWLEVBQWEsQ0FBYixFQUFnQixDQUFoQixDQUZPLEVBR1AsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxDQUFWLEVBQWEsQ0FBYixFQUFnQixDQUFoQixDQUhPLEVBSVAsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxDQUFWLEVBQWEsQ0FBYixFQUFnQixDQUFoQixDQUpPLEVBS1AsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxDQUFWLEVBQWEsQ0FBYixFQUFnQixDQUFoQixDQUxPLEVBTVAsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxDQUFWLEVBQWEsQ0FBYixFQUFnQixDQUFoQixDQU5PLEVBT1AsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxDQUFWLEVBQWEsQ0FBYixFQUFnQixDQUFoQixDQVBPLEVBUVAsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxDQUFWLEVBQWEsQ0FBYixFQUFnQixDQUFoQixDQVJPLEVBU1AsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxDQUFWLEVBQWEsQ0FBYixFQUFnQixDQUFoQixDQVRPLEVBVVAsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxDQUFWLEVBQWEsQ0FBYixFQUFnQixDQUFoQixDQVZPLEVBV1AsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxDQUFWLEVBQWEsQ0FBYixFQUFnQixDQUFoQixDQVhPLEVBWVAsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxDQUFWLEVBQWEsQ0FBYixF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QUFjLENBQUNuNkIsS0FBZjtBQUNILFNBVEQsRUFTRyxJQVRILEVBU1NtNkIsY0FUVDtBQVVILE9BWEQsQ0FXRSxPQUFPcm5DLEdBQVAsRUFBWTtBQUNWYixjQUFNLENBQUNhLEdBQUQsQ0FBTjtBQUNIO0FBQ0osS0FmTSxDQUFQO0FBZ0JILEdBeEgyQjs7QUF5SDVCO0FBQ0E7QUFDQSxNQUFJK25DLE9BQUosR0FBYztBQUNWLFdBQU9YLHVCQUFQO0FBQ0gsR0E3SDJCOztBQThINUJZLFNBQU8sRUFBUEEsc0JBOUg0QjtBQStINUIvQixjQUFZLEVBQVpBLGFBL0g0QjtBQWdJNUI3SCxZQUFVLEVBQVZBLDhCQWhJNEI7QUFpSTVCMXlDLGNBQVksRUFBWkEsZ0NBakk0QjtBQWtJNUJ1OEMsaUJBQWUsRUFBZkEsZ0JBQWVBO0FBbElhLENBQWhDO0FBcUllYixtR0FBZixFLENBQ0EiLCJmaWxlIjoicXVhZ2dhLmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZ2V0dGVyIH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4gXHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuIFx0XHR9XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gXHR9O1xuXG4gXHQvLyBjcmVhdGUgYSBmYWtlIG5hbWVzcGFjZSBvYmplY3RcbiBcdC8vIG1vZGUgJiAxOiB2YWx1ZSBpcyBhIG1vZHVsZSBpZCwgcmVxdWlyZSBpdFxuIFx0Ly8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXG4gXHQvLyBtb2RlICYgNDogcmV0dXJuIHZhbHVlIHdoZW4gYWxyZWFkeSBucyBvYmplY3RcbiBcdC8vIG1vZGUgJiA4fDE6IGJlaGF2ZSBsaWtlIHJlcXVpcmVcbiBcdF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XG4gXHRcdGlmKG1vZGUgJiAxKSB2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpO1xuIFx0XHRpZihtb2RlICYgOCkgcmV0dXJuIHZhbHVlO1xuIFx0XHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xuIFx0XHR2YXIgbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIobnMpO1xuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XG4gXHRcdGlmKG1vZGUgJiAyICYmIHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykgZm9yKHZhciBrZXkgaW4gdmFsdWUpIF9fd2VicGFja19yZXF1aXJlX18uZChucywga2V5LCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHZhbHVlW2tleV07IH0uYmluZChudWxsLCBrZXkpKTtcbiBcdFx0cmV0dXJuIG5zO1xuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCIvXCI7XG5cblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSA5MSk7XG4iLCJmdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmaW5lUHJvcGVydHk7XG5tb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7IiwiZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gIH1cblxuICByZXR1cm4gc2VsZjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfYXNzZXJ0VGhpc0luaXRpYWxpemVkO1xubW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlOyIsImZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pO1xuICB9O1xuICBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG4gIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2dldFByb3RvdHlwZU9mO1xubW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlOyIsImZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2NsYXNzQ2FsbENoZWNrO1xubW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlOyIsImZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfY3JlYXRlQ2xhc3M7XG5tb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7IiwidmFyIF90eXBlb2YgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy90eXBlb2ZcIilbXCJkZWZhdWx0XCJdO1xuXG52YXIgYXNzZXJ0VGhpc0luaXRpYWxpemVkID0gcmVxdWlyZShcIi4vYXNzZXJ0VGhpc0luaXRpYWxpemVkLmpzXCIpO1xuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7XG4gIGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgcmV0dXJuIGNhbGw7XG4gIH0gZWxzZSBpZiAoY2FsbCAhPT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkXCIpO1xuICB9XG5cbiAgcmV0dXJuIGFzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjtcbm1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsiLCJ2YXIgc2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKFwiLi9zZXRQcm90b3R5cGVPZi5qc1wiKTtcblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gIH1cblxuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9XG4gIH0pO1xuICBpZiAoc3VwZXJDbGFzcykgc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9pbmhlcml0cztcbm1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsiLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgRVBTSUxPTjogcmVxdWlyZSgnLi9lcHNpbG9uJylcbiAgLCBjcmVhdGU6IHJlcXVpcmUoJy4vY3JlYXRlJylcbiAgLCBjbG9uZTogcmVxdWlyZSgnLi9jbG9uZScpXG4gICwgZnJvbVZhbHVlczogcmVxdWlyZSgnLi9mcm9tVmFsdWVzJylcbiAgLCBjb3B5OiByZXF1aXJlKCcuL2NvcHknKVxuICAsIHNldDogcmVxdWlyZSgnLi9zZXQnKVxuICAsIGVxdWFsczogcmVxdWlyZSgnLi9lcXVhbHMnKVxuICAsIGV4YWN0RXF1YWxzOiByZXF1aXJlKCcuL2V4YWN0RXF1YWxzJylcbiAgLCBhZGQ6IHJlcXVpcmUoJy4vYWRkJylcbiAgLCBzdWJ0cmFjdDogcmVxdWlyZSgnLi9zdWJ0cmFjdCcpXG4gICwgc3ViOiByZXF1aXJlKCcuL3N1YicpXG4gICwgbXVsdGlwbHk6IHJlcXVpcmUoJy4vbXVsdGlwbHknKVxuICAsIG11bDogcmVxdWlyZSgnLi9tdWwnKVxuICAsIGRpdmlkZTogcmVxdWlyZSgnLi9kaXZpZGUnKVxuICAsIGRpdjogcmVxdWlyZSgnLi9kaXYnKVxuICAsIGludmVyc2U6IHJlcXVpcmUoJy4vaW52ZXJzZScpXG4gICwgbWluOiByZXF1aXJlKCcuL21pbicpXG4gICwgbWF4OiByZXF1aXJlKCcuL21heCcpXG4gICwgcm90YXRlOiByZXF1aXJlKCcuL3JvdGF0ZScpXG4gICwgZmxvb3I6IHJlcXVpcmUoJy4vZmxvb3InKVxuICAsIGNlaWw6IHJlcXVpcmUoJy4vY2VpbCcpXG4gICwgcm91bmQ6IHJlcXVpcmUoJy4vcm91bmQnKVxuICAsIHNjYWxlOiByZXF1aXJlKCcuL3NjYWxlJylcbiAgLCBzY2FsZUFuZEFkZDogcmVxdWlyZSgnLi9zY2FsZUFuZEFkZCcpXG4gICwgZGlzdGFuY2U6IHJlcXVpcmUoJy4vZGlzdGFuY2UnKVxuICAsIGRpc3Q6IHJlcXVpcmUoJy4vZGlzdCcpXG4gICwgc3F1YXJlZERpc3RhbmNlOiByZXF1aXJlKCcuL3NxdWFyZWREaXN0YW5jZScpXG4gICwgc3FyRGlzdDogcmVxdWlyZSgnLi9zcXJEaXN0JylcbiAgLCBsZW5ndGg6IHJlcXVpcmUoJy4vbGVuZ3RoJylcbiAgLCBsZW46IHJlcXVpcmUoJy4vbGVuJylcbiAgLCBzcXVhcmVkTGVuZ3RoOiByZXF1aXJlKCcuL3NxdWFyZWRMZW5ndGgnKVxuICAsIHNxckxlbjogcmVxdWlyZSgnLi9zcXJMZW4nKVxuICAsIG5lZ2F0ZTogcmVxdWlyZSgnLi9uZWdhdGUnKVxuICAsIG5vcm1hbGl6ZTogcmVxdWlyZSgnLi9ub3JtYWxpemUnKVxuICAsIGRvdDogcmVxdWlyZSgnLi9kb3QnKVxuICAsIGNyb3NzOiByZXF1aXJlKCcuL2Nyb3NzJylcbiAgLCBsZXJwOiByZXF1aXJlKCcuL2xlcnAnKVxuICAsIHJhbmRvbTogcmVxdWlyZSgnLi9yYW5kb20nKVxuICAsIHRyYW5zZm9ybU1hdDI6IHJlcXVpcmUoJy4vdHJhbnNmb3JtTWF0MicpXG4gICwgdHJhbnNmb3JtTWF0MmQ6IHJlcXVpcmUoJy4vdHJhbnNmb3JtTWF0MmQnKVxuICAsIHRyYW5zZm9ybU1hdDM6IHJlcXVpcmUoJy4vdHJhbnNmb3JtTWF0MycpXG4gICwgdHJhbnNmb3JtTWF0NDogcmVxdWlyZSgnLi90cmFuc2Zvcm1NYXQ0JylcbiAgLCBmb3JFYWNoOiByZXF1aXJlKCcuL2ZvckVhY2gnKVxuICAsIGxpbWl0OiByZXF1aXJlKCcuL2xpbWl0Jylcbn1cbiIsImltcG9ydCB7IFR5cGVkQXJyYXkgfSBmcm9tIFwiLi4vLi4vdHlwZS1kZWZpbml0aW9ucy9xdWFnZ2FcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICAgIGluaXQ6IGZ1bmN0aW9uKGFycjogVHlwZWRBcnJheSB8IEFycmF5PGFueT4sIHZhbDogYW55KSB7XHJcbiAgICAgICAgLy8gYXJyLmZpbGwodmFsKTtcclxuICAgICAgICBsZXQgbCA9IGFyci5sZW5ndGg7XHJcbiAgICAgICAgd2hpbGUgKGwtLSkge1xyXG4gICAgICAgICAgICBhcnJbbF0gPSB2YWw7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNodWZmbGVzIHRoZSBjb250ZW50IG9mIGFuIGFycmF5XHJcbiAgICAgKi9cclxuICAgIHNodWZmbGU6IGZ1bmN0aW9uKGFycjogQXJyYXk8bnVtYmVyPikge1xyXG4gICAgICAgIGxldCBpID0gYXJyLmxlbmd0aCAtIDE7XHJcbiAgICAgICAgZm9yIChpOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgICBjb25zdCBqID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogaSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHggPSBhcnJbaV07XHJcbiAgICAgICAgICAgIGFycltpXSA9IGFycltqXTtcclxuICAgICAgICAgICAgYXJyW2pdID0geDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGFycjtcclxuICAgIH0sXHJcblxyXG4gICAgdG9Qb2ludExpc3Q6IGZ1bmN0aW9uKGFycjogQXJyYXk8QXJyYXk8bnVtYmVyPj4pIHtcclxuICAgICAgICBjb25zdCByb3dzID0gYXJyLnJlZHVjZSgocCwgbikgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCByb3cgPSBgWyR7bi5qb2luKCcsJyl9XWA7XHJcbiAgICAgICAgICAgIHAucHVzaChyb3cpO1xyXG4gICAgICAgICAgICByZXR1cm4gcDtcclxuICAgICAgICB9LCBbXSBhcyBBcnJheTxzdHJpbmc+KTtcclxuICAgICAgICByZXR1cm4gYFske3Jvd3Muam9pbignLFxcclxcbicpfV1gO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIHJldHVybnMgdGhlIGVsZW1lbnRzIHdoaWNoJ3Mgc2NvcmUgaXMgYmlnZ2VyIHRoYW4gdGhlIHRocmVzaG9sZFxyXG4gICAgICovXHJcbiAgICB0aHJlc2hvbGQ6IGZ1bmN0aW9uKGFycjogQXJyYXk8bnVtYmVyPiwgdGhyZXNob2xkOiBudW1iZXIsIHNjb3JlRnVuYzogKChzY29yZTogbnVtYmVyKSA9PiBudW1iZXIpKSB7XHJcbiAgICAgICAgY29uc3QgcXVldWUgPSBhcnIucmVkdWNlKChwcmV2OiBBcnJheTxudW1iZXI+LCBuZXh0KSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChzY29yZUZ1bmMuYXBwbHkoYXJyLCBbbmV4dF0pID49IHRocmVzaG9sZCkge1xyXG4gICAgICAgICAgICAgICAgcHJldi5wdXNoKG5leHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBwcmV2O1xyXG4gICAgICAgIH0sIFtdKTtcclxuICAgICAgICByZXR1cm4gcXVldWU7XHJcbiAgICB9LFxyXG5cclxuICAgIG1heEluZGV4OiBmdW5jdGlvbihhcnI6IEFycmF5PGFueT4pIHtcclxuICAgICAgICBsZXQgbWF4ID0gMDtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoYXJyW2ldID4gYXJyW21heF0pIHtcclxuICAgICAgICAgICAgICAgIG1heCA9IGk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG1heDtcclxuICAgIH0sXHJcblxyXG4gICAgbWF4OiBmdW5jdGlvbihhcnI6IEFycmF5PGFueT4pIHtcclxuICAgICAgICBsZXQgbWF4ID0gMDtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoYXJyW2ldID4gbWF4KSB7XHJcbiAgICAgICAgICAgICAgICBtYXggPSBhcnJbaV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG1heDtcclxuICAgIH0sXHJcblxyXG4gICAgc3VtOiBmdW5jdGlvbihhcnI6IEFycmF5PGFueT4gfCBUeXBlZEFycmF5KTogbnVtYmVyIHtcclxuICAgICAgICBsZXQgbGVuZ3RoID0gYXJyLmxlbmd0aDtcclxuICAgICAgICBsZXQgc3VtID0gMDtcclxuXHJcbiAgICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XHJcbiAgICAgICAgICAgIHN1bSArPSBhcnJbbGVuZ3RoXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHN1bTtcclxuICAgIH0sXHJcbn07XHJcbiIsImltcG9ydCB7IGNsb25lIH0gZnJvbSAnZ2wtdmVjMic7XHJcbmltcG9ydCB7IGhzdjJyZ2IgfSBmcm9tICcuL2N2X3V0aWxzJztcclxuaW1wb3J0IEFycmF5SGVscGVyIGZyb20gJy4vYXJyYXlfaGVscGVyJztcclxuaW1wb3J0IHtcclxuICAgIFhZU2l6ZSxcclxuICAgIFR5cGVkQXJyYXlDb25zdHJ1Y3RvcixcclxuICAgIFR5cGVkQXJyYXksXHJcbiAgICBXcmFwcGVySW5kZXhNYXBwaW5nLFxyXG4gICAgTW9tZW50LFxyXG4gICAgU3BhcnNlSW1hZ2VXcmFwcGVyLFxyXG59IGZyb20gJy4uLy4uL3R5cGUtZGVmaW5pdGlvbnMvcXVhZ2dhLmQnO1xyXG5cclxuY29uc3QgdmVjMiA9IHsgY2xvbmUgfTtcclxuXHJcbnR5cGUgUG9zaXRpdmVOdW1iZXIgPSBudW1iZXI7XHJcbmZ1bmN0aW9uIGFzc2VydE51bWJlclBvc2l0aXZlKHZhbDogbnVtYmVyKTogYXNzZXJ0cyB2YWwgaXMgUG9zaXRpdmVOdW1iZXIge1xyXG4gICAgaWYgKHZhbCA8IDApIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGV4cGVjdGVkIHBvc2l0aXZlIG51bWJlciwgcmVjZWl2ZWQgJHt2YWx9YCk7XHJcbiAgICB9XHJcbn1cclxuXHJcbmNsYXNzIEltYWdlV3JhcHBlciBpbXBsZW1lbnRzIFNwYXJzZUltYWdlV3JhcHBlciB7XHJcbiAgICBkYXRhOiBUeXBlZEFycmF5IHwgQXJyYXk8bnVtYmVyPjtcclxuXHJcbiAgICBzaXplOiBYWVNpemU7XHJcblxyXG4gICAgaW5kZXhNYXBwaW5nPzogV3JhcHBlckluZGV4TWFwcGluZztcclxuXHJcbiAgICAvLyBSZXByZXNlbnRzIGEgYmFzaWMgaW1hZ2UgY29tYmluaW5nIHRoZSBkYXRhIGFuZCBzaXplLiBJbiBhZGRpdGlvbiwgc29tZSBtZXRob2RzIGZvclxyXG4gICAgLy8gbWFuaXB1bGF0aW9uIGFyZSBjb250YWluZWQgd2l0aGluLlxyXG4gICAgY29uc3RydWN0b3IoXHJcbiAgICAgICAgc2l6ZTogWFlTaXplLFxyXG4gICAgICAgIGRhdGE/OiBUeXBlZEFycmF5IHwgQXJyYXk8bnVtYmVyPixcclxuICAgICAgICBBcnJheVR5cGU6IFR5cGVkQXJyYXlDb25zdHJ1Y3RvciB8IEFycmF5Q29uc3RydWN0b3IgPSBVaW50OEFycmF5LFxyXG4gICAgICAgIGluaXRpYWxpemU/OiBib29sZWFuLFxyXG4gICAgKSB7XHJcbiAgICAgICAgaWYgKCFkYXRhKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGF0YSA9IG5ldyAoQXJyYXlUeXBlKShzaXplLnggKiBzaXplLnkpO1xyXG4gICAgICAgICAgICBpZiAoaW5pdGlhbGl6ZSkge1xyXG4gICAgICAgICAgICAgICAgQXJyYXlIZWxwZXIuaW5pdCh0aGlzLmRhdGEsIDApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zaXplID0gc2l6ZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyB0ZXN0cyBpZiBhIHBvc2l0aW9uIGlzIHdpdGhpbiB0aGUgaW1hZ2UsIGV4dGVuZGVkIG91dCBieSBhIGJvcmRlciBvbiBlYWNoIHNpZGVcclxuICAgIGluSW1hZ2VXaXRoQm9yZGVyKGltZ1JlZjogWFlTaXplLCBib3JkZXI6IFBvc2l0aXZlTnVtYmVyID0gMCk6IGJvb2xlYW4ge1xyXG4gICAgICAgIGFzc2VydE51bWJlclBvc2l0aXZlKGJvcmRlcik7XHJcbiAgICAgICAgLy8gVE9ETzogY29kZV8xMjggc3RhcnRzIGZhaWxpbmcgbWlzZXJhYmx5IHdoZW4gaSBvbmx5IGFsbG93IGltZ1JlZiB0byBjb250YWluIHBvc2l0aXZlIG51bWJlcnMuXHJcbiAgICAgICAgLy8gVE9ETzogdGhpcyBkb2Vzbid0IG1ha2UgbXVjaCBzZW5zZSB0byBtZSwgd2h5IGRvZXMgaXQgZ28gbmVnYXRpdmU/ICBUZXN0cyBhcmUgbm90IGFmZmVjdGVkIGJ5XHJcbiAgICAgICAgLy8gcmV0dXJuaW5nIGZhbHNlLCBidXQgdGhlIHdob2xlIGNvZGVfMTI4IHJlYWRlciBibG93cyB1cCB3aGVuIGkgdGhyb3cgb24gbmVnYXRpdmUgaW1nUmVmLlxyXG4gICAgICAgIC8vIGFzc2VydE51bWJlclBvc2l0aXZlKGltZ1JlZi54KTtcclxuICAgICAgICAvLyBhc3NlcnROdW1iZXJQb3NpdGl2ZShpbWdSZWYueSk7XHJcbiAgICAgICAgcmV0dXJuIChpbWdSZWYueCA+PSAwKVxyXG4gICAgICAgICAgICAmJiAoaW1nUmVmLnkgPj0gMClcclxuICAgICAgICAgICAgJiYgKGltZ1JlZi54IDwgKHRoaXMuc2l6ZS54ICsgKGJvcmRlciAqIDIpKSlcclxuICAgICAgICAgICAgJiYgKGltZ1JlZi55IDwgKHRoaXMuc2l6ZS55ICsgKGJvcmRlciAqIDIpKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ29weSBmcm9tIFRISVMgSW1hZ2VXcmFwcGVyIHRvIHRoZSBuZXcgaW1hZ2VXcmFwcGVyIHBhcmFtZXRlciwgc3RhcnRpbmcgYXQgZnJvbSwgc3RvcHBpbmcgYXRcclxuICAgIC8vIGVuZCBvZiBuZXcgaW1hZ2VXcmFwcGVyIHNpemUuXHJcbiAgICBzdWJJbWFnZUFzQ29weShpbWFnZVdyYXBwZXI6IEltYWdlV3JhcHBlciwgZnJvbTogWFlTaXplKTogSW1hZ2VXcmFwcGVyIHtcclxuICAgICAgICBhc3NlcnROdW1iZXJQb3NpdGl2ZShmcm9tLngpO1xyXG4gICAgICAgIGFzc2VydE51bWJlclBvc2l0aXZlKGZyb20ueSk7XHJcbiAgICAgICAgY29uc3QgeyB4OiBzaXplWCwgeTogc2l6ZVkgfSA9IGltYWdlV3JhcHBlci5zaXplO1xyXG4gICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgc2l6ZVg7IHgrKykge1xyXG4gICAgICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IHNpemVZOyB5KyspIHtcclxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxyXG4gICAgICAgICAgICAgICAgaW1hZ2VXcmFwcGVyLmRhdGFbeSAqIHNpemVYICsgeF0gPSB0aGlzLmRhdGFbKGZyb20ueSArIHkpICogdGhpcy5zaXplLnggKyBmcm9tLnggKyB4XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaW1hZ2VXcmFwcGVyO1xyXG4gICAgICAgIC8vIFRPRE86IHRoaXMgZnVuY3Rpb24gcmVhbGx5IHByb2JhYmx5IHNob3VsZCBjYWxsIGludG8gSW1hZ2VXcmFwcGVyIHNvbWV3aGVyZSB0byBtYWtlXHJcbiAgICAgICAgLy8gc3VyZSB0aGF0IGFsbCBvZiBpdCdzIHBhcmFtZXRlcnMgYXJlIHNldCBwcm9wZXJseSwgc29tZXRoaW5nIGxpa2VcclxuICAgICAgICAvLyBJbWFnZVdyYXBwZXIuVXBkYXRlRnJvbSgpXHJcbiAgICAgICAgLy8gdGhhdCBtaWdodCB0YWtlIGEgcHJvdmlkZWQgZGF0YSBhbmQgc2l6ZSwgYW5kIG1ha2Ugc3VyZSB0aGVyZSdzIG5vIGludmFsaWQgaW5kZXhNYXBwaW5nXHJcbiAgICAgICAgLy8gaGFuZ2luZyBhcm91bmQsIGFuZCBzdWNoLlxyXG4gICAgfVxyXG5cclxuICAgIC8vIFJldHJpZXZlIGEgZ3JheXNjYWxlIHZhbHVlIGF0IHRoZSBnaXZlbiBwaXhlbCBwb3NpdGlvbiBvZiB0aGUgaW1hZ2VcclxuICAgIGdldCh4OiBudW1iZXIsIHk6IG51bWJlcik6IG51bWJlciB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVt5ICogdGhpcy5zaXplLnggKyB4XTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBSZXRyaWV2ZSBhIGdyYXlzY2FsZSB2YWx1ZSBhdCB0aGUgZ2l2ZW4gcGl4ZWwgcG9zaXRpb24gb2YgdGhlIGltYWdlIChzYWZlLCB3aGF0ZXZlciB0aGF0XHJcbiAgICAvLyBtZWFucylcclxuICAgIGdldFNhZmUoeDogbnVtYmVyLCB5OiBudW1iZXIpOiBudW1iZXIge1xyXG4gICAgICAgIC8vIGNhY2hlIGluZGV4TWFwcGluZyBiZWNhdXNlIGlmIHdlJ3JlIHVzaW5nIGl0IG9uY2UsIHdlJ2xsIHByb2JhYmx5IG5lZWQgaXQgYSBidW5jaCBtb3JlXHJcbiAgICAgICAgLy8gdG9vXHJcbiAgICAgICAgaWYgKCF0aGlzLmluZGV4TWFwcGluZykge1xyXG4gICAgICAgICAgICB0aGlzLmluZGV4TWFwcGluZyA9IHtcclxuICAgICAgICAgICAgICAgIHg6IFtdLFxyXG4gICAgICAgICAgICAgICAgeTogW10sXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zaXplLng7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbmRleE1hcHBpbmcueFtpXSA9IGk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmluZGV4TWFwcGluZy54W2kgKyB0aGlzLnNpemUueF0gPSBpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zaXplLnk7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbmRleE1hcHBpbmcueVtpXSA9IGk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmluZGV4TWFwcGluZy55W2kgKyB0aGlzLnNpemUueV0gPSBpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFbKHRoaXMuaW5kZXhNYXBwaW5nLnlbeSArIHRoaXMuc2l6ZS55XSkgKiB0aGlzLnNpemUueCArIHRoaXMuaW5kZXhNYXBwaW5nLnhbeCArIHRoaXMuc2l6ZS54XV07XHJcbiAgICB9XHJcblxyXG4gICAgLy8gU2V0cyBhIGdpdmVuIHBpeGVsIHBvc2l0aW9uIGluIHRoZSBpbWFnZSB0byB0aGUgZ2l2ZW4gZ3JheXNjYWxlIHZhbHVlXHJcbiAgICBzZXQoeDogbnVtYmVyLCB5OiBudW1iZXIsIHZhbHVlOiBudW1iZXIpOiBJbWFnZVdyYXBwZXIge1xyXG4gICAgICAgIHRoaXMuZGF0YVt5ICogdGhpcy5zaXplLnggKyB4XSA9IHZhbHVlO1xyXG4gICAgICAgIGRlbGV0ZSB0aGlzLmluZGV4TWFwcGluZztcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICAvLyBTZXRzIHRoZSBib3JkZXIgb2YgdGhlIGltYWdlICgxIHBpeGVsKSB0byB6ZXJvXHJcbiAgICB6ZXJvQm9yZGVyKCk6IEltYWdlV3JhcHBlciB7XHJcbiAgICAgICAgY29uc3QgeyB4OiB3aWR0aCwgeTogaGVpZ2h0IH0gPSB0aGlzLnNpemU7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3aWR0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1tdWx0aS1hc3NpZ25cclxuICAgICAgICAgICAgdGhpcy5kYXRhW2ldID0gdGhpcy5kYXRhWyhoZWlnaHQgLSAxKSAqIHdpZHRoICsgaV0gPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGhlaWdodCAtIDE7IGkrKykge1xyXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbXVsdGktYXNzaWduXHJcbiAgICAgICAgICAgIHRoaXMuZGF0YVtpICogd2lkdGhdID0gdGhpcy5kYXRhW2kgKiB3aWR0aCArICh3aWR0aCAtIDEpXSA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRlbGV0ZSB0aGlzLmluZGV4TWFwcGluZztcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICAvLyBUT0RPOiB0aGlzIGZ1bmN0aW9uIGlzIGVudGlyZWx5IHRvbyBsYXJnZSBmb3IgbWUgdG8gcmVhc29uIG91dCByaWdodCBhdCB0aGlzIG1vbWVudCB0aGF0IGknbSBoYW5kbGluZ1xyXG4gICAgLy8gYWxsIHRoZSByZXN0IG9mIGl0LCBzbyB0aGlzIGlzIGEgdmVyYmF0aW0gY29weSBvZiB0aGUgamF2YXNjcmlwdCBzb3VyY2UsIHdpdGggb25seSB0d2Vha3NcclxuICAgIC8vIG5lY2Vzc2FyeSB0byBnZXQgaXQgdG8gcnVuLCBubyB0aG91Z2h0IHB1dCBpbnRvIGl0IHlldC5cclxuICAgIG1vbWVudHMobGFiZWxDb3VudDogbnVtYmVyKTogQXJyYXk8TW9tZW50PiB7XHJcbiAgICAgICAgY29uc3QgeyBkYXRhIH0gPSB0aGlzO1xyXG4gICAgICAgIGxldCB4O1xyXG4gICAgICAgIGxldCB5O1xyXG4gICAgICAgIGNvbnN0IGhlaWdodCA9IHRoaXMuc2l6ZS55O1xyXG4gICAgICAgIGNvbnN0IHdpZHRoID0gdGhpcy5zaXplLng7XHJcbiAgICAgICAgbGV0IHZhbDtcclxuICAgICAgICBsZXQgeXNxO1xyXG4gICAgICAgIGNvbnN0IGxhYmVsU3VtOiBBcnJheTxNb21lbnQ+ID0gW107XHJcbiAgICAgICAgbGV0IGk7XHJcbiAgICAgICAgbGV0IGxhYmVsO1xyXG4gICAgICAgIGxldCBtdTExO1xyXG4gICAgICAgIGxldCBtdTAyO1xyXG4gICAgICAgIGxldCBtdTIwO1xyXG4gICAgICAgIGxldCB4XztcclxuICAgICAgICBsZXQgeV87XHJcbiAgICAgICAgbGV0IHRtcDtcclxuICAgICAgICBjb25zdCByZXN1bHQ6IEFycmF5PE1vbWVudD4gPSBbXTtcclxuICAgICAgICBjb25zdCB7IFBJIH0gPSBNYXRoO1xyXG4gICAgICAgIGNvbnN0IFBJXzQgPSBQSSAvIDQ7XHJcblxyXG4gICAgICAgIGlmIChsYWJlbENvdW50IDw9IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsYWJlbENvdW50OyBpKyspIHtcclxuICAgICAgICAgICAgbGFiZWxTdW1baV0gPSB7XHJcbiAgICAgICAgICAgICAgICBtMDA6IDAsXHJcbiAgICAgICAgICAgICAgICBtMDE6IDAsXHJcbiAgICAgICAgICAgICAgICBtMTA6IDAsXHJcbiAgICAgICAgICAgICAgICBtMTE6IDAsXHJcbiAgICAgICAgICAgICAgICBtMDI6IDAsXHJcbiAgICAgICAgICAgICAgICBtMjA6IDAsXHJcbiAgICAgICAgICAgICAgICB0aGV0YTogMCxcclxuICAgICAgICAgICAgICAgIHJhZDogMCxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvciAoeSA9IDA7IHkgPCBoZWlnaHQ7IHkrKykge1xyXG4gICAgICAgICAgICB5c3EgPSB5ICogeTtcclxuICAgICAgICAgICAgZm9yICh4ID0gMDsgeCA8IHdpZHRoOyB4KyspIHtcclxuICAgICAgICAgICAgICAgIHZhbCA9IGRhdGFbeSAqIHdpZHRoICsgeF07XHJcbiAgICAgICAgICAgICAgICBpZiAodmFsID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsID0gbGFiZWxTdW1bdmFsIC0gMV07XHJcbiAgICAgICAgICAgICAgICAgICAgbGFiZWwubTAwICs9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgbGFiZWwubTAxICs9IHk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGFiZWwubTEwICs9IHg7XHJcbiAgICAgICAgICAgICAgICAgICAgbGFiZWwubTExICs9IHggKiB5O1xyXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsLm0wMiArPSB5c3E7XHJcbiAgICAgICAgICAgICAgICAgICAgbGFiZWwubTIwICs9IHggKiB4O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGFiZWxDb3VudDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGxhYmVsID0gbGFiZWxTdW1baV07XHJcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLWdsb2JhbHNcclxuICAgICAgICAgICAgaWYgKCFpc05hTihsYWJlbC5tMDApICYmIGxhYmVsLm0wMCAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgeF8gPSBsYWJlbC5tMTAgLyBsYWJlbC5tMDA7XHJcbiAgICAgICAgICAgICAgICB5XyA9IGxhYmVsLm0wMSAvIGxhYmVsLm0wMDtcclxuICAgICAgICAgICAgICAgIG11MTEgPSBsYWJlbC5tMTEgLyBsYWJlbC5tMDAgLSB4XyAqIHlfO1xyXG4gICAgICAgICAgICAgICAgbXUwMiA9IGxhYmVsLm0wMiAvIGxhYmVsLm0wMCAtIHlfICogeV87XHJcbiAgICAgICAgICAgICAgICBtdTIwID0gbGFiZWwubTIwIC8gbGFiZWwubTAwIC0geF8gKiB4XztcclxuICAgICAgICAgICAgICAgIHRtcCA9IChtdTAyIC0gbXUyMCkgLyAoMiAqIG11MTEpO1xyXG4gICAgICAgICAgICAgICAgdG1wID0gMC41ICogTWF0aC5hdGFuKHRtcCkgKyAobXUxMSA+PSAwID8gUElfNCA6IC1QSV80KSArIFBJO1xyXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW1peGVkLW9wZXJhdG9yc1xyXG4gICAgICAgICAgICAgICAgbGFiZWwudGhldGEgPSAodG1wICogMTgwIC8gUEkgKyA5MCkgJSAxODAgLSA5MDtcclxuICAgICAgICAgICAgICAgIGlmIChsYWJlbC50aGV0YSA8IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBsYWJlbC50aGV0YSArPSAxODA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBsYWJlbC5yYWQgPSB0bXAgPiBQSSA/IHRtcCAtIFBJIDogdG1wO1xyXG4gICAgICAgICAgICAgICAgbGFiZWwudmVjID0gdmVjMi5jbG9uZShbTWF0aC5jb3ModG1wKSwgTWF0aC5zaW4odG1wKV0pO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobGFiZWwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gcmV0dXJuIGEgVWludDhDbGFtcGVkQXJyYXkgY29udGFpbmluZyB0aGlzIGdyYXlzY2FsZSBpbWFnZSBjb252ZXJ0ZWQgdG8gUkdCQSBmb3JtXHJcbiAgICBnZXRBc1JHQkEoc2NhbGUgPSAxLjApOiBVaW50OENsYW1wZWRBcnJheSB7XHJcbiAgICAgICAgY29uc3QgcmV0ID0gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KDQgKiB0aGlzLnNpemUueCAqIHRoaXMuc2l6ZS55KTtcclxuICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IHRoaXMuc2l6ZS55OyB5KyspIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCB0aGlzLnNpemUueDsgeCsrKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwaXhlbCA9IHkgKiB0aGlzLnNpemUueCArIHg7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5nZXQoeCwgeSkgKiBzY2FsZTtcclxuICAgICAgICAgICAgICAgIHJldFtwaXhlbCAqIDQgKyAwXSA9IGN1cnJlbnQ7XHJcbiAgICAgICAgICAgICAgICByZXRbcGl4ZWwgKiA0ICsgMV0gPSBjdXJyZW50O1xyXG4gICAgICAgICAgICAgICAgcmV0W3BpeGVsICogNCArIDJdID0gY3VycmVudDtcclxuICAgICAgICAgICAgICAgIHJldFtwaXhlbCAqIDQgKyAzXSA9IDI1NTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmV0O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIERpc3BsYXkgdGhpcyBJbWFnZVdyYXBwZXIgaW4gYSBnaXZlbiBDYW52YXMgZWxlbWVudCBhdCB0aGUgc3BlY2lmaWVkIHNjYWxlXHJcbiAgICBzaG93KGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQsIHNjYWxlID0gMS4wKTogdm9pZCB7XHJcbiAgICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XHJcbiAgICAgICAgaWYgKCFjdHgpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gZ2V0IGNhbnZhcyBjb250ZXh0Jyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGZyYW1lID0gY3R4LmdldEltYWdlRGF0YSgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xyXG4gICAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLmdldEFzUkdCQShzY2FsZSk7XHJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXHJcbiAgICAgICAgY2FudmFzLndpZHRoID0gdGhpcy5zaXplLng7XHJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXHJcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IHRoaXMuc2l6ZS55O1xyXG4gICAgICAgIGNvbnN0IG5ld0ZyYW1lID0gbmV3IEltYWdlRGF0YShkYXRhLCBmcmFtZS53aWR0aCwgZnJhbWUuaGVpZ2h0KTtcclxuICAgICAgICBjdHgucHV0SW1hZ2VEYXRhKG5ld0ZyYW1lLCAwLCAwKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBEaXNwbGF5cyBhIHNwZWNpZmllZCBTdWJJbWFnZSBhcmVhIGluIGEgZ2l2ZW4gY2FudmFzLiBUaGlzIGRpZmZlcnMgZHJhc3RpY2FsbHkgZnJvbVxyXG4gICAgLy8gY3JlYXRpbmcgYSBuZXcgU3ViSW1hZ2UgYW5kIHVzaW5nIGl0J3Mgc2hvdygpIG1ldGhvZC4gV2h5PyBJIGRvbid0IGhhdmUgdGhlIGFuc3dlciB0byB0aGF0XHJcbiAgICAvLyB5ZXQuICBJIHN1c3BlY3QgdGhlIEhTVi9SR0Igb3BlcmF0aW9ucyBpbnZvbHZlZCBoZXJlIGFyZSBtYWtpbmcgaXQgc2lnbmlmaWNhbnRseSBkaWZmZXJlbnQsXHJcbiAgICAvLyBidXQgdW50aWwgSSBjYW4gdmlzdWFsaXplIHRoZXNlIGZ1bmN0aW9ucyBzaWRlIGJ5IHNpZGUsIEknbSBqdXN0IGdvaW5nIHRvIGNvcHkgdGhlIGV4aXN0aW5nXHJcbiAgICAvLyBpbXBsZW1lbnRhdGlvbi5cclxuICAgIG92ZXJsYXkoY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCwgaW5TY2FsZTogbnVtYmVyLCBmcm9tOiBYWVNpemUpOiB2b2lkIHtcclxuICAgICAgICBjb25zdCBhZGp1c3RlZFNjYWxlID0gKGluU2NhbGUgPCAwIHx8IGluU2NhbGUgPiAzNjApID8gMzYwIDogaW5TY2FsZTtcclxuICAgICAgICBjb25zdCBoc3YgPSBbMCwgMSwgMV07XHJcbiAgICAgICAgY29uc3QgcmdiID0gWzAsIDAsIDBdO1xyXG4gICAgICAgIGNvbnN0IHdoaXRlUmdiID0gWzI1NSwgMjU1LCAyNTVdO1xyXG4gICAgICAgIGNvbnN0IGJsYWNrUmdiID0gWzAsIDAsIDBdO1xyXG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcclxuICAgICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcclxuICAgICAgICBpZiAoIWN0eCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBnZXQgY2FudmFzIGNvbnRleHQnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgZnJhbWUgPSBjdHguZ2V0SW1hZ2VEYXRhKGZyb20ueCwgZnJvbS55LCB0aGlzLnNpemUueCwgdGhpcy5zaXplLnkpO1xyXG4gICAgICAgIGNvbnN0IHsgZGF0YSB9ID0gZnJhbWU7XHJcbiAgICAgICAgbGV0IHsgbGVuZ3RoIH0gPSB0aGlzLmRhdGE7XHJcbiAgICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XHJcbiAgICAgICAgICAgIGhzdlswXSA9IHRoaXMuZGF0YVtsZW5ndGhdICogYWRqdXN0ZWRTY2FsZTtcclxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5lc3RlZC10ZXJuYXJ5XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IGhzdlswXSA8PSAwID8gd2hpdGVSZ2IgOiBoc3ZbMF0gPj0gMzYwID8gYmxhY2tSZ2IgOiBoc3YycmdiKGhzdiwgcmdiKTtcclxuICAgICAgICAgICAgY29uc3QgcG9zID0gbGVuZ3RoICogNDtcclxuICAgICAgICAgICAgW2RhdGFbcG9zXSwgZGF0YVtwb3MgKyAxXSwgZGF0YVtwb3MgKyAyXV0gPSByZXN1bHQ7XHJcbiAgICAgICAgICAgIGRhdGFbcG9zICsgM10gPSAyNTU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGN0eC5wdXRJbWFnZURhdGEoZnJhbWUsIGZyb20ueCwgZnJvbS55KTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgSW1hZ2VXcmFwcGVyO1xyXG4iLCIvLyBUT0RPOiBjbHVzdGVyLmpzIGFuZCBjdl91dGlscy5qcyBhcmUgcHJldHR5IHRpZ2h0bHkgaW50ZXJ0d2luZWQsIG1ha2luZyBmb3IgYSBjb21wbGV4IGNvbnZlcnNpb25cclxuLy8gaW50byB0eXBlc2NyaXB0LiBiZSB3YXJuZWQuIDotKVxyXG5cclxuaW1wb3J0IHsgY2xvbmUsIGRvdCB9IGZyb20gJ2dsLXZlYzInO1xyXG5cclxuY29uc3QgdmVjMiA9IHsgY2xvbmUsIGRvdCB9O1xyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBjbHVzdGVyIGZvciBncm91cGluZyBzaW1pbGFyIG9yaWVudGF0aW9ucyBvZiBkYXRhcG9pbnRzXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgICBjcmVhdGUocG9pbnQsIHRocmVzaG9sZCkge1xyXG4gICAgICAgIGNvbnN0IHBvaW50cyA9IFtdO1xyXG4gICAgICAgIGNvbnN0IGNlbnRlciA9IHtcclxuICAgICAgICAgICAgcmFkOiAwLFxyXG4gICAgICAgICAgICB2ZWM6IHZlYzIuY2xvbmUoWzAsIDBdKSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNvbnN0IHBvaW50TWFwID0ge307XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGFkZChwb2ludFRvQWRkKSB7XHJcbiAgICAgICAgICAgIHBvaW50TWFwW3BvaW50VG9BZGQuaWRdID0gcG9pbnRUb0FkZDtcclxuICAgICAgICAgICAgcG9pbnRzLnB1c2gocG9pbnRUb0FkZCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiB1cGRhdGVDZW50ZXIoKSB7XHJcbiAgICAgICAgICAgIGxldCBpOyBsZXRcclxuICAgICAgICAgICAgICAgIHN1bSA9IDA7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHN1bSArPSBwb2ludHNbaV0ucmFkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNlbnRlci5yYWQgPSBzdW0gLyBwb2ludHMubGVuZ3RoO1xyXG4gICAgICAgICAgICBjZW50ZXIudmVjID0gdmVjMi5jbG9uZShbTWF0aC5jb3MoY2VudGVyLnJhZCksIE1hdGguc2luKGNlbnRlci5yYWQpXSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBpbml0KCkge1xyXG4gICAgICAgICAgICBhZGQocG9pbnQpO1xyXG4gICAgICAgICAgICB1cGRhdGVDZW50ZXIoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGluaXQoKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgYWRkKHBvaW50VG9BZGQpIHtcclxuICAgICAgICAgICAgICAgIGlmICghcG9pbnRNYXBbcG9pbnRUb0FkZC5pZF0pIHtcclxuICAgICAgICAgICAgICAgICAgICBhZGQocG9pbnRUb0FkZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlQ2VudGVyKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGZpdHMob3RoZXJQb2ludCkge1xyXG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgY29zaW5lIHNpbWlsYXJpdHkgdG8gY2VudGVyLWFuZ2xlXHJcbiAgICAgICAgICAgICAgICBjb25zdCBzaW1pbGFyaXR5ID0gTWF0aC5hYnModmVjMi5kb3Qob3RoZXJQb2ludC5wb2ludC52ZWMsIGNlbnRlci52ZWMpKTtcclxuICAgICAgICAgICAgICAgIGlmIChzaW1pbGFyaXR5ID4gdGhyZXNob2xkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGdldFBvaW50cygpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwb2ludHM7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGdldENlbnRlcigpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjZW50ZXI7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfTtcclxuICAgIH0sXHJcbiAgICBjcmVhdGVQb2ludChuZXdQb2ludCwgaWQsIHByb3BlcnR5KSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgcmFkOiBuZXdQb2ludFtwcm9wZXJ0eV0sXHJcbiAgICAgICAgICAgIHBvaW50OiBuZXdQb2ludCxcclxuICAgICAgICAgICAgaWQsXHJcbiAgICAgICAgfTtcclxuICAgIH0sXHJcbn07XHJcbiIsIi8qIGVzbGludC1kaXNhYmxlIG5vLW1peGVkLW9wZXJhdG9ycyAqL1xyXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1iaXR3aXNlICovXHJcbmltcG9ydCB7IGNsb25lIGFzIHYyY2xvbmUgfSBmcm9tICdnbC12ZWMyJztcclxuaW1wb3J0IHsgY2xvbmUgYXMgdjNjbG9uZSB9IGZyb20gJ2dsLXZlYzMnO1xyXG5pbXBvcnQgQ2x1c3RlcjIgZnJvbSAnLi9jbHVzdGVyJztcclxuaW1wb3J0IEFycmF5SGVscGVyIGZyb20gJy4vYXJyYXlfaGVscGVyJztcclxuXHJcbmNvbnN0IHZlYzIgPSB7IGNsb25lOiB2MmNsb25lIH07XHJcbmNvbnN0IHZlYzMgPSB7IGNsb25lOiB2M2Nsb25lIH07XHJcblxyXG4vKipcclxuICogQHBhcmFtIHggeC1jb29yZGluYXRlXHJcbiAqIEBwYXJhbSB5IHktY29vcmRpbmF0ZVxyXG4gKiBAcmV0dXJuIEltYWdlUmVmZXJlbmNlIHt4LHl9IENvb3JkaW5hdGVcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBpbWFnZVJlZih4LCB5KSB7XHJcbiAgICBjb25zdCB0aGF0ID0ge1xyXG4gICAgICAgIHgsXHJcbiAgICAgICAgeSxcclxuICAgICAgICB0b1ZlYzIoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB2ZWMyLmNsb25lKFt0aGlzLngsIHRoaXMueV0pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdG9WZWMzKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdmVjMy5jbG9uZShbdGhpcy54LCB0aGlzLnksIDFdKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHJvdW5kKCkge1xyXG4gICAgICAgICAgICB0aGlzLnggPSB0aGlzLnggPiAwLjAgPyBNYXRoLmZsb29yKHRoaXMueCArIDAuNSkgOiBNYXRoLmZsb29yKHRoaXMueCAtIDAuNSk7XHJcbiAgICAgICAgICAgIHRoaXMueSA9IHRoaXMueSA+IDAuMCA/IE1hdGguZmxvb3IodGhpcy55ICsgMC41KSA6IE1hdGguZmxvb3IodGhpcy55IC0gMC41KTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfSxcclxuICAgIH07XHJcbiAgICByZXR1cm4gdGhhdDtcclxufVxyXG5cclxuLyoqXHJcbiAqIENvbXB1dGVzIGFuIGludGVncmFsIGltYWdlIG9mIGEgZ2l2ZW4gZ3JheXNjYWxlIGltYWdlLlxyXG4gKiBAcGFyYW0gaW1hZ2VEYXRhQ29udGFpbmVyIHtJbWFnZURhdGFDb250YWluZXJ9IHRoZSBpbWFnZSB0byBiZSBpbnRlZ3JhdGVkXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZUludGVncmFsSW1hZ2UyKGltYWdlV3JhcHBlciwgaW50ZWdyYWxXcmFwcGVyKSB7XHJcbiAgICBjb25zdCBpbWFnZURhdGEgPSBpbWFnZVdyYXBwZXIuZGF0YTtcclxuICAgIGNvbnN0IHdpZHRoID0gaW1hZ2VXcmFwcGVyLnNpemUueDtcclxuICAgIGNvbnN0IGhlaWdodCA9IGltYWdlV3JhcHBlci5zaXplLnk7XHJcbiAgICBjb25zdCBpbnRlZ3JhbEltYWdlRGF0YSA9IGludGVncmFsV3JhcHBlci5kYXRhO1xyXG4gICAgbGV0IHN1bSA9IDA7IGxldCBwb3NBID0gMDsgbGV0IHBvc0IgPSAwOyBsZXQgcG9zQyA9IDA7IGxldCBwb3NEID0gMDsgbGV0IHg7IGxldFxyXG4gICAgICAgIHk7XHJcblxyXG4gICAgLy8gc3VtIHVwIGZpcnN0IGNvbHVtblxyXG4gICAgcG9zQiA9IHdpZHRoO1xyXG4gICAgc3VtID0gMDtcclxuICAgIGZvciAoeSA9IDE7IHkgPCBoZWlnaHQ7IHkrKykge1xyXG4gICAgICAgIHN1bSArPSBpbWFnZURhdGFbcG9zQV07XHJcbiAgICAgICAgaW50ZWdyYWxJbWFnZURhdGFbcG9zQl0gKz0gc3VtO1xyXG4gICAgICAgIHBvc0EgKz0gd2lkdGg7XHJcbiAgICAgICAgcG9zQiArPSB3aWR0aDtcclxuICAgIH1cclxuXHJcbiAgICBwb3NBID0gMDtcclxuICAgIHBvc0IgPSAxO1xyXG4gICAgc3VtID0gMDtcclxuICAgIGZvciAoeCA9IDE7IHggPCB3aWR0aDsgeCsrKSB7XHJcbiAgICAgICAgc3VtICs9IGltYWdlRGF0YVtwb3NBXTtcclxuICAgICAgICBpbnRlZ3JhbEltYWdlRGF0YVtwb3NCXSArPSBzdW07XHJcbiAgICAgICAgcG9zQSsrO1xyXG4gICAgICAgIHBvc0IrKztcclxuICAgIH1cclxuXHJcbiAgICBmb3IgKHkgPSAxOyB5IDwgaGVpZ2h0OyB5KyspIHtcclxuICAgICAgICBwb3NBID0geSAqIHdpZHRoICsgMTtcclxuICAgICAgICBwb3NCID0gKHkgLSAxKSAqIHdpZHRoICsgMTtcclxuICAgICAgICBwb3NDID0geSAqIHdpZHRoO1xyXG4gICAgICAgIHBvc0QgPSAoeSAtIDEpICogd2lkdGg7XHJcbiAgICAgICAgZm9yICh4ID0gMTsgeCA8IHdpZHRoOyB4KyspIHtcclxuICAgICAgICAgICAgaW50ZWdyYWxJbWFnZURhdGFbcG9zQV1cclxuICAgICAgICAgICAgICAgICs9IGltYWdlRGF0YVtwb3NBXSArIGludGVncmFsSW1hZ2VEYXRhW3Bvc0JdICsgaW50ZWdyYWxJbWFnZURhdGFbcG9zQ10gLSBpbnRlZ3JhbEltYWdlRGF0YVtwb3NEXTtcclxuICAgICAgICAgICAgcG9zQSsrO1xyXG4gICAgICAgICAgICBwb3NCKys7XHJcbiAgICAgICAgICAgIHBvc0MrKztcclxuICAgICAgICAgICAgcG9zRCsrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVJbnRlZ3JhbEltYWdlKGltYWdlV3JhcHBlciwgaW50ZWdyYWxXcmFwcGVyKSB7XHJcbiAgICBjb25zdCBpbWFnZURhdGEgPSBpbWFnZVdyYXBwZXIuZGF0YTtcclxuICAgIGNvbnN0IHdpZHRoID0gaW1hZ2VXcmFwcGVyLnNpemUueDtcclxuICAgIGNvbnN0IGhlaWdodCA9IGltYWdlV3JhcHBlci5zaXplLnk7XHJcbiAgICBjb25zdCBpbnRlZ3JhbEltYWdlRGF0YSA9IGludGVncmFsV3JhcHBlci5kYXRhO1xyXG4gICAgbGV0IHN1bSA9IDA7XHJcblxyXG4gICAgLy8gc3VtIHVwIGZpcnN0IHJvd1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3aWR0aDsgaSsrKSB7XHJcbiAgICAgICAgc3VtICs9IGltYWdlRGF0YVtpXTtcclxuICAgICAgICBpbnRlZ3JhbEltYWdlRGF0YVtpXSA9IHN1bTtcclxuICAgIH1cclxuXHJcbiAgICBmb3IgKGxldCB2ID0gMTsgdiA8IGhlaWdodDsgdisrKSB7XHJcbiAgICAgICAgc3VtID0gMDtcclxuICAgICAgICBmb3IgKGxldCB1ID0gMDsgdSA8IHdpZHRoOyB1KyspIHtcclxuICAgICAgICAgICAgc3VtICs9IGltYWdlRGF0YVt2ICogd2lkdGggKyB1XTtcclxuICAgICAgICAgICAgaW50ZWdyYWxJbWFnZURhdGFbKCh2KSAqIHdpZHRoKSArIHVdID0gc3VtICsgaW50ZWdyYWxJbWFnZURhdGFbKHYgLSAxKSAqIHdpZHRoICsgdV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdGhyZXNob2xkSW1hZ2UoaW1hZ2VXcmFwcGVyLCB0aHJlc2hvbGQsIHRhcmdldFdyYXBwZXIpIHtcclxuICAgIGlmICghdGFyZ2V0V3JhcHBlcikge1xyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxyXG4gICAgICAgIHRhcmdldFdyYXBwZXIgPSBpbWFnZVdyYXBwZXI7XHJcbiAgICB9XHJcbiAgICBjb25zdCBpbWFnZURhdGEgPSBpbWFnZVdyYXBwZXIuZGF0YTsgbGV0IHsgbGVuZ3RoIH0gPSBpbWFnZURhdGE7IGNvbnN0XHJcbiAgICAgICAgdGFyZ2V0RGF0YSA9IHRhcmdldFdyYXBwZXIuZGF0YTtcclxuXHJcbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcclxuICAgICAgICB0YXJnZXREYXRhW2xlbmd0aF0gPSBpbWFnZURhdGFbbGVuZ3RoXSA8IHRocmVzaG9sZCA/IDEgOiAwO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZUhpc3RvZ3JhbShpbWFnZVdyYXBwZXIsIGJpdHNQZXJQaXhlbCkge1xyXG4gICAgaWYgKCFiaXRzUGVyUGl4ZWwpIHtcclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cclxuICAgICAgICBiaXRzUGVyUGl4ZWwgPSA4O1xyXG4gICAgfVxyXG4gICAgY29uc3QgaW1hZ2VEYXRhID0gaW1hZ2VXcmFwcGVyLmRhdGE7XHJcbiAgICBsZXQgeyBsZW5ndGggfSA9IGltYWdlRGF0YTtcclxuICAgIGNvbnN0IGJpdFNoaWZ0ID0gOCAtIGJpdHNQZXJQaXhlbDtcclxuICAgIGNvbnN0IGJ1Y2tldENudCA9IDEgPDwgYml0c1BlclBpeGVsO1xyXG4gICAgY29uc3QgaGlzdCA9IG5ldyBJbnQzMkFycmF5KGJ1Y2tldENudCk7XHJcblxyXG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XHJcbiAgICAgICAgaGlzdFtpbWFnZURhdGFbbGVuZ3RoXSA+PiBiaXRTaGlmdF0rKztcclxuICAgIH1cclxuICAgIHJldHVybiBoaXN0O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gc2hhcnBlbkxpbmUobGluZSkge1xyXG4gICAgbGV0IGk7XHJcbiAgICBjb25zdCB7IGxlbmd0aCB9ID0gbGluZTtcclxuICAgIGxldCBsZWZ0ID0gbGluZVswXTtcclxuICAgIGxldCBjZW50ZXIgPSBsaW5lWzFdO1xyXG4gICAgbGV0IHJpZ2h0O1xyXG5cclxuICAgIGZvciAoaSA9IDE7IGkgPCBsZW5ndGggLSAxOyBpKyspIHtcclxuICAgICAgICByaWdodCA9IGxpbmVbaSArIDFdO1xyXG4gICAgICAgIC8vICAtMSA0IC0xIGtlcm5lbFxyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxyXG4gICAgICAgIGxpbmVbaSAtIDFdID0gKCgoY2VudGVyICogMikgLSBsZWZ0IC0gcmlnaHQpKSAmIDI1NTtcclxuICAgICAgICBsZWZ0ID0gY2VudGVyO1xyXG4gICAgICAgIGNlbnRlciA9IHJpZ2h0O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGxpbmU7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBkZXRlcm1pbmVPdHN1VGhyZXNob2xkKGltYWdlV3JhcHBlciwgYml0c1BlclBpeGVsID0gOCkge1xyXG4gICAgbGV0IGhpc3Q7XHJcbiAgICBjb25zdCBiaXRTaGlmdCA9IDggLSBiaXRzUGVyUGl4ZWw7XHJcblxyXG4gICAgZnVuY3Rpb24gcHgoaW5pdCwgZW5kKSB7XHJcbiAgICAgICAgbGV0IHN1bSA9IDA7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IGluaXQ7IGkgPD0gZW5kOyBpKyspIHtcclxuICAgICAgICAgICAgc3VtICs9IGhpc3RbaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzdW07XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gbXgoaW5pdCwgZW5kKSB7XHJcbiAgICAgICAgbGV0IHN1bSA9IDA7XHJcblxyXG4gICAgICAgIGZvciAobGV0IGkgPSBpbml0OyBpIDw9IGVuZDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHN1bSArPSBpICogaGlzdFtpXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBzdW07XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZGV0ZXJtaW5lVGhyZXNob2xkKCkge1xyXG4gICAgICAgIGNvbnN0IHZldCA9IFswXTtcclxuICAgICAgICBsZXQgcDE7XHJcbiAgICAgICAgbGV0IHAyO1xyXG4gICAgICAgIGxldCBwMTI7XHJcbiAgICAgICAgbGV0IG0xO1xyXG4gICAgICAgIGxldCBtMjtcclxuICAgICAgICBsZXQgbTEyO1xyXG4gICAgICAgIGNvbnN0IG1heCA9ICgxIDw8IGJpdHNQZXJQaXhlbCkgLSAxO1xyXG5cclxuICAgICAgICBoaXN0ID0gY29tcHV0ZUhpc3RvZ3JhbShpbWFnZVdyYXBwZXIsIGJpdHNQZXJQaXhlbCk7XHJcbiAgICAgICAgZm9yIChsZXQgayA9IDE7IGsgPCBtYXg7IGsrKykge1xyXG4gICAgICAgICAgICBwMSA9IHB4KDAsIGspO1xyXG4gICAgICAgICAgICBwMiA9IHB4KGsgKyAxLCBtYXgpO1xyXG4gICAgICAgICAgICBwMTIgPSBwMSAqIHAyO1xyXG4gICAgICAgICAgICBpZiAocDEyID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBwMTIgPSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG0xID0gbXgoMCwgaykgKiBwMjtcclxuICAgICAgICAgICAgbTIgPSBteChrICsgMSwgbWF4KSAqIHAxO1xyXG4gICAgICAgICAgICBtMTIgPSBtMSAtIG0yO1xyXG4gICAgICAgICAgICB2ZXRba10gPSBtMTIgKiBtMTIgLyBwMTI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBBcnJheUhlbHBlci5tYXhJbmRleCh2ZXQpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHRocmVzaG9sZCA9IGRldGVybWluZVRocmVzaG9sZCgpO1xyXG4gICAgcmV0dXJuIHRocmVzaG9sZCA8PCBiaXRTaGlmdDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIG90c3VUaHJlc2hvbGQoaW1hZ2VXcmFwcGVyLCB0YXJnZXRXcmFwcGVyKSB7XHJcbiAgICBjb25zdCB0aHJlc2hvbGQgPSBkZXRlcm1pbmVPdHN1VGhyZXNob2xkKGltYWdlV3JhcHBlcik7XHJcblxyXG4gICAgdGhyZXNob2xkSW1hZ2UoaW1hZ2VXcmFwcGVyLCB0aHJlc2hvbGQsIHRhcmdldFdyYXBwZXIpO1xyXG4gICAgcmV0dXJuIHRocmVzaG9sZDtcclxufVxyXG5cclxuLy8gbG9jYWwgdGhyZXNob2xkaW5nXHJcbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlQmluYXJ5SW1hZ2UoaW1hZ2VXcmFwcGVyLCBpbnRlZ3JhbFdyYXBwZXIsIHRhcmdldFdyYXBwZXIpIHtcclxuICAgIGNvbXB1dGVJbnRlZ3JhbEltYWdlKGltYWdlV3JhcHBlciwgaW50ZWdyYWxXcmFwcGVyKTtcclxuXHJcbiAgICBpZiAoIXRhcmdldFdyYXBwZXIpIHtcclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cclxuICAgICAgICB0YXJnZXRXcmFwcGVyID0gaW1hZ2VXcmFwcGVyO1xyXG4gICAgfVxyXG4gICAgY29uc3QgaW1hZ2VEYXRhID0gaW1hZ2VXcmFwcGVyLmRhdGE7XHJcbiAgICBjb25zdCB0YXJnZXREYXRhID0gdGFyZ2V0V3JhcHBlci5kYXRhO1xyXG4gICAgY29uc3Qgd2lkdGggPSBpbWFnZVdyYXBwZXIuc2l6ZS54O1xyXG4gICAgY29uc3QgaGVpZ2h0ID0gaW1hZ2VXcmFwcGVyLnNpemUueTtcclxuICAgIGNvbnN0IGludGVncmFsSW1hZ2VEYXRhID0gaW50ZWdyYWxXcmFwcGVyLmRhdGE7XHJcbiAgICBsZXQgc3VtID0gMDsgbGV0IHY7IGxldCB1OyBjb25zdCBrZXJuZWwgPSAzOyBsZXQgQTsgbGV0IEI7IGxldCBDOyBsZXQgRDsgbGV0IGF2ZzsgY29uc3RcclxuICAgICAgICBzaXplID0gKGtlcm5lbCAqIDIgKyAxKSAqIChrZXJuZWwgKiAyICsgMSk7XHJcblxyXG4gICAgLy8gY2xlYXIgb3V0IHRvcCAmIGJvdHRvbS1ib3JkZXJcclxuICAgIGZvciAodiA9IDA7IHYgPD0ga2VybmVsOyB2KyspIHtcclxuICAgICAgICBmb3IgKHUgPSAwOyB1IDwgd2lkdGg7IHUrKykge1xyXG4gICAgICAgICAgICB0YXJnZXREYXRhWygodikgKiB3aWR0aCkgKyB1XSA9IDA7XHJcbiAgICAgICAgICAgIHRhcmdldERhdGFbKCgoaGVpZ2h0IC0gMSkgLSB2KSAqIHdpZHRoKSArIHVdID0gMDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gY2xlYXIgb3V0IGxlZnQgJiByaWdodCBib3JkZXJcclxuICAgIGZvciAodiA9IGtlcm5lbDsgdiA8IGhlaWdodCAtIGtlcm5lbDsgdisrKSB7XHJcbiAgICAgICAgZm9yICh1ID0gMDsgdSA8PSBrZXJuZWw7IHUrKykge1xyXG4gICAgICAgICAgICB0YXJnZXREYXRhWygodikgKiB3aWR0aCkgKyB1XSA9IDA7XHJcbiAgICAgICAgICAgIHRhcmdldERhdGFbKCh2KSAqIHdpZHRoKSArICh3aWR0aCAtIDEgLSB1KV0gPSAwO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmb3IgKHYgPSBrZXJuZWwgKyAxOyB2IDwgaGVpZ2h0IC0ga2VybmVsIC0gMTsgdisrKSB7XHJcbiAgICAgICAgZm9yICh1ID0ga2VybmVsICsgMTsgdSA8IHdpZHRoIC0ga2VybmVsOyB1KyspIHtcclxuICAgICAgICAgICAgQSA9IGludGVncmFsSW1hZ2VEYXRhWyh2IC0ga2VybmVsIC0gMSkgKiB3aWR0aCArICh1IC0ga2VybmVsIC0gMSldO1xyXG4gICAgICAgICAgICBCID0gaW50ZWdyYWxJbWFnZURhdGFbKHYgLSBrZXJuZWwgLSAxKSAqIHdpZHRoICsgKHUgKyBrZXJuZWwpXTtcclxuICAgICAgICAgICAgQyA9IGludGVncmFsSW1hZ2VEYXRhWyh2ICsga2VybmVsKSAqIHdpZHRoICsgKHUgLSBrZXJuZWwgLSAxKV07XHJcbiAgICAgICAgICAgIEQgPSBpbnRlZ3JhbEltYWdlRGF0YVsodiArIGtlcm5lbCkgKiB3aWR0aCArICh1ICsga2VybmVsKV07XHJcbiAgICAgICAgICAgIHN1bSA9IEQgLSBDIC0gQiArIEE7XHJcbiAgICAgICAgICAgIGF2ZyA9IHN1bSAvIChzaXplKTtcclxuICAgICAgICAgICAgdGFyZ2V0RGF0YVt2ICogd2lkdGggKyB1XSA9IGltYWdlRGF0YVt2ICogd2lkdGggKyB1XSA+IChhdmcgKyA1KSA/IDAgOiAxO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGNsdXN0ZXIocG9pbnRzLCB0aHJlc2hvbGQsIHByb3BlcnR5KSB7XHJcbiAgICBsZXQgaTsgbGV0IGs7IGxldCB0aGlzQ2x1c3RlcjsgbGV0IHBvaW50OyBjb25zdFxyXG4gICAgICAgIGNsdXN0ZXJzID0gW107XHJcblxyXG4gICAgaWYgKCFwcm9wZXJ0eSkge1xyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxyXG4gICAgICAgIHByb3BlcnR5ID0gJ3JhZCc7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gYWRkVG9DbHVzdGVyKG5ld1BvaW50KSB7XHJcbiAgICAgICAgbGV0IGZvdW5kID0gZmFsc2U7XHJcbiAgICAgICAgZm9yIChrID0gMDsgayA8IGNsdXN0ZXJzLmxlbmd0aDsgaysrKSB7XHJcbiAgICAgICAgICAgIHRoaXNDbHVzdGVyID0gY2x1c3RlcnNba107XHJcbiAgICAgICAgICAgIGlmICh0aGlzQ2x1c3Rlci5maXRzKG5ld1BvaW50KSkge1xyXG4gICAgICAgICAgICAgICAgdGhpc0NsdXN0ZXIuYWRkKG5ld1BvaW50KTtcclxuICAgICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZm91bmQ7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gaXRlcmF0ZSBvdmVyIGVhY2ggY2xvdWRcclxuICAgIGZvciAoaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBwb2ludCA9IENsdXN0ZXIyLmNyZWF0ZVBvaW50KHBvaW50c1tpXSwgaSwgcHJvcGVydHkpO1xyXG4gICAgICAgIGlmICghYWRkVG9DbHVzdGVyKHBvaW50KSkge1xyXG4gICAgICAgICAgICBjbHVzdGVycy5wdXNoKENsdXN0ZXIyLmNyZWF0ZShwb2ludCwgdGhyZXNob2xkKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNsdXN0ZXJzO1xyXG59XHJcblxyXG5leHBvcnQgY29uc3QgVHJhY2VyID0ge1xyXG4gICAgdHJhY2UocG9pbnRzLCB2ZWMpIHtcclxuICAgICAgICBsZXQgaXRlcmF0aW9uO1xyXG4gICAgICAgIGNvbnN0IG1heEl0ZXJhdGlvbnMgPSAxMDtcclxuICAgICAgICBsZXQgdG9wID0gW107XHJcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xyXG4gICAgICAgIGxldCBjZW50ZXJQb3MgPSAwO1xyXG4gICAgICAgIGxldCBjdXJyZW50UG9zID0gMDtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gdHJhY2UoaWR4LCBmb3J3YXJkKSB7XHJcbiAgICAgICAgICAgIGxldCB0bztcclxuICAgICAgICAgICAgbGV0IHRvSWR4O1xyXG4gICAgICAgICAgICBsZXQgcHJlZGljdGVkUG9zO1xyXG4gICAgICAgICAgICBjb25zdCB0aHJlc2hvbGRYID0gMTtcclxuICAgICAgICAgICAgY29uc3QgdGhyZXNob2xkWSA9IE1hdGguYWJzKHZlY1sxXSAvIDEwKTtcclxuICAgICAgICAgICAgbGV0IGZvdW5kID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiBtYXRjaChwb3MsIHByZWRpY3RlZCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHBvcy54ID4gKHByZWRpY3RlZC54IC0gdGhyZXNob2xkWClcclxuICAgICAgICAgICAgICAgICAgICAgICAgJiYgcG9zLnggPCAocHJlZGljdGVkLnggKyB0aHJlc2hvbGRYKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAmJiBwb3MueSA+IChwcmVkaWN0ZWQueSAtIHRocmVzaG9sZFkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICYmIHBvcy55IDwgKHByZWRpY3RlZC55ICsgdGhyZXNob2xkWSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gY2hlY2sgaWYgdGhlIG5leHQgaW5kZXggaXMgd2l0aGluIHRoZSB2ZWMgc3BlY2lmaWNhdGlvbnNcclxuICAgICAgICAgICAgLy8gaWYgbm90LCBjaGVjayBhcyBsb25nIGFzIHRoZSB0aHJlc2hvbGQgaXMgbWV0XHJcblxyXG4gICAgICAgICAgICBjb25zdCBmcm9tID0gcG9pbnRzW2lkeF07XHJcbiAgICAgICAgICAgIGlmIChmb3J3YXJkKSB7XHJcbiAgICAgICAgICAgICAgICBwcmVkaWN0ZWRQb3MgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeDogZnJvbS54ICsgdmVjWzBdLFxyXG4gICAgICAgICAgICAgICAgICAgIHk6IGZyb20ueSArIHZlY1sxXSxcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBwcmVkaWN0ZWRQb3MgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeDogZnJvbS54IC0gdmVjWzBdLFxyXG4gICAgICAgICAgICAgICAgICAgIHk6IGZyb20ueSAtIHZlY1sxXSxcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRvSWR4ID0gZm9yd2FyZCA/IGlkeCArIDEgOiBpZHggLSAxO1xyXG4gICAgICAgICAgICB0byA9IHBvaW50c1t0b0lkeF07XHJcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25kLWFzc2lnblxyXG4gICAgICAgICAgICB3aGlsZSAodG8gJiYgKGZvdW5kID0gbWF0Y2godG8sIHByZWRpY3RlZFBvcykpICE9PSB0cnVlICYmIChNYXRoLmFicyh0by55IC0gZnJvbS55KSA8IHZlY1sxXSkpIHtcclxuICAgICAgICAgICAgICAgIHRvSWR4ID0gZm9yd2FyZCA/IHRvSWR4ICsgMSA6IHRvSWR4IC0gMTtcclxuICAgICAgICAgICAgICAgIHRvID0gcG9pbnRzW3RvSWR4XTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGZvdW5kID8gdG9JZHggOiBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yIChpdGVyYXRpb24gPSAwOyBpdGVyYXRpb24gPCBtYXhJdGVyYXRpb25zOyBpdGVyYXRpb24rKykge1xyXG4gICAgICAgICAgICAvLyByYW5kb21seSBzZWxlY3QgcG9pbnQgdG8gc3RhcnQgd2l0aFxyXG4gICAgICAgICAgICBjZW50ZXJQb3MgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBwb2ludHMubGVuZ3RoKTtcclxuXHJcbiAgICAgICAgICAgIC8vIHRyYWNlIGZvcndhcmRcclxuICAgICAgICAgICAgdG9wID0gW107XHJcbiAgICAgICAgICAgIGN1cnJlbnRQb3MgPSBjZW50ZXJQb3M7XHJcbiAgICAgICAgICAgIHRvcC5wdXNoKHBvaW50c1tjdXJyZW50UG9zXSk7XHJcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25kLWFzc2lnblxyXG4gICAgICAgICAgICB3aGlsZSAoKGN1cnJlbnRQb3MgPSB0cmFjZShjdXJyZW50UG9zLCB0cnVlKSkgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHRvcC5wdXNoKHBvaW50c1tjdXJyZW50UG9zXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGNlbnRlclBvcyA+IDApIHtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRQb3MgPSBjZW50ZXJQb3M7XHJcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uZC1hc3NpZ25cclxuICAgICAgICAgICAgICAgIHdoaWxlICgoY3VycmVudFBvcyA9IHRyYWNlKGN1cnJlbnRQb3MsIGZhbHNlKSkgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICB0b3AucHVzaChwb2ludHNbY3VycmVudFBvc10pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAodG9wLmxlbmd0aCA+IHJlc3VsdC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRvcDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfSxcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBESUxBVEUgPSAxO1xyXG5leHBvcnQgY29uc3QgRVJPREUgPSAyO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGRpbGF0ZShpbkltYWdlV3JhcHBlciwgb3V0SW1hZ2VXcmFwcGVyKSB7XHJcbiAgICBsZXQgdjtcclxuICAgIGxldCB1O1xyXG4gICAgY29uc3QgaW5JbWFnZURhdGEgPSBpbkltYWdlV3JhcHBlci5kYXRhO1xyXG4gICAgY29uc3Qgb3V0SW1hZ2VEYXRhID0gb3V0SW1hZ2VXcmFwcGVyLmRhdGE7XHJcbiAgICBjb25zdCBoZWlnaHQgPSBpbkltYWdlV3JhcHBlci5zaXplLnk7XHJcbiAgICBjb25zdCB3aWR0aCA9IGluSW1hZ2VXcmFwcGVyLnNpemUueDtcclxuICAgIGxldCBzdW07XHJcbiAgICBsZXQgeVN0YXJ0MTtcclxuICAgIGxldCB5U3RhcnQyO1xyXG4gICAgbGV0IHhTdGFydDE7XHJcbiAgICBsZXQgeFN0YXJ0MjtcclxuXHJcbiAgICBmb3IgKHYgPSAxOyB2IDwgaGVpZ2h0IC0gMTsgdisrKSB7XHJcbiAgICAgICAgZm9yICh1ID0gMTsgdSA8IHdpZHRoIC0gMTsgdSsrKSB7XHJcbiAgICAgICAgICAgIHlTdGFydDEgPSB2IC0gMTtcclxuICAgICAgICAgICAgeVN0YXJ0MiA9IHYgKyAxO1xyXG4gICAgICAgICAgICB4U3RhcnQxID0gdSAtIDE7XHJcbiAgICAgICAgICAgIHhTdGFydDIgPSB1ICsgMTtcclxuICAgICAgICAgICAgc3VtID0gaW5JbWFnZURhdGFbeVN0YXJ0MSAqIHdpZHRoICsgeFN0YXJ0MV0gKyBpbkltYWdlRGF0YVt5U3RhcnQxICogd2lkdGggKyB4U3RhcnQyXVxyXG4gICAgICAgICAgICArIGluSW1hZ2VEYXRhW3YgKiB3aWR0aCArIHVdXHJcbiAgICAgICAgICAgICsgaW5JbWFnZURhdGFbeVN0YXJ0MiAqIHdpZHRoICsgeFN0YXJ0MV0gKyBpbkltYWdlRGF0YVt5U3RhcnQyICogd2lkdGggKyB4U3RhcnQyXTtcclxuICAgICAgICAgICAgb3V0SW1hZ2VEYXRhW3YgKiB3aWR0aCArIHVdID0gc3VtID4gMCA/IDEgOiAwO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGVyb2RlKGluSW1hZ2VXcmFwcGVyLCBvdXRJbWFnZVdyYXBwZXIpIHtcclxuICAgIGxldCB2O1xyXG4gICAgbGV0IHU7XHJcbiAgICBjb25zdCBpbkltYWdlRGF0YSA9IGluSW1hZ2VXcmFwcGVyLmRhdGE7XHJcbiAgICBjb25zdCBvdXRJbWFnZURhdGEgPSBvdXRJbWFnZVdyYXBwZXIuZGF0YTtcclxuICAgIGNvbnN0IGhlaWdodCA9IGluSW1hZ2VXcmFwcGVyLnNpemUueTtcclxuICAgIGNvbnN0IHdpZHRoID0gaW5JbWFnZVdyYXBwZXIuc2l6ZS54O1xyXG4gICAgbGV0IHN1bTtcclxuICAgIGxldCB5U3RhcnQxO1xyXG4gICAgbGV0IHlTdGFydDI7XHJcbiAgICBsZXQgeFN0YXJ0MTtcclxuICAgIGxldCB4U3RhcnQyO1xyXG5cclxuICAgIGZvciAodiA9IDE7IHYgPCBoZWlnaHQgLSAxOyB2KyspIHtcclxuICAgICAgICBmb3IgKHUgPSAxOyB1IDwgd2lkdGggLSAxOyB1KyspIHtcclxuICAgICAgICAgICAgeVN0YXJ0MSA9IHYgLSAxO1xyXG4gICAgICAgICAgICB5U3RhcnQyID0gdiArIDE7XHJcbiAgICAgICAgICAgIHhTdGFydDEgPSB1IC0gMTtcclxuICAgICAgICAgICAgeFN0YXJ0MiA9IHUgKyAxO1xyXG4gICAgICAgICAgICBzdW0gPSBpbkltYWdlRGF0YVt5U3RhcnQxICogd2lkdGggKyB4U3RhcnQxXSArIGluSW1hZ2VEYXRhW3lTdGFydDEgKiB3aWR0aCArIHhTdGFydDJdXHJcbiAgICAgICAgICAgICsgaW5JbWFnZURhdGFbdiAqIHdpZHRoICsgdV1cclxuICAgICAgICAgICAgKyBpbkltYWdlRGF0YVt5U3RhcnQyICogd2lkdGggKyB4U3RhcnQxXSArIGluSW1hZ2VEYXRhW3lTdGFydDIgKiB3aWR0aCArIHhTdGFydDJdO1xyXG4gICAgICAgICAgICBvdXRJbWFnZURhdGFbdiAqIHdpZHRoICsgdV0gPSBzdW0gPT09IDUgPyAxIDogMDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBzdWJ0cmFjdChhSW1hZ2VXcmFwcGVyLCBiSW1hZ2VXcmFwcGVyLCByZXN1bHRJbWFnZVdyYXBwZXIpIHtcclxuICAgIGlmICghcmVzdWx0SW1hZ2VXcmFwcGVyKSB7XHJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXHJcbiAgICAgICAgcmVzdWx0SW1hZ2VXcmFwcGVyID0gYUltYWdlV3JhcHBlcjtcclxuICAgIH1cclxuICAgIGxldCB7IGxlbmd0aCB9ID0gYUltYWdlV3JhcHBlci5kYXRhO1xyXG4gICAgY29uc3QgYUltYWdlRGF0YSA9IGFJbWFnZVdyYXBwZXIuZGF0YTtcclxuICAgIGNvbnN0IGJJbWFnZURhdGEgPSBiSW1hZ2VXcmFwcGVyLmRhdGE7XHJcbiAgICBjb25zdCBjSW1hZ2VEYXRhID0gcmVzdWx0SW1hZ2VXcmFwcGVyLmRhdGE7XHJcblxyXG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XHJcbiAgICAgICAgY0ltYWdlRGF0YVtsZW5ndGhdID0gYUltYWdlRGF0YVtsZW5ndGhdIC0gYkltYWdlRGF0YVtsZW5ndGhdO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gYml0d2lzZU9yKGFJbWFnZVdyYXBwZXIsIGJJbWFnZVdyYXBwZXIsIHJlc3VsdEltYWdlV3JhcHBlcikge1xyXG4gICAgaWYgKCFyZXN1bHRJbWFnZVdyYXBwZXIpIHtcclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cclxuICAgICAgICByZXN1bHRJbWFnZVdyYXBwZXIgPSBhSW1hZ2VXcmFwcGVyO1xyXG4gICAgfVxyXG4gICAgbGV0IHsgbGVuZ3RoIH0gPSBhSW1hZ2VXcmFwcGVyLmRhdGE7XHJcbiAgICBjb25zdCBhSW1hZ2VEYXRhID0gYUltYWdlV3JhcHBlci5kYXRhO1xyXG4gICAgY29uc3QgYkltYWdlRGF0YSA9IGJJbWFnZVdyYXBwZXIuZGF0YTtcclxuICAgIGNvbnN0IGNJbWFnZURhdGEgPSByZXN1bHRJbWFnZVdyYXBwZXIuZGF0YTtcclxuXHJcbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcclxuICAgICAgICBjSW1hZ2VEYXRhW2xlbmd0aF0gPSBhSW1hZ2VEYXRhW2xlbmd0aF0gfHwgYkltYWdlRGF0YVtsZW5ndGhdO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gY291bnROb25aZXJvKGltYWdlV3JhcHBlcikge1xyXG4gICAgbGV0IHsgbGVuZ3RoIH0gPSBpbWFnZVdyYXBwZXIuZGF0YTtcclxuICAgIGNvbnN0IHsgZGF0YSB9ID0gaW1hZ2VXcmFwcGVyO1xyXG4gICAgbGV0IHN1bSA9IDA7XHJcblxyXG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XHJcbiAgICAgICAgc3VtICs9IGRhdGFbbGVuZ3RoXTtcclxuICAgIH1cclxuICAgIHJldHVybiBzdW07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB0b3BHZW5lcmljKGxpc3QsIHRvcCwgc2NvcmVGdW5jKSB7XHJcbiAgICBsZXQgaTsgbGV0IG1pbklkeCA9IDA7IGxldCBtaW4gPSAwOyBjb25zdCBxdWV1ZSA9IFtdOyBsZXQgc2NvcmU7IGxldCBoaXQ7IGxldFxyXG4gICAgICAgIHBvcztcclxuXHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgdG9wOyBpKyspIHtcclxuICAgICAgICBxdWV1ZVtpXSA9IHtcclxuICAgICAgICAgICAgc2NvcmU6IDAsXHJcbiAgICAgICAgICAgIGl0ZW06IG51bGwsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHNjb3JlID0gc2NvcmVGdW5jLmFwcGx5KHRoaXMsIFtsaXN0W2ldXSk7XHJcbiAgICAgICAgaWYgKHNjb3JlID4gbWluKSB7XHJcbiAgICAgICAgICAgIGhpdCA9IHF1ZXVlW21pbklkeF07XHJcbiAgICAgICAgICAgIGhpdC5zY29yZSA9IHNjb3JlO1xyXG4gICAgICAgICAgICBoaXQuaXRlbSA9IGxpc3RbaV07XHJcbiAgICAgICAgICAgIG1pbiA9IE51bWJlci5NQVhfVkFMVUU7XHJcbiAgICAgICAgICAgIGZvciAocG9zID0gMDsgcG9zIDwgdG9wOyBwb3MrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHF1ZXVlW3Bvc10uc2NvcmUgPCBtaW4pIHtcclxuICAgICAgICAgICAgICAgICAgICBtaW4gPSBxdWV1ZVtwb3NdLnNjb3JlO1xyXG4gICAgICAgICAgICAgICAgICAgIG1pbklkeCA9IHBvcztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcXVldWU7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBncmF5QXJyYXlGcm9tSW1hZ2UoaHRtbEltYWdlLCBvZmZzZXRYLCBjdHgsIGFycmF5KSB7XHJcbiAgICBjdHguZHJhd0ltYWdlKGh0bWxJbWFnZSwgb2Zmc2V0WCwgMCwgaHRtbEltYWdlLndpZHRoLCBodG1sSW1hZ2UuaGVpZ2h0KTtcclxuICAgIGNvbnN0IGN0eERhdGEgPSBjdHguZ2V0SW1hZ2VEYXRhKG9mZnNldFgsIDAsIGh0bWxJbWFnZS53aWR0aCwgaHRtbEltYWdlLmhlaWdodCkuZGF0YTtcclxuICAgIGNvbXB1dGVHcmF5KGN0eERhdGEsIGFycmF5KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdyYXlBcnJheUZyb21Db250ZXh0KGN0eCwgc2l6ZSwgb2Zmc2V0LCBhcnJheSkge1xyXG4gICAgY29uc3QgY3R4RGF0YSA9IGN0eC5nZXRJbWFnZURhdGEob2Zmc2V0LngsIG9mZnNldC55LCBzaXplLngsIHNpemUueSkuZGF0YTtcclxuICAgIGNvbXB1dGVHcmF5KGN0eERhdGEsIGFycmF5KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdyYXlBbmRIYWxmU2FtcGxlRnJvbUNhbnZhc0RhdGEoY2FudmFzRGF0YSwgc2l6ZSwgb3V0QXJyYXkpIHtcclxuICAgIGxldCB0b3BSb3dJZHggPSAwO1xyXG4gICAgbGV0IGJvdHRvbVJvd0lkeCA9IHNpemUueDtcclxuICAgIGNvbnN0IGVuZElkeCA9IE1hdGguZmxvb3IoY2FudmFzRGF0YS5sZW5ndGggLyA0KTtcclxuICAgIGNvbnN0IG91dFdpZHRoID0gc2l6ZS54IC8gMjtcclxuICAgIGxldCBvdXRJbWdJZHggPSAwO1xyXG4gICAgY29uc3QgaW5XaWR0aCA9IHNpemUueDtcclxuICAgIGxldCBpO1xyXG5cclxuICAgIHdoaWxlIChib3R0b21Sb3dJZHggPCBlbmRJZHgpIHtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgb3V0V2lkdGg7IGkrKykge1xyXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cclxuICAgICAgICAgICAgb3V0QXJyYXlbb3V0SW1nSWR4XSA9IChcclxuICAgICAgICAgICAgICAgICgwLjI5OSAqIGNhbnZhc0RhdGFbdG9wUm93SWR4ICogNCArIDBdXHJcbiAgICAgICAgICAgICAgICAgKyAwLjU4NyAqIGNhbnZhc0RhdGFbdG9wUm93SWR4ICogNCArIDFdXHJcbiAgICAgICAgICAgICAgICAgKyAwLjExNCAqIGNhbnZhc0RhdGFbdG9wUm93SWR4ICogNCArIDJdKVxyXG4gICAgICAgICAgICAgICAgKyAoMC4yOTkgKiBjYW52YXNEYXRhWyh0b3BSb3dJZHggKyAxKSAqIDQgKyAwXVxyXG4gICAgICAgICAgICAgICAgICsgMC41ODcgKiBjYW52YXNEYXRhWyh0b3BSb3dJZHggKyAxKSAqIDQgKyAxXVxyXG4gICAgICAgICAgICAgICAgICsgMC4xMTQgKiBjYW52YXNEYXRhWyh0b3BSb3dJZHggKyAxKSAqIDQgKyAyXSlcclxuICAgICAgICAgICAgICAgICsgKDAuMjk5ICogY2FudmFzRGF0YVsoYm90dG9tUm93SWR4KSAqIDQgKyAwXVxyXG4gICAgICAgICAgICAgICAgICsgMC41ODcgKiBjYW52YXNEYXRhWyhib3R0b21Sb3dJZHgpICogNCArIDFdXHJcbiAgICAgICAgICAgICAgICAgKyAwLjExNCAqIGNhbnZhc0RhdGFbKGJvdHRvbVJvd0lkeCkgKiA0ICsgMl0pXHJcbiAgICAgICAgICAgICAgICArICgwLjI5OSAqIGNhbnZhc0RhdGFbKGJvdHRvbVJvd0lkeCArIDEpICogNCArIDBdXHJcbiAgICAgICAgICAgICAgICAgKyAwLjU4NyAqIGNhbnZhc0RhdGFbKGJvdHRvbVJvd0lkeCArIDEpICogNCArIDFdXHJcbiAgICAgICAgICAgICAgICAgKyAwLjExNCAqIGNhbnZhc0RhdGFbKGJvdHRvbVJvd0lkeCArIDEpICogNCArIDJdKSkgLyA0O1xyXG4gICAgICAgICAgICBvdXRJbWdJZHgrKztcclxuICAgICAgICAgICAgdG9wUm93SWR4ICs9IDI7XHJcbiAgICAgICAgICAgIGJvdHRvbVJvd0lkeCArPSAyO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0b3BSb3dJZHggKz0gaW5XaWR0aDtcclxuICAgICAgICBib3R0b21Sb3dJZHggKz0gaW5XaWR0aDtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVHcmF5KGltYWdlRGF0YSwgb3V0QXJyYXksIGNvbmZpZykge1xyXG4gICAgY29uc3QgbCA9IChpbWFnZURhdGEubGVuZ3RoIC8gNCkgfCAwO1xyXG4gICAgY29uc3Qgc2luZ2xlQ2hhbm5lbCA9IGNvbmZpZyAmJiBjb25maWcuc2luZ2xlQ2hhbm5lbCA9PT0gdHJ1ZTtcclxuXHJcbiAgICBpZiAoc2luZ2xlQ2hhbm5lbCkge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxyXG4gICAgICAgICAgICBvdXRBcnJheVtpXSA9IGltYWdlRGF0YVtpICogNCArIDBdO1xyXG4gICAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXHJcbiAgICAgICAgICAgIG91dEFycmF5W2ldID0gMC4yOTkgKiBpbWFnZURhdGFbaSAqIDQgKyAwXSArIDAuNTg3ICogaW1hZ2VEYXRhW2kgKiA0ICsgMV0gKyAwLjExNCAqIGltYWdlRGF0YVtpICogNCArIDJdO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGxvYWRJbWFnZUFycmF5KHNyYywgY2FsbGJhY2ssIGNhbnZhcyA9IGRvY3VtZW50ICYmIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpKSB7XHJcbiAgICBjb25zdCBpbWcgPSBuZXcgSW1hZ2UoKTtcclxuICAgIGltZy5jYWxsYmFjayA9IGNhbGxiYWNrO1xyXG4gICAgaW1nLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cclxuICAgICAgICBjYW52YXMud2lkdGggPSB0aGlzLndpZHRoO1xyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxyXG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSB0aGlzLmhlaWdodDtcclxuICAgICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcclxuICAgICAgICBjdHguZHJhd0ltYWdlKHRoaXMsIDAsIDApO1xyXG4gICAgICAgIGNvbnN0IGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy53aWR0aCAqIHRoaXMuaGVpZ2h0KTtcclxuICAgICAgICBjdHguZHJhd0ltYWdlKHRoaXMsIDAsIDApO1xyXG4gICAgICAgIGNvbnN0IHsgZGF0YSB9ID0gY3R4LmdldEltYWdlRGF0YSgwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XHJcbiAgICAgICAgY29tcHV0ZUdyYXkoZGF0YSwgYXJyYXkpO1xyXG4gICAgICAgIHRoaXMuY2FsbGJhY2soYXJyYXksIHtcclxuICAgICAgICAgICAgeDogdGhpcy53aWR0aCxcclxuICAgICAgICAgICAgeTogdGhpcy5oZWlnaHQsXHJcbiAgICAgICAgfSwgdGhpcyk7XHJcbiAgICB9O1xyXG4gICAgaW1nLnNyYyA9IHNyYztcclxufVxyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSBpbkltZyB7SW1hZ2VXcmFwcGVyfSBpbnB1dCBpbWFnZSB0byBiZSBzYW1wbGVkXHJcbiAqIEBwYXJhbSBvdXRJbWcge0ltYWdlV3JhcHBlcn0gdG8gYmUgc3RvcmVkIGluXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaGFsZlNhbXBsZShpbkltZ1dyYXBwZXIsIG91dEltZ1dyYXBwZXIpIHtcclxuICAgIGNvbnN0IGluSW1nID0gaW5JbWdXcmFwcGVyLmRhdGE7XHJcbiAgICBjb25zdCBpbldpZHRoID0gaW5JbWdXcmFwcGVyLnNpemUueDtcclxuICAgIGNvbnN0IG91dEltZyA9IG91dEltZ1dyYXBwZXIuZGF0YTtcclxuICAgIGxldCB0b3BSb3dJZHggPSAwO1xyXG4gICAgbGV0IGJvdHRvbVJvd0lkeCA9IGluV2lkdGg7XHJcbiAgICBjb25zdCBlbmRJZHggPSBpbkltZy5sZW5ndGg7XHJcbiAgICBjb25zdCBvdXRXaWR0aCA9IGluV2lkdGggLyAyO1xyXG4gICAgbGV0IG91dEltZ0lkeCA9IDA7XHJcbiAgICB3aGlsZSAoYm90dG9tUm93SWR4IDwgZW5kSWR4KSB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRXaWR0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIG91dEltZ1tvdXRJbWdJZHhdID0gTWF0aC5mbG9vcihcclxuICAgICAgICAgICAgICAgIChpbkltZ1t0b3BSb3dJZHhdICsgaW5JbWdbdG9wUm93SWR4ICsgMV0gKyBpbkltZ1tib3R0b21Sb3dJZHhdICsgaW5JbWdbYm90dG9tUm93SWR4ICsgMV0pIC8gNCxcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgb3V0SW1nSWR4Kys7XHJcbiAgICAgICAgICAgIHRvcFJvd0lkeCArPSAyO1xyXG4gICAgICAgICAgICBib3R0b21Sb3dJZHggKz0gMjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdG9wUm93SWR4ICs9IGluV2lkdGg7XHJcbiAgICAgICAgYm90dG9tUm93SWR4ICs9IGluV2lkdGg7XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBoc3YycmdiKGhzdiwgcmdiID0gWzAsIDAsIDBdKSB7XHJcbiAgICBjb25zdCBoID0gaHN2WzBdO1xyXG4gICAgY29uc3QgcyA9IGhzdlsxXTtcclxuICAgIGNvbnN0IHYgPSBoc3ZbMl07XHJcbiAgICBjb25zdCBjID0gdiAqIHM7XHJcbiAgICBjb25zdCB4ID0gYyAqICgxIC0gTWF0aC5hYnMoKGggLyA2MCkgJSAyIC0gMSkpO1xyXG4gICAgY29uc3QgbSA9IHYgLSBjO1xyXG4gICAgbGV0IHIgPSAwO1xyXG4gICAgbGV0IGcgPSAwO1xyXG4gICAgbGV0IGIgPSAwO1xyXG5cclxuICAgIGlmIChoIDwgNjApIHtcclxuICAgICAgICByID0gYztcclxuICAgICAgICBnID0geDtcclxuICAgIH0gZWxzZSBpZiAoaCA8IDEyMCkge1xyXG4gICAgICAgIHIgPSB4O1xyXG4gICAgICAgIGcgPSBjO1xyXG4gICAgfSBlbHNlIGlmIChoIDwgMTgwKSB7XHJcbiAgICAgICAgZyA9IGM7XHJcbiAgICAgICAgYiA9IHg7XHJcbiAgICB9IGVsc2UgaWYgKGggPCAyNDApIHtcclxuICAgICAgICBnID0geDtcclxuICAgICAgICBiID0gYztcclxuICAgIH0gZWxzZSBpZiAoaCA8IDMwMCkge1xyXG4gICAgICAgIHIgPSB4O1xyXG4gICAgICAgIGIgPSBjO1xyXG4gICAgfSBlbHNlIGlmIChoIDwgMzYwKSB7XHJcbiAgICAgICAgciA9IGM7XHJcbiAgICAgICAgYiA9IHg7XHJcbiAgICB9XHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cclxuICAgIHJnYlswXSA9ICgociArIG0pICogMjU1KSB8IDA7XHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cclxuICAgIHJnYlsxXSA9ICgoZyArIG0pICogMjU1KSB8IDA7XHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cclxuICAgIHJnYlsyXSA9ICgoYiArIG0pICogMjU1KSB8IDA7XHJcbiAgICByZXR1cm4gcmdiO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX2NvbXB1dGVEaXZpc29ycyhuKSB7XHJcbiAgICBjb25zdCBsYXJnZURpdmlzb3JzID0gW107XHJcbiAgICBjb25zdCBkaXZpc29ycyA9IFtdO1xyXG5cclxuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgTWF0aC5zcXJ0KG4pICsgMTsgaSsrKSB7XHJcbiAgICAgICAgaWYgKG4gJSBpID09PSAwKSB7XHJcbiAgICAgICAgICAgIGRpdmlzb3JzLnB1c2goaSk7XHJcbiAgICAgICAgICAgIGlmIChpICE9PSBuIC8gaSkge1xyXG4gICAgICAgICAgICAgICAgbGFyZ2VEaXZpc29ycy51bnNoaWZ0KE1hdGguZmxvb3IobiAvIGkpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBkaXZpc29ycy5jb25jYXQobGFyZ2VEaXZpc29ycyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9jb21wdXRlSW50ZXJzZWN0aW9uKGFycjEsIGFycjIpIHtcclxuICAgIGxldCBpID0gMDtcclxuICAgIGxldCBqID0gMDtcclxuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xyXG5cclxuICAgIHdoaWxlIChpIDwgYXJyMS5sZW5ndGggJiYgaiA8IGFycjIubGVuZ3RoKSB7XHJcbiAgICAgICAgaWYgKGFycjFbaV0gPT09IGFycjJbal0pIHtcclxuICAgICAgICAgICAgcmVzdWx0LnB1c2goYXJyMVtpXSk7XHJcbiAgICAgICAgICAgIGkrKztcclxuICAgICAgICAgICAgaisrO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoYXJyMVtpXSA+IGFycjJbal0pIHtcclxuICAgICAgICAgICAgaisrO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGkrKztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlUGF0Y2hTaXplKHBhdGNoU2l6ZSwgaW1nU2l6ZSkge1xyXG4gICAgY29uc3QgZGl2aXNvcnNYID0gX2NvbXB1dGVEaXZpc29ycyhpbWdTaXplLngpO1xyXG4gICAgY29uc3QgZGl2aXNvcnNZID0gX2NvbXB1dGVEaXZpc29ycyhpbWdTaXplLnkpO1xyXG4gICAgY29uc3Qgd2lkZVNpZGUgPSBNYXRoLm1heChpbWdTaXplLngsIGltZ1NpemUueSk7XHJcbiAgICBjb25zdCBjb21tb24gPSBfY29tcHV0ZUludGVyc2VjdGlvbihkaXZpc29yc1gsIGRpdmlzb3JzWSk7XHJcbiAgICBjb25zdCBuck9mUGF0Y2hlc0xpc3QgPSBbOCwgMTAsIDE1LCAyMCwgMzIsIDYwLCA4MF07XHJcbiAgICBjb25zdCBuck9mUGF0Y2hlc01hcCA9IHtcclxuICAgICAgICAneC1zbWFsbCc6IDUsXHJcbiAgICAgICAgc21hbGw6IDQsXHJcbiAgICAgICAgbWVkaXVtOiAzLFxyXG4gICAgICAgIGxhcmdlOiAyLFxyXG4gICAgICAgICd4LWxhcmdlJzogMSxcclxuICAgIH07XHJcbiAgICBjb25zdCBuck9mUGF0Y2hlc0lkeCA9IG5yT2ZQYXRjaGVzTWFwW3BhdGNoU2l6ZV0gfHwgbnJPZlBhdGNoZXNNYXAubWVkaXVtO1xyXG4gICAgY29uc3QgbnJPZlBhdGNoZXMgPSBuck9mUGF0Y2hlc0xpc3RbbnJPZlBhdGNoZXNJZHhdO1xyXG4gICAgY29uc3QgZGVzaXJlZFBhdGNoU2l6ZSA9IE1hdGguZmxvb3Iod2lkZVNpZGUgLyBuck9mUGF0Y2hlcyk7XHJcbiAgICBsZXQgb3B0aW1hbFBhdGNoU2l6ZTtcclxuXHJcbiAgICBmdW5jdGlvbiBmaW5kUGF0Y2hTaXplRm9yRGl2aXNvcnMoZGl2aXNvcnMpIHtcclxuICAgICAgICBsZXQgaSA9IDA7XHJcbiAgICAgICAgbGV0IGZvdW5kID0gZGl2aXNvcnNbTWF0aC5mbG9vcihkaXZpc29ycy5sZW5ndGggLyAyKV07XHJcblxyXG4gICAgICAgIHdoaWxlIChpIDwgKGRpdmlzb3JzLmxlbmd0aCAtIDEpICYmIGRpdmlzb3JzW2ldIDwgZGVzaXJlZFBhdGNoU2l6ZSkge1xyXG4gICAgICAgICAgICBpKys7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpID4gMCkge1xyXG4gICAgICAgICAgICBpZiAoTWF0aC5hYnMoZGl2aXNvcnNbaV0gLSBkZXNpcmVkUGF0Y2hTaXplKSA+IE1hdGguYWJzKGRpdmlzb3JzW2kgLSAxXSAtIGRlc2lyZWRQYXRjaFNpemUpKSB7XHJcbiAgICAgICAgICAgICAgICBmb3VuZCA9IGRpdmlzb3JzW2kgLSAxXTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGZvdW5kID0gZGl2aXNvcnNbaV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGRlc2lyZWRQYXRjaFNpemUgLyBmb3VuZCA8IG5yT2ZQYXRjaGVzTGlzdFtuck9mUGF0Y2hlc0lkeCArIDFdIC8gbnJPZlBhdGNoZXNMaXN0W25yT2ZQYXRjaGVzSWR4XVxyXG4gICAgICAgICAgICAmJiBkZXNpcmVkUGF0Y2hTaXplIC8gZm91bmQgPiBuck9mUGF0Y2hlc0xpc3RbbnJPZlBhdGNoZXNJZHggLSAxXSAvIG5yT2ZQYXRjaGVzTGlzdFtuck9mUGF0Y2hlc0lkeF0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHsgeDogZm91bmQsIHk6IGZvdW5kIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIG9wdGltYWxQYXRjaFNpemUgPSBmaW5kUGF0Y2hTaXplRm9yRGl2aXNvcnMoY29tbW9uKTtcclxuICAgIGlmICghb3B0aW1hbFBhdGNoU2l6ZSkge1xyXG4gICAgICAgIG9wdGltYWxQYXRjaFNpemUgPSBmaW5kUGF0Y2hTaXplRm9yRGl2aXNvcnMoX2NvbXB1dGVEaXZpc29ycyh3aWRlU2lkZSkpO1xyXG4gICAgICAgIGlmICghb3B0aW1hbFBhdGNoU2l6ZSkge1xyXG4gICAgICAgICAgICBvcHRpbWFsUGF0Y2hTaXplID0gZmluZFBhdGNoU2l6ZUZvckRpdmlzb3JzKChfY29tcHV0ZURpdmlzb3JzKGRlc2lyZWRQYXRjaFNpemUgKiBuck9mUGF0Y2hlcykpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gb3B0aW1hbFBhdGNoU2l6ZTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9wYXJzZUNTU0RpbWVuc2lvblZhbHVlcyh2YWx1ZSkge1xyXG4gICAgY29uc3QgZGltZW5zaW9uID0ge1xyXG4gICAgICAgIHZhbHVlOiBwYXJzZUZsb2F0KHZhbHVlKSxcclxuICAgICAgICB1bml0OiB2YWx1ZS5pbmRleE9mKCclJykgPT09IHZhbHVlLmxlbmd0aCAtIDEgPyAnJScgOiAnJScsXHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiBkaW1lbnNpb247XHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBfZGltZW5zaW9uc0NvbnZlcnRlcnMgPSB7XHJcbiAgICB0b3AoZGltZW5zaW9uLCBjb250ZXh0KSB7XHJcbiAgICAgICAgcmV0dXJuIGRpbWVuc2lvbi51bml0ID09PSAnJScgPyBNYXRoLmZsb29yKGNvbnRleHQuaGVpZ2h0ICogKGRpbWVuc2lvbi52YWx1ZSAvIDEwMCkpIDogbnVsbDtcclxuICAgIH0sXHJcbiAgICByaWdodChkaW1lbnNpb24sIGNvbnRleHQpIHtcclxuICAgICAgICByZXR1cm4gZGltZW5zaW9uLnVuaXQgPT09ICclJyA/IE1hdGguZmxvb3IoY29udGV4dC53aWR0aCAtIChjb250ZXh0LndpZHRoICogKGRpbWVuc2lvbi52YWx1ZSAvIDEwMCkpKSA6IG51bGw7XHJcbiAgICB9LFxyXG4gICAgYm90dG9tKGRpbWVuc2lvbiwgY29udGV4dCkge1xyXG4gICAgICAgIHJldHVybiBkaW1lbnNpb24udW5pdCA9PT0gJyUnID8gTWF0aC5mbG9vcihjb250ZXh0LmhlaWdodCAtIChjb250ZXh0LmhlaWdodCAqIChkaW1lbnNpb24udmFsdWUgLyAxMDApKSkgOiBudWxsO1xyXG4gICAgfSxcclxuICAgIGxlZnQoZGltZW5zaW9uLCBjb250ZXh0KSB7XHJcbiAgICAgICAgcmV0dXJuIGRpbWVuc2lvbi51bml0ID09PSAnJScgPyBNYXRoLmZsb29yKGNvbnRleHQud2lkdGggKiAoZGltZW5zaW9uLnZhbHVlIC8gMTAwKSkgOiBudWxsO1xyXG4gICAgfSxcclxufTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlSW1hZ2VBcmVhKGlucHV0V2lkdGgsIGlucHV0SGVpZ2h0LCBhcmVhKSB7XHJcbiAgICBjb25zdCBjb250ZXh0ID0geyB3aWR0aDogaW5wdXRXaWR0aCwgaGVpZ2h0OiBpbnB1dEhlaWdodCB9O1xyXG5cclxuICAgIGNvbnN0IHBhcnNlZEFyZWEgPSBPYmplY3Qua2V5cyhhcmVhKS5yZWR1Y2UoKHJlc3VsdCwga2V5KSA9PiB7XHJcbiAgICAgICAgY29uc3QgdmFsdWUgPSBhcmVhW2tleV07XHJcbiAgICAgICAgY29uc3QgcGFyc2VkID0gX3BhcnNlQ1NTRGltZW5zaW9uVmFsdWVzKHZhbHVlKTtcclxuICAgICAgICBjb25zdCBjYWxjdWxhdGVkID0gX2RpbWVuc2lvbnNDb252ZXJ0ZXJzW2tleV0ocGFyc2VkLCBjb250ZXh0KTtcclxuXHJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXHJcbiAgICAgICAgcmVzdWx0W2tleV0gPSBjYWxjdWxhdGVkO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9LCB7fSk7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBzeDogcGFyc2VkQXJlYS5sZWZ0LFxyXG4gICAgICAgIHN5OiBwYXJzZWRBcmVhLnRvcCxcclxuICAgICAgICBzdzogcGFyc2VkQXJlYS5yaWdodCAtIHBhcnNlZEFyZWEubGVmdCxcclxuICAgICAgICBzaDogcGFyc2VkQXJlYS5ib3R0b20gLSBwYXJzZWRBcmVhLnRvcCxcclxuICAgIH07XHJcbn1cclxuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwicmVnZW5lcmF0b3ItcnVudGltZVwiKTtcbiIsInZhciBzdXBlclByb3BCYXNlID0gcmVxdWlyZShcIi4vc3VwZXJQcm9wQmFzZS5qc1wiKTtcblxuZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikge1xuICBpZiAodHlwZW9mIFJlZmxlY3QgIT09IFwidW5kZWZpbmVkXCIgJiYgUmVmbGVjdC5nZXQpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IF9nZXQgPSBSZWZsZWN0LmdldDtcbiAgICBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBfZ2V0ID0gZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikge1xuICAgICAgdmFyIGJhc2UgPSBzdXBlclByb3BCYXNlKHRhcmdldCwgcHJvcGVydHkpO1xuICAgICAgaWYgKCFiYXNlKSByZXR1cm47XG4gICAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYmFzZSwgcHJvcGVydHkpO1xuXG4gICAgICBpZiAoZGVzYy5nZXQpIHtcbiAgICAgICAgcmV0dXJuIGRlc2MuZ2V0LmNhbGwocmVjZWl2ZXIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGVzYy52YWx1ZTtcbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIgfHwgdGFyZ2V0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfZ2V0O1xubW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlOyIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlXG4gKiBbbGFuZ3VhZ2UgdHlwZV0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2UtdHlwZXMpXG4gKiBvZiBgT2JqZWN0YC4gKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3Qoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzT2JqZWN0O1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBBcnJheWAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcnJheTtcbiIsImltcG9ydCB7IFhZU2l6ZSB9IGZyb20gJy4uLy4uL3R5cGUtZGVmaW5pdGlvbnMvcXVhZ2dhLmQnO1xyXG5cclxuLy8gVE9ETzogWFlQb3NpdGlvbiBzaG91bGQgYmUgYW4gWFlPYmplY3QsIGJ1dCB0aGF0IGJyZWFrcyBYWURlZmluaXRpb24sIHdoaWNoIGJyZWFrcyBkcmF3UGF0aCgpIGJlbG93LlxyXG5kZWNsYXJlIGludGVyZmFjZSBYWVBvc2l0aW9uIHtcclxuICAgIHg6IG51bWJlcjtcclxuICAgIHk6IG51bWJlcjtcclxufVxyXG5cclxuZGVjbGFyZSBpbnRlcmZhY2UgQ2FudmFzU3R5bGUge1xyXG4gICAgY29sb3I6IHN0cmluZztcclxuICAgIGxpbmVXaWR0aDogbnVtYmVyO1xyXG59XHJcblxyXG4vLyBYWURlZmluaXRpb24gdGVsbHMgdXMgd2hpY2ggY29tcG9uZW50IG9mIGEgZ2l2ZW4gYXJyYXkgb3Igb2JqZWN0IGlzIHRoZSBcIlhcIiBhbmQgd2hpY2ggaXMgdGhlIFwiWVwiLlxyXG4vLyBVc3VhbGx5IHRoaXMgaXMgMCBmb3IgWCBhbmQgMSBmb3IgWSwgYnV0IG1pZ2h0IGJlIHVzZWQgYXMgJ3gnIGZvciB4IGFuZCAneScgZm9yIFkuXHJcbmRlY2xhcmUgaW50ZXJmYWNlIFhZRGVmaW5pdGlvbiB7XHJcbiAgICB4OiBrZXlvZiBYWVBvc2l0aW9uO1xyXG4gICAgeToga2V5b2YgWFlQb3NpdGlvbjtcclxufVxyXG5cclxuZGVjbGFyZSB0eXBlIFBhdGggPSBBcnJheTxYWVBvc2l0aW9uPjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICAgIGRyYXdSZWN0KHBvczogWFlQb3NpdGlvbiwgc2l6ZTogWFlTaXplLCBjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCwgc3R5bGU6IENhbnZhc1N0eWxlKTogdm9pZCB7XHJcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gc3R5bGUuY29sb3I7XHJcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHN0eWxlLmNvbG9yO1xyXG4gICAgICAgIGN0eC5saW5lV2lkdGggPSBzdHlsZS5saW5lV2lkdGggfHwgMTtcclxuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgY3R4LnN0cm9rZVJlY3QocG9zLngsIHBvcy55LCBzaXplLngsIHNpemUueSk7XHJcbiAgICB9LFxyXG4gICAgZHJhd1BhdGgocGF0aDogUGF0aCwgZGVmOiBYWURlZmluaXRpb24sIGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCBzdHlsZTogQ2FudmFzU3R5bGUpOiB2b2lkIHtcclxuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBzdHlsZS5jb2xvcjtcclxuICAgICAgICBjdHguZmlsbFN0eWxlID0gc3R5bGUuY29sb3I7XHJcbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IHN0eWxlLmxpbmVXaWR0aDtcclxuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgY3R4Lm1vdmVUbyhwYXRoWzBdW2RlZi54XSwgcGF0aFswXVtkZWYueV0pO1xyXG4gICAgICAgIGZvciAobGV0IGogPSAxOyBqIDwgcGF0aC5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICBjdHgubGluZVRvKHBhdGhbal1bZGVmLnhdLCBwYXRoW2pdW2RlZi55XSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcclxuICAgICAgICBjdHguc3Ryb2tlKCk7XHJcbiAgICB9LFxyXG4gICAgZHJhd0ltYWdlKGltYWdlRGF0YTogQXJyYXk8bnVtYmVyPiwgc2l6ZTogWFlTaXplLCBjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCk6IGJvb2xlYW4ge1xyXG4gICAgICAgIGNvbnN0IGNhbnZhc0RhdGEgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIHNpemUueCwgc2l6ZS55KTtcclxuICAgICAgICBjb25zdCB7IGRhdGEgfSA9IGNhbnZhc0RhdGE7XHJcbiAgICAgICAgbGV0IGNhbnZhc0RhdGFQb3MgPSBkYXRhLmxlbmd0aDtcclxuICAgICAgICBsZXQgaW1hZ2VEYXRhUG9zID0gaW1hZ2VEYXRhLmxlbmd0aDtcclxuXHJcbiAgICAgICAgaWYgKGNhbnZhc0RhdGFQb3MgLyBpbWFnZURhdGFQb3MgIT09IDQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB3aGlsZSAoaW1hZ2VEYXRhUG9zLS0pIHtcclxuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBpbWFnZURhdGFbaW1hZ2VEYXRhUG9zXTtcclxuICAgICAgICAgICAgZGF0YVstLWNhbnZhc0RhdGFQb3NdID0gMjU1O1xyXG4gICAgICAgICAgICBkYXRhWy0tY2FudmFzRGF0YVBvc10gPSB2YWx1ZTtcclxuICAgICAgICAgICAgZGF0YVstLWNhbnZhc0RhdGFQb3NdID0gdmFsdWU7XHJcbiAgICAgICAgICAgIGRhdGFbLS1jYW52YXNEYXRhUG9zXSA9IHZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjdHgucHV0SW1hZ2VEYXRhKGNhbnZhc0RhdGEsIDAsIDApO1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfSxcclxufTtcclxuIiwidmFyIGJhc2VNZXJnZSA9IHJlcXVpcmUoJy4vX2Jhc2VNZXJnZScpLFxuICAgIGNyZWF0ZUFzc2lnbmVyID0gcmVxdWlyZSgnLi9fY3JlYXRlQXNzaWduZXInKTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmFzc2lnbmAgZXhjZXB0IHRoYXQgaXQgcmVjdXJzaXZlbHkgbWVyZ2VzIG93biBhbmRcbiAqIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzIG9mIHNvdXJjZSBvYmplY3RzIGludG8gdGhlXG4gKiBkZXN0aW5hdGlvbiBvYmplY3QuIFNvdXJjZSBwcm9wZXJ0aWVzIHRoYXQgcmVzb2x2ZSB0byBgdW5kZWZpbmVkYCBhcmVcbiAqIHNraXBwZWQgaWYgYSBkZXN0aW5hdGlvbiB2YWx1ZSBleGlzdHMuIEFycmF5IGFuZCBwbGFpbiBvYmplY3QgcHJvcGVydGllc1xuICogYXJlIG1lcmdlZCByZWN1cnNpdmVseS4gT3RoZXIgb2JqZWN0cyBhbmQgdmFsdWUgdHlwZXMgYXJlIG92ZXJyaWRkZW4gYnlcbiAqIGFzc2lnbm1lbnQuIFNvdXJjZSBvYmplY3RzIGFyZSBhcHBsaWVkIGZyb20gbGVmdCB0byByaWdodC4gU3Vic2VxdWVudFxuICogc291cmNlcyBvdmVyd3JpdGUgcHJvcGVydHkgYXNzaWdubWVudHMgb2YgcHJldmlvdXMgc291cmNlcy5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuNS4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0gey4uLk9iamVjdH0gW3NvdXJjZXNdIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7XG4gKiAgICdhJzogW3sgJ2InOiAyIH0sIHsgJ2QnOiA0IH1dXG4gKiB9O1xuICpcbiAqIHZhciBvdGhlciA9IHtcbiAqICAgJ2EnOiBbeyAnYyc6IDMgfSwgeyAnZSc6IDUgfV1cbiAqIH07XG4gKlxuICogXy5tZXJnZShvYmplY3QsIG90aGVyKTtcbiAqIC8vID0+IHsgJ2EnOiBbeyAnYic6IDIsICdjJzogMyB9LCB7ICdkJzogNCwgJ2UnOiA1IH1dIH1cbiAqL1xudmFyIG1lcmdlID0gY3JlYXRlQXNzaWduZXIoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4KSB7XG4gIGJhc2VNZXJnZShvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgpO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gbWVyZ2U7XG4iLCJ2YXIgZnJlZUdsb2JhbCA9IHJlcXVpcmUoJy4vX2ZyZWVHbG9iYWwnKTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbnZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG4vKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbnZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJvb3Q7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc09iamVjdExpa2U7XG4iLCJmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG5cbiAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqO1xuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG4gIH1cblxuICByZXR1cm4gX3R5cGVvZihvYmopO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF90eXBlb2Y7XG5tb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7IiwiZnVuY3Rpb24gYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBrZXksIGFyZykge1xuICB0cnkge1xuICAgIHZhciBpbmZvID0gZ2VuW2tleV0oYXJnKTtcbiAgICB2YXIgdmFsdWUgPSBpbmZvLnZhbHVlO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJlamVjdChlcnJvcik7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGluZm8uZG9uZSkge1xuICAgIHJlc29sdmUodmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihfbmV4dCwgX3Rocm93KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfYXN5bmNUb0dlbmVyYXRvcihmbikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIGdlbiA9IGZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuXG4gICAgICBmdW5jdGlvbiBfbmV4dCh2YWx1ZSkge1xuICAgICAgICBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIFwibmV4dFwiLCB2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIF90aHJvdyhlcnIpIHtcbiAgICAgICAgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBcInRocm93XCIsIGVycik7XG4gICAgICB9XG5cbiAgICAgIF9uZXh0KHVuZGVmaW5lZCk7XG4gICAgfSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2FzeW5jVG9HZW5lcmF0b3I7XG5tb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7IiwiLyoqXHJcbiAqIGh0dHA6Ly93d3cuY29kZXByb2plY3QuY29tL1RpcHMvNDA3MTcyL0Nvbm5lY3RlZC1Db21wb25lbnQtTGFiZWxpbmctYW5kLVZlY3Rvcml6YXRpb25cclxuICovXHJcbmNvbnN0IFRyYWNlciA9IHtcclxuICAgIHNlYXJjaERpcmVjdGlvbnM6IFtbMCwgMV0sIFsxLCAxXSwgWzEsIDBdLCBbMSwgLTFdLCBbMCwgLTFdLCBbLTEsIC0xXSwgWy0xLCAwXSwgWy0xLCAxXV0sXHJcbiAgICBjcmVhdGUoaW1hZ2VXcmFwcGVyLCBsYWJlbFdyYXBwZXIpIHtcclxuICAgICAgICBjb25zdCBpbWFnZURhdGEgPSBpbWFnZVdyYXBwZXIuZGF0YTtcclxuICAgICAgICBjb25zdCBsYWJlbERhdGEgPSBsYWJlbFdyYXBwZXIuZGF0YTtcclxuICAgICAgICBjb25zdCB7IHNlYXJjaERpcmVjdGlvbnMgfSA9IHRoaXM7XHJcbiAgICAgICAgY29uc3Qgd2lkdGggPSBpbWFnZVdyYXBwZXIuc2l6ZS54O1xyXG4gICAgICAgIGxldCBwb3M7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHRyYWNlKGN1cnJlbnQsIGNvbG9yLCBsYWJlbCwgZWRnZWxhYmVsKSB7XHJcbiAgICAgICAgICAgIGxldCBpO1xyXG4gICAgICAgICAgICBsZXQgeTtcclxuICAgICAgICAgICAgbGV0IHg7XHJcblxyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNzsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB5ID0gY3VycmVudC5jeSArIHNlYXJjaERpcmVjdGlvbnNbY3VycmVudC5kaXJdWzBdO1xyXG4gICAgICAgICAgICAgICAgeCA9IGN1cnJlbnQuY3ggKyBzZWFyY2hEaXJlY3Rpb25zW2N1cnJlbnQuZGlyXVsxXTtcclxuICAgICAgICAgICAgICAgIHBvcyA9IHkgKiB3aWR0aCArIHg7XHJcbiAgICAgICAgICAgICAgICBpZiAoKGltYWdlRGF0YVtwb3NdID09PSBjb2xvcikgJiYgKChsYWJlbERhdGFbcG9zXSA9PT0gMCkgfHwgKGxhYmVsRGF0YVtwb3NdID09PSBsYWJlbCkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGFiZWxEYXRhW3Bvc10gPSBsYWJlbDtcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50LmN5ID0geTtcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50LmN4ID0geDtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChsYWJlbERhdGFbcG9zXSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsRGF0YVtwb3NdID0gZWRnZWxhYmVsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY3VycmVudC5kaXIgPSAoY3VycmVudC5kaXIgKyAxKSAlIDg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gdmVydGV4MkQoeCwgeSwgZGlyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBkaXIsXHJcbiAgICAgICAgICAgICAgICB4LFxyXG4gICAgICAgICAgICAgICAgeSxcclxuICAgICAgICAgICAgICAgIG5leHQ6IG51bGwsXHJcbiAgICAgICAgICAgICAgICBwcmV2OiBudWxsLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gY29udG91clRyYWNpbmcoc3ksIHN4LCBsYWJlbCwgY29sb3IsIGVkZ2VsYWJlbCkge1xyXG4gICAgICAgICAgICBsZXQgRnYgPSBudWxsO1xyXG4gICAgICAgICAgICBsZXQgQ3Y7XHJcbiAgICAgICAgICAgIGxldCBQO1xyXG4gICAgICAgICAgICBsZXQgbGRpcjtcclxuICAgICAgICAgICAgY29uc3QgY3VycmVudCA9IHtcclxuICAgICAgICAgICAgICAgIGN4OiBzeCxcclxuICAgICAgICAgICAgICAgIGN5OiBzeSxcclxuICAgICAgICAgICAgICAgIGRpcjogMCxcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIGlmICh0cmFjZShjdXJyZW50LCBjb2xvciwgbGFiZWwsIGVkZ2VsYWJlbCkpIHtcclxuICAgICAgICAgICAgICAgIEZ2ID0gdmVydGV4MkQoc3gsIHN5LCBjdXJyZW50LmRpcik7XHJcbiAgICAgICAgICAgICAgICBDdiA9IEZ2O1xyXG4gICAgICAgICAgICAgICAgbGRpciA9IGN1cnJlbnQuZGlyO1xyXG4gICAgICAgICAgICAgICAgUCA9IHZlcnRleDJEKGN1cnJlbnQuY3gsIGN1cnJlbnQuY3ksIDApO1xyXG4gICAgICAgICAgICAgICAgUC5wcmV2ID0gQ3Y7XHJcbiAgICAgICAgICAgICAgICBDdi5uZXh0ID0gUDtcclxuICAgICAgICAgICAgICAgIFAubmV4dCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBDdiA9IFA7XHJcbiAgICAgICAgICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudC5kaXIgPSAoY3VycmVudC5kaXIgKyA2KSAlIDg7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJhY2UoY3VycmVudCwgY29sb3IsIGxhYmVsLCBlZGdlbGFiZWwpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChsZGlyICE9PSBjdXJyZW50LmRpcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBDdi5kaXIgPSBjdXJyZW50LmRpcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgUCA9IHZlcnRleDJEKGN1cnJlbnQuY3gsIGN1cnJlbnQuY3ksIDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBQLnByZXYgPSBDdjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgQ3YubmV4dCA9IFA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFAubmV4dCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIEN2ID0gUDtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBDdi5kaXIgPSBsZGlyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBDdi54ID0gY3VycmVudC5jeDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgQ3YueSA9IGN1cnJlbnQuY3k7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGxkaXIgPSBjdXJyZW50LmRpcjtcclxuICAgICAgICAgICAgICAgIH0gd2hpbGUgKGN1cnJlbnQuY3ggIT09IHN4IHx8IGN1cnJlbnQuY3kgIT09IHN5KTtcclxuICAgICAgICAgICAgICAgIEZ2LnByZXYgPSBDdi5wcmV2O1xyXG4gICAgICAgICAgICAgICAgQ3YucHJldi5uZXh0ID0gRnY7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIEZ2O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdHJhY2UoY3VycmVudCwgY29sb3IsIGxhYmVsLCBlZGdlbGFiZWwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cmFjZShjdXJyZW50LCBjb2xvciwgbGFiZWwsIGVkZ2VsYWJlbCk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGNvbnRvdXJUcmFjaW5nKHN5LCBzeCwgbGFiZWwsIGNvbG9yLCBlZGdlbGFiZWwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjb250b3VyVHJhY2luZyhzeSwgc3gsIGxhYmVsLCBjb2xvciwgZWRnZWxhYmVsKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9O1xyXG4gICAgfSxcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IChUcmFjZXIpO1xyXG4iLCJ2YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fU3ltYm9sJyksXG4gICAgZ2V0UmF3VGFnID0gcmVxdWlyZSgnLi9fZ2V0UmF3VGFnJyksXG4gICAgb2JqZWN0VG9TdHJpbmcgPSByZXF1aXJlKCcuL19vYmplY3RUb1N0cmluZycpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbnVsbFRhZyA9ICdbb2JqZWN0IE51bGxdJyxcbiAgICB1bmRlZmluZWRUYWcgPSAnW29iamVjdCBVbmRlZmluZWRdJztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wgPyBTeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldFRhZ2Agd2l0aG91dCBmYWxsYmFja3MgZm9yIGJ1Z2d5IGVudmlyb25tZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0VGFnKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWRUYWcgOiBudWxsVGFnO1xuICB9XG4gIHJldHVybiAoc3ltVG9TdHJpbmdUYWcgJiYgc3ltVG9TdHJpbmdUYWcgaW4gT2JqZWN0KHZhbHVlKSlcbiAgICA/IGdldFJhd1RhZyh2YWx1ZSlcbiAgICA6IG9iamVjdFRvU3RyaW5nKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlR2V0VGFnO1xuIiwiaW1wb3J0ICogYXMgdmVjMiBmcm9tICdnbC12ZWMyJztcclxuaW1wb3J0ICogYXMgbWF0MiBmcm9tICdnbC1tYXQyJztcclxuaW1wb3J0IEltYWdlV3JhcHBlciBmcm9tICcuLi9jb21tb24vaW1hZ2Vfd3JhcHBlcic7XHJcbmltcG9ydCB7XHJcbiAgICBjYWxjdWxhdGVQYXRjaFNpemUsXHJcbiAgICBvdHN1VGhyZXNob2xkLFxyXG4gICAgaHN2MnJnYixcclxuICAgIGNsdXN0ZXIsXHJcbiAgICB0b3BHZW5lcmljLFxyXG4gICAgaW1hZ2VSZWYsXHJcbiAgICBoYWxmU2FtcGxlLFxyXG4gICAgY29tcHV0ZUltYWdlQXJlYSxcclxufSBmcm9tICcuLi9jb21tb24vY3ZfdXRpbHMnO1xyXG5pbXBvcnQgQXJyYXlIZWxwZXIgZnJvbSAnLi4vY29tbW9uL2FycmF5X2hlbHBlcic7XHJcbmltcG9ydCBJbWFnZURlYnVnIGZyb20gJy4uL2NvbW1vbi9pbWFnZV9kZWJ1Zyc7XHJcbmltcG9ydCBSYXN0ZXJpemVyIGZyb20gJy4vcmFzdGVyaXplcic7XHJcbmltcG9ydCBUcmFjZXIgZnJvbSAnLi90cmFjZXInO1xyXG5pbXBvcnQgc2tlbGV0b25pemVyIGZyb20gJy4vc2tlbGV0b25pemVyJztcclxuXHJcblxyXG5sZXQgX2NvbmZpZztcclxubGV0IF9jdXJyZW50SW1hZ2VXcmFwcGVyO1xyXG5sZXQgX3NrZWxJbWFnZVdyYXBwZXI7XHJcbmxldCBfc3ViSW1hZ2VXcmFwcGVyO1xyXG5sZXQgX2xhYmVsSW1hZ2VXcmFwcGVyO1xyXG5sZXQgX3BhdGNoR3JpZDtcclxubGV0IF9wYXRjaExhYmVsR3JpZDtcclxubGV0IF9pbWFnZVRvUGF0Y2hHcmlkO1xyXG5sZXQgX2JpbmFyeUltYWdlV3JhcHBlcjtcclxubGV0IF9wYXRjaFNpemU7XHJcbmNvbnN0IF9jYW52YXNDb250YWluZXIgPSB7XHJcbiAgICBjdHg6IHtcclxuICAgICAgICBiaW5hcnk6IG51bGwsXHJcbiAgICB9LFxyXG4gICAgZG9tOiB7XHJcbiAgICAgICAgYmluYXJ5OiBudWxsLFxyXG4gICAgfSxcclxufTtcclxuY29uc3QgX251bVBhdGNoZXMgPSB7IHg6IDAsIHk6IDAgfTtcclxubGV0IF9pbnB1dEltYWdlV3JhcHBlcjtcclxubGV0IF9za2VsZXRvbml6ZXI7XHJcblxyXG5mdW5jdGlvbiBpbml0QnVmZmVycygpIHtcclxuICAgIGlmIChfY29uZmlnLmhhbGZTYW1wbGUpIHtcclxuICAgICAgICBfY3VycmVudEltYWdlV3JhcHBlciA9IG5ldyBJbWFnZVdyYXBwZXIoe1xyXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxyXG4gICAgICAgICAgICB4OiBfaW5wdXRJbWFnZVdyYXBwZXIuc2l6ZS54IC8gMiB8IDAsXHJcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1iaXR3aXNlXHJcbiAgICAgICAgICAgIHk6IF9pbnB1dEltYWdlV3JhcHBlci5zaXplLnkgLyAyIHwgMCxcclxuICAgICAgICB9KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgX2N1cnJlbnRJbWFnZVdyYXBwZXIgPSBfaW5wdXRJbWFnZVdyYXBwZXI7XHJcbiAgICB9XHJcblxyXG4gICAgX3BhdGNoU2l6ZSA9IGNhbGN1bGF0ZVBhdGNoU2l6ZShfY29uZmlnLnBhdGNoU2l6ZSwgX2N1cnJlbnRJbWFnZVdyYXBwZXIuc2l6ZSk7XHJcblxyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWJpdHdpc2VcclxuICAgIF9udW1QYXRjaGVzLnggPSBfY3VycmVudEltYWdlV3JhcHBlci5zaXplLnggLyBfcGF0Y2hTaXplLnggfCAwO1xyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWJpdHdpc2VcclxuICAgIF9udW1QYXRjaGVzLnkgPSBfY3VycmVudEltYWdlV3JhcHBlci5zaXplLnkgLyBfcGF0Y2hTaXplLnkgfCAwO1xyXG5cclxuICAgIF9iaW5hcnlJbWFnZVdyYXBwZXIgPSBuZXcgSW1hZ2VXcmFwcGVyKF9jdXJyZW50SW1hZ2VXcmFwcGVyLnNpemUsIHVuZGVmaW5lZCwgVWludDhBcnJheSwgZmFsc2UpO1xyXG5cclxuICAgIF9sYWJlbEltYWdlV3JhcHBlciA9IG5ldyBJbWFnZVdyYXBwZXIoX3BhdGNoU2l6ZSwgdW5kZWZpbmVkLCBBcnJheSwgdHJ1ZSk7XHJcblxyXG4gICAgY29uc3Qgc2tlbGV0b25JbWFnZURhdGEgPSBuZXcgQXJyYXlCdWZmZXIoNjQgKiAxMDI0KTtcclxuICAgIF9zdWJJbWFnZVdyYXBwZXIgPSBuZXcgSW1hZ2VXcmFwcGVyKF9wYXRjaFNpemUsXHJcbiAgICAgICAgbmV3IFVpbnQ4QXJyYXkoc2tlbGV0b25JbWFnZURhdGEsIDAsIF9wYXRjaFNpemUueCAqIF9wYXRjaFNpemUueSkpO1xyXG4gICAgX3NrZWxJbWFnZVdyYXBwZXIgPSBuZXcgSW1hZ2VXcmFwcGVyKF9wYXRjaFNpemUsXHJcbiAgICAgICAgbmV3IFVpbnQ4QXJyYXkoc2tlbGV0b25JbWFnZURhdGEsIF9wYXRjaFNpemUueCAqIF9wYXRjaFNpemUueSAqIDMsIF9wYXRjaFNpemUueCAqIF9wYXRjaFNpemUueSksXHJcbiAgICAgICAgdW5kZWZpbmVkLCB0cnVlKTtcclxuICAgIF9za2VsZXRvbml6ZXIgPSBza2VsZXRvbml6ZXIoXHJcbiAgICAgICAgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSA/IHdpbmRvdyA6ICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcpID8gc2VsZiA6IGdsb2JhbCxcclxuICAgICAgICB7IHNpemU6IF9wYXRjaFNpemUueCB9LFxyXG4gICAgICAgIHNrZWxldG9uSW1hZ2VEYXRhLFxyXG4gICAgKTtcclxuXHJcbiAgICBfaW1hZ2VUb1BhdGNoR3JpZCA9IG5ldyBJbWFnZVdyYXBwZXIoe1xyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1iaXR3aXNlXHJcbiAgICAgICAgeDogKF9jdXJyZW50SW1hZ2VXcmFwcGVyLnNpemUueCAvIF9zdWJJbWFnZVdyYXBwZXIuc2l6ZS54KSB8IDAsXHJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWJpdHdpc2VcclxuICAgICAgICB5OiAoX2N1cnJlbnRJbWFnZVdyYXBwZXIuc2l6ZS55IC8gX3N1YkltYWdlV3JhcHBlci5zaXplLnkpIHwgMCxcclxuICAgIH0sIHVuZGVmaW5lZCwgQXJyYXksIHRydWUpO1xyXG4gICAgX3BhdGNoR3JpZCA9IG5ldyBJbWFnZVdyYXBwZXIoX2ltYWdlVG9QYXRjaEdyaWQuc2l6ZSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHRydWUpO1xyXG4gICAgX3BhdGNoTGFiZWxHcmlkID0gbmV3IEltYWdlV3JhcHBlcihfaW1hZ2VUb1BhdGNoR3JpZC5zaXplLCB1bmRlZmluZWQsIEludDMyQXJyYXksIHRydWUpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBpbml0Q2FudmFzKCkge1xyXG4gICAgaWYgKF9jb25maWcudXNlV29ya2VyIHx8IHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBfY2FudmFzQ29udGFpbmVyLmRvbS5iaW5hcnkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcclxuICAgIF9jYW52YXNDb250YWluZXIuZG9tLmJpbmFyeS5jbGFzc05hbWUgPSAnYmluYXJ5QnVmZmVyJztcclxuICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQgJiYgX2NvbmZpZy5kZWJ1Zy5zaG93Q2FudmFzID09PSB0cnVlKSB7XHJcbiAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI2RlYnVnJykuYXBwZW5kQ2hpbGQoX2NhbnZhc0NvbnRhaW5lci5kb20uYmluYXJ5KTtcclxuICAgIH1cclxuICAgIF9jYW52YXNDb250YWluZXIuY3R4LmJpbmFyeSA9IF9jYW52YXNDb250YWluZXIuZG9tLmJpbmFyeS5nZXRDb250ZXh0KCcyZCcpO1xyXG4gICAgX2NhbnZhc0NvbnRhaW5lci5kb20uYmluYXJ5LndpZHRoID0gX2JpbmFyeUltYWdlV3JhcHBlci5zaXplLng7XHJcbiAgICBfY2FudmFzQ29udGFpbmVyLmRvbS5iaW5hcnkuaGVpZ2h0ID0gX2JpbmFyeUltYWdlV3JhcHBlci5zaXplLnk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgYm91bmRpbmcgYm94IHdoaWNoIGVuY2xvc2VzIGFsbCB0aGUgZ2l2ZW4gcGF0Y2hlc1xyXG4gKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBtaW5pbWFsIGJvdW5kaW5nIGJveFxyXG4gKi9cclxuZnVuY3Rpb24gYm94RnJvbVBhdGNoZXMocGF0Y2hlcykge1xyXG4gICAgbGV0IG92ZXJBdmc7XHJcbiAgICBsZXQgaTtcclxuICAgIGxldCBqO1xyXG4gICAgbGV0IHBhdGNoO1xyXG4gICAgbGV0IHRyYW5zTWF0O1xyXG4gICAgbGV0IG1pbnggPSBfYmluYXJ5SW1hZ2VXcmFwcGVyLnNpemUueDtcclxuICAgIGxldCBtaW55ID0gX2JpbmFyeUltYWdlV3JhcHBlci5zaXplLnk7XHJcbiAgICBsZXQgbWF4eCA9IC1fYmluYXJ5SW1hZ2VXcmFwcGVyLnNpemUueDtcclxuICAgIGxldCBtYXh5ID0gLV9iaW5hcnlJbWFnZVdyYXBwZXIuc2l6ZS55O1xyXG4gICAgbGV0IGJveDtcclxuICAgIGxldCBzY2FsZTtcclxuXHJcbiAgICAvLyBkcmF3IGFsbCBwYXRjaGVzIHdoaWNoIGFyZSB0byBiZSB0YWtlbiBpbnRvIGNvbnNpZGVyYXRpb25cclxuICAgIG92ZXJBdmcgPSAwO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IHBhdGNoZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBwYXRjaCA9IHBhdGNoZXNbaV07XHJcbiAgICAgICAgb3ZlckF2ZyArPSBwYXRjaC5yYWQ7XHJcbiAgICAgICAgaWYgKEVOVi5kZXZlbG9wbWVudCAmJiBfY29uZmlnLmRlYnVnLnNob3dQYXRjaGVzKSB7XHJcbiAgICAgICAgICAgIEltYWdlRGVidWcuZHJhd1JlY3QocGF0Y2gucG9zLCBfc3ViSW1hZ2VXcmFwcGVyLnNpemUsIF9jYW52YXNDb250YWluZXIuY3R4LmJpbmFyeSwgeyBjb2xvcjogJ3JlZCcgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIG92ZXJBdmcgLz0gcGF0Y2hlcy5sZW5ndGg7XHJcbiAgICBvdmVyQXZnID0gKG92ZXJBdmcgKiAxODAgLyBNYXRoLlBJICsgOTApICUgMTgwIC0gOTA7XHJcbiAgICBpZiAob3ZlckF2ZyA8IDApIHtcclxuICAgICAgICBvdmVyQXZnICs9IDE4MDtcclxuICAgIH1cclxuXHJcbiAgICBvdmVyQXZnID0gKDE4MCAtIG92ZXJBdmcpICogTWF0aC5QSSAvIDE4MDtcclxuICAgIHRyYW5zTWF0ID0gbWF0Mi5jb3B5KG1hdDIuY3JlYXRlKCksIFtNYXRoLmNvcyhvdmVyQXZnKSwgTWF0aC5zaW4ob3ZlckF2ZyksIC1NYXRoLnNpbihvdmVyQXZnKSwgTWF0aC5jb3Mob3ZlckF2ZyldKTtcclxuXHJcbiAgICAvLyBpdGVyYXRlIG92ZXIgcGF0Y2hlcyBhbmQgcm90YXRlIGJ5IGFuZ2xlXHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgcGF0Y2hlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHBhdGNoID0gcGF0Y2hlc1tpXTtcclxuICAgICAgICBmb3IgKGogPSAwOyBqIDwgNDsgaisrKSB7XHJcbiAgICAgICAgICAgIHZlYzIudHJhbnNmb3JtTWF0MihwYXRjaC5ib3hbal0sIHBhdGNoLmJveFtqXSwgdHJhbnNNYXQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKEVOVi5kZXZlbG9wbWVudCAmJiBfY29uZmlnLmRlYnVnLmJveEZyb21QYXRjaGVzLnNob3dUcmFuc2Zvcm1lZCkge1xyXG4gICAgICAgICAgICBJbWFnZURlYnVnLmRyYXdQYXRoKHBhdGNoLmJveCwgeyB4OiAwLCB5OiAxIH0sIF9jYW52YXNDb250YWluZXIuY3R4LmJpbmFyeSwgeyBjb2xvcjogJyM5OWZmMDAnLCBsaW5lV2lkdGg6IDIgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIGZpbmQgYm91bmRpbmcgYm94XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgcGF0Y2hlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHBhdGNoID0gcGF0Y2hlc1tpXTtcclxuICAgICAgICBmb3IgKGogPSAwOyBqIDwgNDsgaisrKSB7XHJcbiAgICAgICAgICAgIGlmIChwYXRjaC5ib3hbal1bMF0gPCBtaW54KSB7XHJcbiAgICAgICAgICAgICAgICBtaW54ID0gcGF0Y2guYm94W2pdWzBdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChwYXRjaC5ib3hbal1bMF0gPiBtYXh4KSB7XHJcbiAgICAgICAgICAgICAgICBtYXh4ID0gcGF0Y2guYm94W2pdWzBdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChwYXRjaC5ib3hbal1bMV0gPCBtaW55KSB7XHJcbiAgICAgICAgICAgICAgICBtaW55ID0gcGF0Y2guYm94W2pdWzFdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChwYXRjaC5ib3hbal1bMV0gPiBtYXh5KSB7XHJcbiAgICAgICAgICAgICAgICBtYXh5ID0gcGF0Y2guYm94W2pdWzFdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGJveCA9IFtbbWlueCwgbWlueV0sIFttYXh4LCBtaW55XSwgW21heHgsIG1heHldLCBbbWlueCwgbWF4eV1dO1xyXG5cclxuICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQgJiYgX2NvbmZpZy5kZWJ1Zy5ib3hGcm9tUGF0Y2hlcy5zaG93VHJhbnNmb3JtZWRCb3gpIHtcclxuICAgICAgICBJbWFnZURlYnVnLmRyYXdQYXRoKGJveCwgeyB4OiAwLCB5OiAxIH0sIF9jYW52YXNDb250YWluZXIuY3R4LmJpbmFyeSwgeyBjb2xvcjogJyNmZjAwMDAnLCBsaW5lV2lkdGg6IDIgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgc2NhbGUgPSBfY29uZmlnLmhhbGZTYW1wbGUgPyAyIDogMTtcclxuICAgIC8vIHJldmVyc2Ugcm90YXRpb247XHJcbiAgICB0cmFuc01hdCA9IG1hdDIuaW52ZXJ0KHRyYW5zTWF0LCB0cmFuc01hdCk7XHJcbiAgICBmb3IgKGogPSAwOyBqIDwgNDsgaisrKSB7XHJcbiAgICAgICAgdmVjMi50cmFuc2Zvcm1NYXQyKGJveFtqXSwgYm94W2pdLCB0cmFuc01hdCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKEVOVi5kZXZlbG9wbWVudCAmJiBfY29uZmlnLmRlYnVnLmJveEZyb21QYXRjaGVzLnNob3dCQikge1xyXG4gICAgICAgIEltYWdlRGVidWcuZHJhd1BhdGgoYm94LCB7IHg6IDAsIHk6IDEgfSwgX2NhbnZhc0NvbnRhaW5lci5jdHguYmluYXJ5LCB7IGNvbG9yOiAnI2ZmMDAwMCcsIGxpbmVXaWR0aDogMiB9KTtcclxuICAgIH1cclxuXHJcbiAgICBmb3IgKGogPSAwOyBqIDwgNDsgaisrKSB7XHJcbiAgICAgICAgdmVjMi5zY2FsZShib3hbal0sIGJveFtqXSwgc2NhbGUpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBib3g7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgYmluYXJ5IGltYWdlIG9mIHRoZSBjdXJyZW50IGltYWdlXHJcbiAqL1xyXG5mdW5jdGlvbiBiaW5hcml6ZUltYWdlKCkge1xyXG4gICAgb3RzdVRocmVzaG9sZChfY3VycmVudEltYWdlV3JhcHBlciwgX2JpbmFyeUltYWdlV3JhcHBlcik7XHJcbiAgICBfYmluYXJ5SW1hZ2VXcmFwcGVyLnplcm9Cb3JkZXIoKTtcclxuICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQgJiYgX2NvbmZpZy5kZWJ1Zy5zaG93Q2FudmFzKSB7XHJcbiAgICAgICAgX2JpbmFyeUltYWdlV3JhcHBlci5zaG93KF9jYW52YXNDb250YWluZXIuZG9tLmJpbmFyeSwgMjU1KTtcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEl0ZXJhdGUgb3ZlciB0aGUgZW50aXJlIGltYWdlXHJcbiAqIGV4dHJhY3QgcGF0Y2hlc1xyXG4gKi9cclxuZnVuY3Rpb24gZmluZFBhdGNoZXMoKSB7XHJcbiAgICBsZXQgaTtcclxuICAgIGxldCBqO1xyXG4gICAgbGV0IHg7XHJcbiAgICBsZXQgeTtcclxuICAgIGxldCBtb21lbnRzO1xyXG4gICAgbGV0IHBhdGNoZXNGb3VuZCA9IFtdO1xyXG4gICAgbGV0IHJhc3Rlcml6ZXI7XHJcbiAgICBsZXQgcmFzdGVyUmVzdWx0O1xyXG4gICAgbGV0IHBhdGNoO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IF9udW1QYXRjaGVzLng7IGkrKykge1xyXG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBfbnVtUGF0Y2hlcy55OyBqKyspIHtcclxuICAgICAgICAgICAgeCA9IF9zdWJJbWFnZVdyYXBwZXIuc2l6ZS54ICogaTtcclxuICAgICAgICAgICAgeSA9IF9zdWJJbWFnZVdyYXBwZXIuc2l6ZS55ICogajtcclxuXHJcbiAgICAgICAgICAgIC8vIHNlcGVyYXRlIHBhcnRzXHJcbiAgICAgICAgICAgIHNrZWxldG9uaXplKHgsIHkpO1xyXG5cclxuICAgICAgICAgICAgLy8gUmFzdGVyaXplLCBmaW5kIGluZGl2aWR1YWwgYmFyc1xyXG4gICAgICAgICAgICBfc2tlbEltYWdlV3JhcHBlci56ZXJvQm9yZGVyKCk7XHJcbiAgICAgICAgICAgIEFycmF5SGVscGVyLmluaXQoX2xhYmVsSW1hZ2VXcmFwcGVyLmRhdGEsIDApO1xyXG4gICAgICAgICAgICByYXN0ZXJpemVyID0gUmFzdGVyaXplci5jcmVhdGUoX3NrZWxJbWFnZVdyYXBwZXIsIF9sYWJlbEltYWdlV3JhcHBlcik7XHJcbiAgICAgICAgICAgIHJhc3RlclJlc3VsdCA9IHJhc3Rlcml6ZXIucmFzdGVyaXplKDApO1xyXG5cclxuICAgICAgICAgICAgaWYgKEVOVi5kZXZlbG9wbWVudCAmJiBfY29uZmlnLmRlYnVnLnNob3dMYWJlbHMpIHtcclxuICAgICAgICAgICAgICAgIF9sYWJlbEltYWdlV3JhcHBlci5vdmVybGF5KF9jYW52YXNDb250YWluZXIuZG9tLmJpbmFyeSwgTWF0aC5mbG9vcigzNjAgLyByYXN0ZXJSZXN1bHQuY291bnQpLFxyXG4gICAgICAgICAgICAgICAgICAgIHsgeCwgeSB9KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gY2FsY3VsYXRlIG1vbWVudHMgZnJvbSB0aGUgc2tlbGV0b25pemVkIHBhdGNoXHJcbiAgICAgICAgICAgIG1vbWVudHMgPSBfbGFiZWxJbWFnZVdyYXBwZXIubW9tZW50cyhyYXN0ZXJSZXN1bHQuY291bnQpO1xyXG5cclxuICAgICAgICAgICAgLy8gZXh0cmFjdCBlbGlnaWJsZSBwYXRjaGVzXHJcbiAgICAgICAgICAgIHBhdGNoZXNGb3VuZCA9IHBhdGNoZXNGb3VuZC5jb25jYXQoZGVzY3JpYmVQYXRjaChtb21lbnRzLCBbaSwgal0sIHgsIHkpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKEVOVi5kZXZlbG9wbWVudCAmJiBfY29uZmlnLmRlYnVnLnNob3dGb3VuZFBhdGNoZXMpIHtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcGF0Y2hlc0ZvdW5kLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHBhdGNoID0gcGF0Y2hlc0ZvdW5kW2ldO1xyXG4gICAgICAgICAgICBJbWFnZURlYnVnLmRyYXdSZWN0KHBhdGNoLnBvcywgX3N1YkltYWdlV3JhcHBlci5zaXplLCBfY2FudmFzQ29udGFpbmVyLmN0eC5iaW5hcnksXHJcbiAgICAgICAgICAgICAgICB7IGNvbG9yOiAnIzk5ZmYwMCcsIGxpbmVXaWR0aDogMiB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHBhdGNoZXNGb3VuZDtcclxufVxyXG5cclxuLyoqXHJcbiAqIEZpbmRzIHRob3NlIGNvbm5lY3RlZCBhcmVhcyB3aGljaCBjb250YWluIGF0IGxlYXN0IDYgcGF0Y2hlc1xyXG4gKiBhbmQgcmV0dXJucyB0aGVtIG9yZGVyZWQgREVTQyBieSB0aGUgbnVtYmVyIG9mIGNvbnRhaW5lZCBwYXRjaGVzXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtYXhMYWJlbFxyXG4gKi9cclxuZnVuY3Rpb24gZmluZEJpZ2dlc3RDb25uZWN0ZWRBcmVhcyhtYXhMYWJlbCkge1xyXG4gICAgbGV0IGk7XHJcbiAgICBsZXQgc3VtO1xyXG4gICAgbGV0IGxhYmVsSGlzdCA9IFtdO1xyXG4gICAgbGV0IHRvcExhYmVscyA9IFtdO1xyXG5cclxuICAgIGZvciAoaSA9IDA7IGkgPCBtYXhMYWJlbDsgaSsrKSB7XHJcbiAgICAgICAgbGFiZWxIaXN0LnB1c2goMCk7XHJcbiAgICB9XHJcbiAgICBzdW0gPSBfcGF0Y2hMYWJlbEdyaWQuZGF0YS5sZW5ndGg7XHJcbiAgICB3aGlsZSAoc3VtLS0pIHtcclxuICAgICAgICBpZiAoX3BhdGNoTGFiZWxHcmlkLmRhdGFbc3VtXSA+IDApIHtcclxuICAgICAgICAgICAgbGFiZWxIaXN0W19wYXRjaExhYmVsR3JpZC5kYXRhW3N1bV0gLSAxXSsrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBsYWJlbEhpc3QgPSBsYWJlbEhpc3QubWFwKCh2YWwsIGlkeCkgPT4gKHtcclxuICAgICAgICB2YWwsXHJcbiAgICAgICAgbGFiZWw6IGlkeCArIDEsXHJcbiAgICB9KSk7XHJcblxyXG4gICAgbGFiZWxIaXN0LnNvcnQoKGEsIGIpID0+IGIudmFsIC0gYS52YWwpO1xyXG5cclxuICAgIC8vIGV4dHJhY3QgdG9wIGFyZWFzIHdpdGggYXQgbGVhc3QgNiBwYXRjaGVzIHByZXNlbnRcclxuICAgIHRvcExhYmVscyA9IGxhYmVsSGlzdC5maWx0ZXIoKGVsKSA9PiBlbC52YWwgPj0gNSk7XHJcblxyXG4gICAgcmV0dXJuIHRvcExhYmVscztcclxufVxyXG5cclxuLyoqXHJcbiAqXHJcbiAqL1xyXG5mdW5jdGlvbiBmaW5kQm94ZXModG9wTGFiZWxzLCBtYXhMYWJlbCkge1xyXG4gICAgbGV0IGk7XHJcbiAgICBsZXQgajtcclxuICAgIGxldCBzdW07XHJcbiAgICBjb25zdCBwYXRjaGVzID0gW107XHJcbiAgICBsZXQgcGF0Y2g7XHJcbiAgICBsZXQgYm94O1xyXG4gICAgY29uc3QgYm94ZXMgPSBbXTtcclxuICAgIGNvbnN0IGhzdiA9IFswLCAxLCAxXTtcclxuICAgIGNvbnN0IHJnYiA9IFswLCAwLCAwXTtcclxuXHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgdG9wTGFiZWxzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgc3VtID0gX3BhdGNoTGFiZWxHcmlkLmRhdGEubGVuZ3RoO1xyXG4gICAgICAgIHBhdGNoZXMubGVuZ3RoID0gMDtcclxuICAgICAgICB3aGlsZSAoc3VtLS0pIHtcclxuICAgICAgICAgICAgaWYgKF9wYXRjaExhYmVsR3JpZC5kYXRhW3N1bV0gPT09IHRvcExhYmVsc1tpXS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgcGF0Y2ggPSBfaW1hZ2VUb1BhdGNoR3JpZC5kYXRhW3N1bV07XHJcbiAgICAgICAgICAgICAgICBwYXRjaGVzLnB1c2gocGF0Y2gpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJveCA9IGJveEZyb21QYXRjaGVzKHBhdGNoZXMpO1xyXG4gICAgICAgIGlmIChib3gpIHtcclxuICAgICAgICAgICAgYm94ZXMucHVzaChib3gpO1xyXG5cclxuICAgICAgICAgICAgLy8gZHJhdyBwYXRjaC1sYWJlbHMgaWYgcmVxdWVzdGVkXHJcbiAgICAgICAgICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQgJiYgX2NvbmZpZy5kZWJ1Zy5zaG93UmVtYWluaW5nUGF0Y2hMYWJlbHMpIHtcclxuICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBwYXRjaGVzLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGF0Y2ggPSBwYXRjaGVzW2pdO1xyXG4gICAgICAgICAgICAgICAgICAgIGhzdlswXSA9ICh0b3BMYWJlbHNbaV0ubGFiZWwgLyAobWF4TGFiZWwgKyAxKSkgKiAzNjA7XHJcbiAgICAgICAgICAgICAgICAgICAgaHN2MnJnYihoc3YsIHJnYik7XHJcbiAgICAgICAgICAgICAgICAgICAgSW1hZ2VEZWJ1Zy5kcmF3UmVjdChwYXRjaC5wb3MsIF9zdWJJbWFnZVdyYXBwZXIuc2l6ZSwgX2NhbnZhc0NvbnRhaW5lci5jdHguYmluYXJ5LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7IGNvbG9yOiBgcmdiKCR7cmdiLmpvaW4oJywnKX0pYCwgbGluZVdpZHRoOiAyIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGJveGVzO1xyXG59XHJcblxyXG4vKipcclxuICogRmluZCBzaW1pbGFyIG1vbWVudHMgKHZpYSBjbHVzdGVyKVxyXG4gKiBAcGFyYW0ge09iamVjdH0gbW9tZW50c1xyXG4gKi9cclxuZnVuY3Rpb24gc2ltaWxhck1vbWVudHMobW9tZW50cykge1xyXG4gICAgY29uc3QgY2x1c3RlcnMgPSBjbHVzdGVyKG1vbWVudHMsIDAuOTApO1xyXG4gICAgY29uc3QgdG9wQ2x1c3RlciA9IHRvcEdlbmVyaWMoY2x1c3RlcnMsIDEsIChlKSA9PiBlLmdldFBvaW50cygpLmxlbmd0aCk7XHJcbiAgICBsZXQgcG9pbnRzID0gW107IGNvbnN0XHJcbiAgICAgICAgcmVzdWx0ID0gW107XHJcbiAgICBpZiAodG9wQ2x1c3Rlci5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICBwb2ludHMgPSB0b3BDbHVzdGVyWzBdLml0ZW0uZ2V0UG9pbnRzKCk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgcmVzdWx0LnB1c2gocG9pbnRzW2ldLnBvaW50KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG5mdW5jdGlvbiBza2VsZXRvbml6ZSh4LCB5KSB7XHJcbiAgICBfYmluYXJ5SW1hZ2VXcmFwcGVyLnN1YkltYWdlQXNDb3B5KF9zdWJJbWFnZVdyYXBwZXIsIGltYWdlUmVmKHgsIHkpKTtcclxuICAgIF9za2VsZXRvbml6ZXIuc2tlbGV0b25pemUoKTtcclxuXHJcbiAgICAvLyBTaG93IHNrZWxldG9uIGlmIHJlcXVlc3RlZFxyXG4gICAgaWYgKEVOVi5kZXZlbG9wbWVudCAmJiBfY29uZmlnLmRlYnVnLnNob3dTa2VsZXRvbikge1xyXG4gICAgICAgIF9za2VsSW1hZ2VXcmFwcGVyLm92ZXJsYXkoX2NhbnZhc0NvbnRhaW5lci5kb20uYmluYXJ5LCAzNjAsIGltYWdlUmVmKHgsIHkpKTtcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEV4dHJhY3RzIGFuZCBkZXNjcmliZXMgdGhvc2UgcGF0Y2hlcyB3aGljaCBzZWVtIHRvIGNvbnRhaW4gYSBiYXJjb2RlIHBhdHRlcm5cclxuICogQHBhcmFtIHtBcnJheX0gbW9tZW50c1xyXG4gKiBAcGFyYW0ge09iamVjdH0gcGF0Y2hQb3MsXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB4XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB5XHJcbiAqIEByZXR1cm5zIHtBcnJheX0gbGlzdCBvZiBwYXRjaGVzXHJcbiAqL1xyXG5mdW5jdGlvbiBkZXNjcmliZVBhdGNoKG1vbWVudHMsIHBhdGNoUG9zLCB4LCB5KSB7XHJcbiAgICBsZXQgaztcclxuICAgIGxldCBhdmc7XHJcbiAgICBjb25zdCBlbGlnaWJsZU1vbWVudHMgPSBbXTtcclxuICAgIGxldCBtYXRjaGluZ01vbWVudHM7XHJcbiAgICBsZXQgcGF0Y2g7XHJcbiAgICBjb25zdCBwYXRjaGVzRm91bmQgPSBbXTtcclxuICAgIGNvbnN0IG1pbkNvbXBvbmVudFdlaWdodCA9IE1hdGguY2VpbChfcGF0Y2hTaXplLnggLyAzKTtcclxuXHJcbiAgICBpZiAobW9tZW50cy5sZW5ndGggPj0gMikge1xyXG4gICAgICAgIC8vIG9ubHkgY29sbGVjdCBtb21lbnRzIHdoaWNoJ3MgYXJlYSBjb3ZlcnMgYXQgbGVhc3QgbWluQ29tcG9uZW50V2VpZ2h0IHBpeGVscy5cclxuICAgICAgICBmb3IgKGsgPSAwOyBrIDwgbW9tZW50cy5sZW5ndGg7IGsrKykge1xyXG4gICAgICAgICAgICBpZiAobW9tZW50c1trXS5tMDAgPiBtaW5Db21wb25lbnRXZWlnaHQpIHtcclxuICAgICAgICAgICAgICAgIGVsaWdpYmxlTW9tZW50cy5wdXNoKG1vbWVudHNba10pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBpZiBhdCBsZWFzdCAyIG1vbWVudHMgYXJlIGZvdW5kIHdoaWNoIGhhdmUgYXQgbGVhc3QgbWluQ29tcG9uZW50V2VpZ2h0cyBjb3ZlcmVkXHJcbiAgICAgICAgaWYgKGVsaWdpYmxlTW9tZW50cy5sZW5ndGggPj0gMikge1xyXG4gICAgICAgICAgICBtYXRjaGluZ01vbWVudHMgPSBzaW1pbGFyTW9tZW50cyhlbGlnaWJsZU1vbWVudHMpO1xyXG4gICAgICAgICAgICBhdmcgPSAwO1xyXG4gICAgICAgICAgICAvLyBkZXRlcm1pbmUgdGhlIHNpbWlsYXJpdHkgb2YgdGhlIG1vbWVudHNcclxuICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IG1hdGNoaW5nTW9tZW50cy5sZW5ndGg7IGsrKykge1xyXG4gICAgICAgICAgICAgICAgYXZnICs9IG1hdGNoaW5nTW9tZW50c1trXS5yYWQ7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIE9ubHkgdHdvIG9mIHRoZSBtb21lbnRzIGFyZSBhbGxvd2VkIG5vdCB0byBmaXQgaW50byB0aGUgZXF1YXRpb25cclxuICAgICAgICAgICAgLy8gYWRkIHRoZSBwYXRjaCB0byB0aGUgc2V0XHJcbiAgICAgICAgICAgIGlmIChtYXRjaGluZ01vbWVudHMubGVuZ3RoID4gMVxyXG4gICAgICAgICAgICAgICAgICAgICYmIG1hdGNoaW5nTW9tZW50cy5sZW5ndGggPj0gKGVsaWdpYmxlTW9tZW50cy5sZW5ndGggLyA0KSAqIDNcclxuICAgICAgICAgICAgICAgICAgICAmJiBtYXRjaGluZ01vbWVudHMubGVuZ3RoID4gbW9tZW50cy5sZW5ndGggLyA0KSB7XHJcbiAgICAgICAgICAgICAgICBhdmcgLz0gbWF0Y2hpbmdNb21lbnRzLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIHBhdGNoID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiBwYXRjaFBvc1sxXSAqIF9udW1QYXRjaGVzLnggKyBwYXRjaFBvc1swXSxcclxuICAgICAgICAgICAgICAgICAgICBwb3M6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgeSxcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIGJveDogW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZWMyLmNsb25lKFt4LCB5XSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIuY2xvbmUoW3ggKyBfc3ViSW1hZ2VXcmFwcGVyLnNpemUueCwgeV0pLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZWMyLmNsb25lKFt4ICsgX3N1YkltYWdlV3JhcHBlci5zaXplLngsIHkgKyBfc3ViSW1hZ2VXcmFwcGVyLnNpemUueV0pLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZWMyLmNsb25lKFt4LCB5ICsgX3N1YkltYWdlV3JhcHBlci5zaXplLnldKSxcclxuICAgICAgICAgICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICAgICAgICAgIG1vbWVudHM6IG1hdGNoaW5nTW9tZW50cyxcclxuICAgICAgICAgICAgICAgICAgICByYWQ6IGF2ZyxcclxuICAgICAgICAgICAgICAgICAgICB2ZWM6IHZlYzIuY2xvbmUoW01hdGguY29zKGF2ZyksIE1hdGguc2luKGF2ZyldKSxcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBwYXRjaGVzRm91bmQucHVzaChwYXRjaCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcGF0Y2hlc0ZvdW5kO1xyXG59XHJcblxyXG4vKipcclxuICogZmluZHMgcGF0Y2hlcyB3aGljaCBhcmUgY29ubmVjdGVkIGFuZCBzaGFyZSB0aGUgc2FtZSBvcmllbnRhdGlvblxyXG4gKiBAcGFyYW0ge09iamVjdH0gcGF0Y2hlc0ZvdW5kXHJcbiAqL1xyXG5mdW5jdGlvbiByYXN0ZXJpemVBbmd1bGFyU2ltaWxhcml0eShwYXRjaGVzRm91bmQpIHtcclxuICAgIGxldCBsYWJlbCA9IDA7XHJcbiAgICBjb25zdCB0aHJlc2hvbGQgPSAwLjk1O1xyXG4gICAgbGV0IGN1cnJJZHggPSAwO1xyXG4gICAgbGV0IGo7XHJcbiAgICBsZXQgcGF0Y2g7XHJcbiAgICBjb25zdCBoc3YgPSBbMCwgMSwgMV07XHJcbiAgICBjb25zdCByZ2IgPSBbMCwgMCwgMF07XHJcblxyXG4gICAgZnVuY3Rpb24gbm90WWV0UHJvY2Vzc2VkKCkge1xyXG4gICAgICAgIGxldCBpO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBfcGF0Y2hMYWJlbEdyaWQuZGF0YS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoX3BhdGNoTGFiZWxHcmlkLmRhdGFbaV0gPT09IDAgJiYgX3BhdGNoR3JpZC5kYXRhW2ldID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gX3BhdGNoTGFiZWxHcmlkLmxlbmd0aDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB0cmFjZShjdXJyZW50SWR4KSB7XHJcbiAgICAgICAgbGV0IHg7XHJcbiAgICAgICAgbGV0IHk7XHJcbiAgICAgICAgbGV0IGN1cnJlbnRQYXRjaDtcclxuICAgICAgICBsZXQgaWR4O1xyXG4gICAgICAgIGxldCBkaXI7XHJcbiAgICAgICAgY29uc3QgY3VycmVudCA9IHtcclxuICAgICAgICAgICAgeDogY3VycmVudElkeCAlIF9wYXRjaExhYmVsR3JpZC5zaXplLngsXHJcbiAgICAgICAgICAgIHk6IChjdXJyZW50SWR4IC8gX3BhdGNoTGFiZWxHcmlkLnNpemUueCkgfCAwLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgbGV0IHNpbWlsYXJpdHk7XHJcblxyXG4gICAgICAgIGlmIChjdXJyZW50SWR4IDwgX3BhdGNoTGFiZWxHcmlkLmRhdGEubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGN1cnJlbnRQYXRjaCA9IF9pbWFnZVRvUGF0Y2hHcmlkLmRhdGFbY3VycmVudElkeF07XHJcbiAgICAgICAgICAgIC8vIGFzc2lnbiBsYWJlbFxyXG4gICAgICAgICAgICBfcGF0Y2hMYWJlbEdyaWQuZGF0YVtjdXJyZW50SWR4XSA9IGxhYmVsO1xyXG4gICAgICAgICAgICBmb3IgKGRpciA9IDA7IGRpciA8IFRyYWNlci5zZWFyY2hEaXJlY3Rpb25zLmxlbmd0aDsgZGlyKyspIHtcclxuICAgICAgICAgICAgICAgIHkgPSBjdXJyZW50LnkgKyBUcmFjZXIuc2VhcmNoRGlyZWN0aW9uc1tkaXJdWzBdO1xyXG4gICAgICAgICAgICAgICAgeCA9IGN1cnJlbnQueCArIFRyYWNlci5zZWFyY2hEaXJlY3Rpb25zW2Rpcl1bMV07XHJcbiAgICAgICAgICAgICAgICBpZHggPSB5ICogX3BhdGNoTGFiZWxHcmlkLnNpemUueCArIHg7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gY29udGludWUgaWYgcGF0Y2ggZW1wdHlcclxuICAgICAgICAgICAgICAgIGlmIChfcGF0Y2hHcmlkLmRhdGFbaWR4XSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIF9wYXRjaExhYmVsR3JpZC5kYXRhW2lkeF0gPSBOdW1iZXIuTUFYX1ZBTFVFO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb250aW51ZVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChfcGF0Y2hMYWJlbEdyaWQuZGF0YVtpZHhdID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2ltaWxhcml0eSA9IE1hdGguYWJzKHZlYzIuZG90KF9pbWFnZVRvUGF0Y2hHcmlkLmRhdGFbaWR4XS52ZWMsIGN1cnJlbnRQYXRjaC52ZWMpKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2ltaWxhcml0eSA+IHRocmVzaG9sZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFjZShpZHgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBwcmVwYXJlIGZvciBmaW5kaW5nIHRoZSByaWdodCBwYXRjaGVzXHJcbiAgICBBcnJheUhlbHBlci5pbml0KF9wYXRjaEdyaWQuZGF0YSwgMCk7XHJcbiAgICBBcnJheUhlbHBlci5pbml0KF9wYXRjaExhYmVsR3JpZC5kYXRhLCAwKTtcclxuICAgIEFycmF5SGVscGVyLmluaXQoX2ltYWdlVG9QYXRjaEdyaWQuZGF0YSwgbnVsbCk7XHJcblxyXG4gICAgZm9yIChqID0gMDsgaiA8IHBhdGNoZXNGb3VuZC5sZW5ndGg7IGorKykge1xyXG4gICAgICAgIHBhdGNoID0gcGF0Y2hlc0ZvdW5kW2pdO1xyXG4gICAgICAgIF9pbWFnZVRvUGF0Y2hHcmlkLmRhdGFbcGF0Y2guaW5kZXhdID0gcGF0Y2g7XHJcbiAgICAgICAgX3BhdGNoR3JpZC5kYXRhW3BhdGNoLmluZGV4XSA9IDE7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gcmFzdGVyaXplIHRoZSBwYXRjaGVzIGZvdW5kIHRvIGRldGVybWluZSBhcmVhXHJcbiAgICBfcGF0Y2hHcmlkLnplcm9Cb3JkZXIoKTtcclxuXHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uZC1hc3NpZ25cclxuICAgIHdoaWxlICgoY3VycklkeCA9IG5vdFlldFByb2Nlc3NlZCgpKSA8IF9wYXRjaExhYmVsR3JpZC5kYXRhLmxlbmd0aCkge1xyXG4gICAgICAgIGxhYmVsKys7XHJcbiAgICAgICAgdHJhY2UoY3VycklkeCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gZHJhdyBwYXRjaC1sYWJlbHMgaWYgcmVxdWVzdGVkXHJcbiAgICBpZiAoRU5WLmRldmVsb3BtZW50ICYmIF9jb25maWcuZGVidWcuc2hvd1BhdGNoTGFiZWxzKSB7XHJcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IF9wYXRjaExhYmVsR3JpZC5kYXRhLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgIGlmIChfcGF0Y2hMYWJlbEdyaWQuZGF0YVtqXSA+IDAgJiYgX3BhdGNoTGFiZWxHcmlkLmRhdGFbal0gPD0gbGFiZWwpIHtcclxuICAgICAgICAgICAgICAgIHBhdGNoID0gX2ltYWdlVG9QYXRjaEdyaWQuZGF0YVtqXTtcclxuICAgICAgICAgICAgICAgIGhzdlswXSA9IChfcGF0Y2hMYWJlbEdyaWQuZGF0YVtqXSAvIChsYWJlbCArIDEpKSAqIDM2MDtcclxuICAgICAgICAgICAgICAgIGhzdjJyZ2IoaHN2LCByZ2IpO1xyXG4gICAgICAgICAgICAgICAgSW1hZ2VEZWJ1Zy5kcmF3UmVjdChwYXRjaC5wb3MsIF9zdWJJbWFnZVdyYXBwZXIuc2l6ZSwgX2NhbnZhc0NvbnRhaW5lci5jdHguYmluYXJ5LFxyXG4gICAgICAgICAgICAgICAgICAgIHsgY29sb3I6IGByZ2IoJHtyZ2Iuam9pbignLCcpfSlgLCBsaW5lV2lkdGg6IDIgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGxhYmVsO1xyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgICBpbml0KGlucHV0SW1hZ2VXcmFwcGVyLCBjb25maWcpIHtcclxuICAgICAgICBfY29uZmlnID0gY29uZmlnO1xyXG4gICAgICAgIF9pbnB1dEltYWdlV3JhcHBlciA9IGlucHV0SW1hZ2VXcmFwcGVyO1xyXG5cclxuICAgICAgICBpbml0QnVmZmVycygpO1xyXG4gICAgICAgIGluaXRDYW52YXMoKTtcclxuICAgIH0sXHJcblxyXG4gICAgbG9jYXRlKCkge1xyXG4gICAgICAgIGlmIChfY29uZmlnLmhhbGZTYW1wbGUpIHtcclxuICAgICAgICAgICAgaGFsZlNhbXBsZShfaW5wdXRJbWFnZVdyYXBwZXIsIF9jdXJyZW50SW1hZ2VXcmFwcGVyKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGJpbmFyaXplSW1hZ2UoKTtcclxuICAgICAgICBjb25zdCBwYXRjaGVzRm91bmQgPSBmaW5kUGF0Y2hlcygpO1xyXG4gICAgICAgIC8vIHJldHVybiB1bmxlc3MgNSUgb3IgbW9yZSBwYXRjaGVzIGFyZSBmb3VuZFxyXG4gICAgICAgIGlmIChwYXRjaGVzRm91bmQubGVuZ3RoIDwgX251bVBhdGNoZXMueCAqIF9udW1QYXRjaGVzLnkgKiAwLjA1KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gcmFzdGVycml6ZSBhcmVhIGJ5IGNvbXBhcmluZyBhbmd1bGFyIHNpbWlsYXJpdHk7XHJcbiAgICAgICAgY29uc3QgbWF4TGFiZWwgPSByYXN0ZXJpemVBbmd1bGFyU2ltaWxhcml0eShwYXRjaGVzRm91bmQpO1xyXG4gICAgICAgIGlmIChtYXhMYWJlbCA8IDEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBzZWFyY2ggZm9yIGFyZWEgd2l0aCB0aGUgbW9zdCBwYXRjaGVzIChiaWdnZXN0IGNvbm5lY3RlZCBhcmVhKVxyXG4gICAgICAgIGNvbnN0IHRvcExhYmVscyA9IGZpbmRCaWdnZXN0Q29ubmVjdGVkQXJlYXMobWF4TGFiZWwpO1xyXG4gICAgICAgIGlmICh0b3BMYWJlbHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgYm94ZXMgPSBmaW5kQm94ZXModG9wTGFiZWxzLCBtYXhMYWJlbCk7XHJcbiAgICAgICAgcmV0dXJuIGJveGVzO1xyXG4gICAgfSxcclxuXHJcbiAgICBjaGVja0ltYWdlQ29uc3RyYWludHMoaW5wdXRTdHJlYW0sIGNvbmZpZykge1xyXG4gICAgICAgIGxldCBwYXRjaFNpemU7XHJcbiAgICAgICAgbGV0IHdpZHRoID0gaW5wdXRTdHJlYW0uZ2V0V2lkdGgoKTtcclxuICAgICAgICBsZXQgaGVpZ2h0ID0gaW5wdXRTdHJlYW0uZ2V0SGVpZ2h0KCk7XHJcbiAgICAgICAgY29uc3QgdGhpc0hhbGZTYW1wbGUgPSBjb25maWcuaGFsZlNhbXBsZSA/IDAuNSA6IDE7XHJcbiAgICAgICAgbGV0IGFyZWE7XHJcblxyXG4gICAgICAgIC8vIGNhbGN1bGF0ZSB3aWR0aCBhbmQgaGVpZ2h0IGJhc2VkIG9uIGFyZWFcclxuICAgICAgICBpZiAoaW5wdXRTdHJlYW0uZ2V0Q29uZmlnKCkuYXJlYSkge1xyXG4gICAgICAgICAgICBhcmVhID0gY29tcHV0ZUltYWdlQXJlYSh3aWR0aCwgaGVpZ2h0LCBpbnB1dFN0cmVhbS5nZXRDb25maWcoKS5hcmVhKTtcclxuICAgICAgICAgICAgaW5wdXRTdHJlYW0uc2V0VG9wUmlnaHQoeyB4OiBhcmVhLnN4LCB5OiBhcmVhLnN5IH0pO1xyXG4gICAgICAgICAgICBpbnB1dFN0cmVhbS5zZXRDYW52YXNTaXplKHsgeDogd2lkdGgsIHk6IGhlaWdodCB9KTtcclxuICAgICAgICAgICAgd2lkdGggPSBhcmVhLnN3O1xyXG4gICAgICAgICAgICBoZWlnaHQgPSBhcmVhLnNoO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3Qgc2l6ZSA9IHtcclxuICAgICAgICAgICAgeDogTWF0aC5mbG9vcih3aWR0aCAqIHRoaXNIYWxmU2FtcGxlKSxcclxuICAgICAgICAgICAgeTogTWF0aC5mbG9vcihoZWlnaHQgKiB0aGlzSGFsZlNhbXBsZSksXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgcGF0Y2hTaXplID0gY2FsY3VsYXRlUGF0Y2hTaXplKGNvbmZpZy5wYXRjaFNpemUsIHNpemUpO1xyXG4gICAgICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coYFBhdGNoLVNpemU6ICR7SlNPTi5zdHJpbmdpZnkocGF0Y2hTaXplKX1gKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlucHV0U3RyZWFtLnNldFdpZHRoKE1hdGguZmxvb3IoTWF0aC5mbG9vcihzaXplLnggLyBwYXRjaFNpemUueCkgKiAoMSAvIHRoaXNIYWxmU2FtcGxlKSAqIHBhdGNoU2l6ZS54KSk7XHJcbiAgICAgICAgaW5wdXRTdHJlYW0uc2V0SGVpZ2h0KE1hdGguZmxvb3IoTWF0aC5mbG9vcihzaXplLnkgLyBwYXRjaFNpemUueSkgKiAoMSAvIHRoaXNIYWxmU2FtcGxlKSAqIHBhdGNoU2l6ZS55KSk7XHJcblxyXG4gICAgICAgIGlmICgoaW5wdXRTdHJlYW0uZ2V0V2lkdGgoKSAlIHBhdGNoU2l6ZS54KSA9PT0gMCAmJiAoaW5wdXRTdHJlYW0uZ2V0SGVpZ2h0KCkgJSBwYXRjaFNpemUueSkgPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEltYWdlIGRpbWVuc2lvbnMgZG8gbm90IGNvbXBseSB3aXRoIHRoZSBjdXJyZW50IHNldHRpbmdzOiBXaWR0aCAoJHtcclxuICAgICAgICAgICAgd2lkdGh9IClhbmQgaGVpZ2h0ICgke2hlaWdodFxyXG4gICAgICAgIH0pIG11c3QgYSBtdWx0aXBsZSBvZiAke3BhdGNoU2l6ZS54fWApO1xyXG4gICAgfSxcclxufTtcclxuIiwidmFyIGxpc3RDYWNoZUNsZWFyID0gcmVxdWlyZSgnLi9fbGlzdENhY2hlQ2xlYXInKSxcbiAgICBsaXN0Q2FjaGVEZWxldGUgPSByZXF1aXJlKCcuL19saXN0Q2FjaGVEZWxldGUnKSxcbiAgICBsaXN0Q2FjaGVHZXQgPSByZXF1aXJlKCcuL19saXN0Q2FjaGVHZXQnKSxcbiAgICBsaXN0Q2FjaGVIYXMgPSByZXF1aXJlKCcuL19saXN0Q2FjaGVIYXMnKSxcbiAgICBsaXN0Q2FjaGVTZXQgPSByZXF1aXJlKCcuL19saXN0Q2FjaGVTZXQnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGxpc3QgY2FjaGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBMaXN0Q2FjaGUoZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgTGlzdENhY2hlYC5cbkxpc3RDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBsaXN0Q2FjaGVDbGVhcjtcbkxpc3RDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbGlzdENhY2hlRGVsZXRlO1xuTGlzdENhY2hlLnByb3RvdHlwZS5nZXQgPSBsaXN0Q2FjaGVHZXQ7XG5MaXN0Q2FjaGUucHJvdG90eXBlLmhhcyA9IGxpc3RDYWNoZUhhcztcbkxpc3RDYWNoZS5wcm90b3R5cGUuc2V0ID0gbGlzdENhY2hlU2V0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IExpc3RDYWNoZTtcbiIsInZhciBlcSA9IHJlcXVpcmUoJy4vZXEnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgYGtleWAgaXMgZm91bmQgaW4gYGFycmF5YCBvZiBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHsqfSBrZXkgVGhlIGtleSB0byBzZWFyY2ggZm9yLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAqL1xuZnVuY3Rpb24gYXNzb2NJbmRleE9mKGFycmF5LCBrZXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgaWYgKGVxKGFycmF5W2xlbmd0aF1bMF0sIGtleSkpIHtcbiAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhc3NvY0luZGV4T2Y7XG4iLCIvKipcbiAqIFBlcmZvcm1zIGFcbiAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmUgZXF1aXZhbGVudC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2EnOiAxIH07XG4gKlxuICogXy5lcShvYmplY3QsIG9iamVjdCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcShvYmplY3QsIG90aGVyKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcSgnYScsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcSgnYScsIE9iamVjdCgnYScpKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcShOYU4sIE5hTik7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGVxKHZhbHVlLCBvdGhlcikge1xuICByZXR1cm4gdmFsdWUgPT09IG90aGVyIHx8ICh2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlcTtcbiIsInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBTeW1ib2wgPSByb290LlN5bWJvbDtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW1ib2w7XG4iLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBuYXRpdmVDcmVhdGUgPSBnZXROYXRpdmUoT2JqZWN0LCAnY3JlYXRlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gbmF0aXZlQ3JlYXRlO1xuIiwidmFyIGlzS2V5YWJsZSA9IHJlcXVpcmUoJy4vX2lzS2V5YWJsZScpO1xuXG4vKipcbiAqIEdldHMgdGhlIGRhdGEgZm9yIGBtYXBgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSByZWZlcmVuY2Uga2V5LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1hcCBkYXRhLlxuICovXG5mdW5jdGlvbiBnZXRNYXBEYXRhKG1hcCwga2V5KSB7XG4gIHZhciBkYXRhID0gbWFwLl9fZGF0YV9fO1xuICByZXR1cm4gaXNLZXlhYmxlKGtleSlcbiAgICA/IGRhdGFbdHlwZW9mIGtleSA9PSAnc3RyaW5nJyA/ICdzdHJpbmcnIDogJ2hhc2gnXVxuICAgIDogZGF0YS5tYXA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0TWFwRGF0YTtcbiIsInZhciBiYXNlSXNBcmd1bWVudHMgPSByZXF1aXJlKCcuL19iYXNlSXNBcmd1bWVudHMnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhbiBgYXJndW1lbnRzYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcmd1bWVudHMgPSBiYXNlSXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPyBiYXNlSXNBcmd1bWVudHMgOiBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnY2FsbGVlJykgJiZcbiAgICAhcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc0FyZ3VtZW50cztcbiIsIi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuICovXG52YXIgcmVJc1VpbnQgPSAvXig/OjB8WzEtOV1cXGQqKSQvO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBpbmRleC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD1NQVhfU0FGRV9JTlRFR0VSXSBUaGUgdXBwZXIgYm91bmRzIG9mIGEgdmFsaWQgaW5kZXguXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGluZGV4LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSW5kZXgodmFsdWUsIGxlbmd0aCkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyBNQVhfU0FGRV9JTlRFR0VSIDogbGVuZ3RoO1xuXG4gIHJldHVybiAhIWxlbmd0aCAmJlxuICAgICh0eXBlID09ICdudW1iZXInIHx8XG4gICAgICAodHlwZSAhPSAnc3ltYm9sJyAmJiByZUlzVWludC50ZXN0KHZhbHVlKSkpICYmXG4gICAgICAgICh2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDwgbGVuZ3RoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0luZGV4O1xuIiwidmFyIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc0tleSA9IHJlcXVpcmUoJy4vX2lzS2V5JyksXG4gICAgc3RyaW5nVG9QYXRoID0gcmVxdWlyZSgnLi9fc3RyaW5nVG9QYXRoJyksXG4gICAgdG9TdHJpbmcgPSByZXF1aXJlKCcuL3RvU3RyaW5nJyk7XG5cbi8qKlxuICogQ2FzdHMgYHZhbHVlYCB0byBhIHBhdGggYXJyYXkgaWYgaXQncyBub3Qgb25lLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkga2V5cyBvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY2FzdCBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICovXG5mdW5jdGlvbiBjYXN0UGF0aCh2YWx1ZSwgb2JqZWN0KSB7XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByZXR1cm4gaXNLZXkodmFsdWUsIG9iamVjdCkgPyBbdmFsdWVdIDogc3RyaW5nVG9QYXRoKHRvU3RyaW5nKHZhbHVlKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2FzdFBhdGg7XG4iLCJ2YXIgYXJyYXlXaXRoSG9sZXMgPSByZXF1aXJlKFwiLi9hcnJheVdpdGhIb2xlcy5qc1wiKTtcblxudmFyIGl0ZXJhYmxlVG9BcnJheUxpbWl0ID0gcmVxdWlyZShcIi4vaXRlcmFibGVUb0FycmF5TGltaXQuanNcIik7XG5cbnZhciB1bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSA9IHJlcXVpcmUoXCIuL3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5LmpzXCIpO1xuXG52YXIgbm9uSXRlcmFibGVSZXN0ID0gcmVxdWlyZShcIi4vbm9uSXRlcmFibGVSZXN0LmpzXCIpO1xuXG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHtcbiAgcmV0dXJuIGFycmF5V2l0aEhvbGVzKGFycikgfHwgaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB8fCB1bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIsIGkpIHx8IG5vbkl0ZXJhYmxlUmVzdCgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9zbGljZWRUb0FycmF5O1xubW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlOyIsInZhciBhcnJheVdpdGhvdXRIb2xlcyA9IHJlcXVpcmUoXCIuL2FycmF5V2l0aG91dEhvbGVzLmpzXCIpO1xuXG52YXIgaXRlcmFibGVUb0FycmF5ID0gcmVxdWlyZShcIi4vaXRlcmFibGVUb0FycmF5LmpzXCIpO1xuXG52YXIgdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkgPSByZXF1aXJlKFwiLi91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheS5qc1wiKTtcblxudmFyIG5vbkl0ZXJhYmxlU3ByZWFkID0gcmVxdWlyZShcIi4vbm9uSXRlcmFibGVTcHJlYWQuanNcIik7XG5cbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHtcbiAgcmV0dXJuIGFycmF5V2l0aG91dEhvbGVzKGFycikgfHwgaXRlcmFibGVUb0FycmF5KGFycikgfHwgdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBub25JdGVyYWJsZVNwcmVhZCgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF90b0NvbnN1bWFibGVBcnJheTtcbm1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsiLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBkZXRlcm1pbmFudDogcmVxdWlyZSgnLi9kZXRlcm1pbmFudCcpXG4gICwgdHJhbnNwb3NlOiByZXF1aXJlKCcuL3RyYW5zcG9zZScpXG4gICwgbXVsdGlwbHk6IHJlcXVpcmUoJy4vbXVsdGlwbHknKVxuICAsIGlkZW50aXR5OiByZXF1aXJlKCcuL2lkZW50aXR5JylcbiAgLCBhZGpvaW50OiByZXF1aXJlKCcuL2Fkam9pbnQnKVxuICAsIHJvdGF0ZTogcmVxdWlyZSgnLi9yb3RhdGUnKVxuICAsIGludmVydDogcmVxdWlyZSgnLi9pbnZlcnQnKVxuICAsIGNyZWF0ZTogcmVxdWlyZSgnLi9jcmVhdGUnKVxuICAsIHNjYWxlOiByZXF1aXJlKCcuL3NjYWxlJylcbiAgLCBjb3B5OiByZXF1aXJlKCcuL2NvcHknKVxuICAsIGZyb2I6IHJlcXVpcmUoJy4vZnJvYicpXG4gICwgbGR1OiByZXF1aXJlKCcuL2xkdScpXG59XG4iLCJ2YXIgYmFzZUlzTmF0aXZlID0gcmVxdWlyZSgnLi9fYmFzZUlzTmF0aXZlJyksXG4gICAgZ2V0VmFsdWUgPSByZXF1aXJlKCcuL19nZXRWYWx1ZScpO1xuXG4vKipcbiAqIEdldHMgdGhlIG5hdGl2ZSBmdW5jdGlvbiBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBtZXRob2QgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZ1bmN0aW9uIGlmIGl0J3MgbmF0aXZlLCBlbHNlIGB1bmRlZmluZWRgLlxuICovXG5mdW5jdGlvbiBnZXROYXRpdmUob2JqZWN0LCBrZXkpIHtcbiAgdmFyIHZhbHVlID0gZ2V0VmFsdWUob2JqZWN0LCBrZXkpO1xuICByZXR1cm4gYmFzZUlzTmF0aXZlKHZhbHVlKSA/IHZhbHVlIDogdW5kZWZpbmVkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldE5hdGl2ZTtcbiIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXN5bmNUYWcgPSAnW29iamVjdCBBc3luY0Z1bmN0aW9uXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJyxcbiAgICBwcm94eVRhZyA9ICdbb2JqZWN0IFByb3h5XSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0Z1bmN0aW9uKF8pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAvLyBpbiBTYWZhcmkgOSB3aGljaCByZXR1cm5zICdvYmplY3QnIGZvciB0eXBlZCBhcnJheXMgYW5kIG90aGVyIGNvbnN0cnVjdG9ycy5cbiAgdmFyIHRhZyA9IGJhc2VHZXRUYWcodmFsdWUpO1xuICByZXR1cm4gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZyB8fCB0YWcgPT0gYXN5bmNUYWcgfHwgdGFnID09IHByb3h5VGFnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzRnVuY3Rpb247XG4iLCJ2YXIgZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL19kZWZpbmVQcm9wZXJ0eScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBhc3NpZ25WYWx1ZWAgYW5kIGBhc3NpZ25NZXJnZVZhbHVlYCB3aXRob3V0XG4gKiB2YWx1ZSBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAqL1xuZnVuY3Rpb24gYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5ID09ICdfX3Byb3RvX18nICYmIGRlZmluZVByb3BlcnR5KSB7XG4gICAgZGVmaW5lUHJvcGVydHkob2JqZWN0LCBrZXksIHtcbiAgICAgICdjb25maWd1cmFibGUnOiB0cnVlLFxuICAgICAgJ2VudW1lcmFibGUnOiB0cnVlLFxuICAgICAgJ3ZhbHVlJzogdmFsdWUsXG4gICAgICAnd3JpdGFibGUnOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VBc3NpZ25WYWx1ZTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obW9kdWxlKSB7XG5cdGlmICghbW9kdWxlLndlYnBhY2tQb2x5ZmlsbCkge1xuXHRcdG1vZHVsZS5kZXByZWNhdGUgPSBmdW5jdGlvbigpIHt9O1xuXHRcdG1vZHVsZS5wYXRocyA9IFtdO1xuXHRcdC8vIG1vZHVsZS5wYXJlbnQgPSB1bmRlZmluZWQgYnkgZGVmYXVsdFxuXHRcdGlmICghbW9kdWxlLmNoaWxkcmVuKSBtb2R1bGUuY2hpbGRyZW4gPSBbXTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImxvYWRlZFwiLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5sO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwiaWRcIiwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBtb2R1bGUuaTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRtb2R1bGUud2VicGFja1BvbHlmaWxsID0gMTtcblx0fVxuXHRyZXR1cm4gbW9kdWxlO1xufTtcbiIsInZhciBpc0Z1bmN0aW9uID0gcmVxdWlyZSgnLi9pc0Z1bmN0aW9uJyksXG4gICAgaXNMZW5ndGggPSByZXF1aXJlKCcuL2lzTGVuZ3RoJyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZS4gQSB2YWx1ZSBpcyBjb25zaWRlcmVkIGFycmF5LWxpa2UgaWYgaXQnc1xuICogbm90IGEgZnVuY3Rpb24gYW5kIGhhcyBhIGB2YWx1ZS5sZW5ndGhgIHRoYXQncyBhbiBpbnRlZ2VyIGdyZWF0ZXIgdGhhbiBvclxuICogZXF1YWwgdG8gYDBgIGFuZCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYE51bWJlci5NQVhfU0FGRV9JTlRFR0VSYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoJ2FiYycpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgIWlzRnVuY3Rpb24odmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQXJyYXlMaWtlO1xuIiwiLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGxlbmd0aC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvblxuICogW2BUb0xlbmd0aGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvbGVuZ3RoKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGxlbmd0aCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzTGVuZ3RoKDMpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNMZW5ndGgoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoSW5maW5pdHkpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKCczJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0xlbmd0aCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmXG4gICAgdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzTGVuZ3RoO1xuIiwiZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgcmV0dXJuIG87XG4gIH07XG5cbiAgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9zZXRQcm90b3R5cGVPZjtcbm1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsiLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTeW1ib2xgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzeW1ib2wsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1N5bWJvbChTeW1ib2wuaXRlcmF0b3IpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNTeW1ib2woJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTeW1ib2wodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3ltYm9sJyB8fFxuICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IHN5bWJvbFRhZyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNTeW1ib2w7XG4iLCJ2YXIgaXNTeW1ib2wgPSByZXF1aXJlKCcuL2lzU3ltYm9sJyk7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZID0gMSAvIDA7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyBrZXkgaWYgaXQncyBub3QgYSBzdHJpbmcgb3Igc3ltYm9sLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICogQHJldHVybnMge3N0cmluZ3xzeW1ib2x9IFJldHVybnMgdGhlIGtleS5cbiAqL1xuZnVuY3Rpb24gdG9LZXkodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fCBpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvS2V5O1xuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpLFxuICAgIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBNYXAgPSBnZXROYXRpdmUocm9vdCwgJ01hcCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1hcDtcbiIsIi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsICYmIGdsb2JhbC5PYmplY3QgPT09IE9iamVjdCAmJiBnbG9iYWw7XG5cbm1vZHVsZS5leHBvcnRzID0gZnJlZUdsb2JhbDtcbiIsInZhciBnO1xuXG4vLyBUaGlzIHdvcmtzIGluIG5vbi1zdHJpY3QgbW9kZVxuZyA9IChmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXM7XG59KSgpO1xuXG50cnkge1xuXHQvLyBUaGlzIHdvcmtzIGlmIGV2YWwgaXMgYWxsb3dlZCAoc2VlIENTUClcblx0ZyA9IGcgfHwgbmV3IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKTtcbn0gY2F0Y2ggKGUpIHtcblx0Ly8gVGhpcyB3b3JrcyBpZiB0aGUgd2luZG93IHJlZmVyZW5jZSBpcyBhdmFpbGFibGVcblx0aWYgKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpIGcgPSB3aW5kb3c7XG59XG5cbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cbi8vIFdlIHJldHVybiB1bmRlZmluZWQsIGluc3RlYWQgb2Ygbm90aGluZyBoZXJlLCBzbyBpdCdzXG4vLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XG5cbm1vZHVsZS5leHBvcnRzID0gZztcbiIsInZhciBtYXBDYWNoZUNsZWFyID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVDbGVhcicpLFxuICAgIG1hcENhY2hlRGVsZXRlID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVEZWxldGUnKSxcbiAgICBtYXBDYWNoZUdldCA9IHJlcXVpcmUoJy4vX21hcENhY2hlR2V0JyksXG4gICAgbWFwQ2FjaGVIYXMgPSByZXF1aXJlKCcuL19tYXBDYWNoZUhhcycpLFxuICAgIG1hcENhY2hlU2V0ID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVTZXQnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbWFwIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIE1hcENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYE1hcENhY2hlYC5cbk1hcENhY2hlLnByb3RvdHlwZS5jbGVhciA9IG1hcENhY2hlQ2xlYXI7XG5NYXBDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbWFwQ2FjaGVEZWxldGU7XG5NYXBDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbWFwQ2FjaGVHZXQ7XG5NYXBDYWNoZS5wcm90b3R5cGUuaGFzID0gbWFwQ2FjaGVIYXM7XG5NYXBDYWNoZS5wcm90b3R5cGUuc2V0ID0gbWFwQ2FjaGVTZXQ7XG5cbm1vZHVsZS5leHBvcnRzID0gTWFwQ2FjaGU7XG4iLCJ2YXIgYmFzZUFzc2lnblZhbHVlID0gcmVxdWlyZSgnLi9fYmFzZUFzc2lnblZhbHVlJyksXG4gICAgZXEgPSByZXF1aXJlKCcuL2VxJyk7XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlIGBhc3NpZ25WYWx1ZWAgZXhjZXB0IHRoYXQgaXQgZG9lc24ndCBhc3NpZ25cbiAqIGB1bmRlZmluZWRgIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuICovXG5mdW5jdGlvbiBhc3NpZ25NZXJnZVZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICBpZiAoKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgIWVxKG9iamVjdFtrZXldLCB2YWx1ZSkpIHx8XG4gICAgICAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSkge1xuICAgIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXNzaWduTWVyZ2VWYWx1ZTtcbiIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKTtcblxudmFyIGRlZmluZVByb3BlcnR5ID0gKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIHZhciBmdW5jID0gZ2V0TmF0aXZlKE9iamVjdCwgJ2RlZmluZVByb3BlcnR5Jyk7XG4gICAgZnVuYyh7fSwgJycsIHt9KTtcbiAgICByZXR1cm4gZnVuYztcbiAgfSBjYXRjaCAoZSkge31cbn0oKSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZGVmaW5lUHJvcGVydHk7XG4iLCJ2YXIgb3ZlckFyZyA9IHJlcXVpcmUoJy4vX292ZXJBcmcnKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgZ2V0UHJvdG90eXBlID0gb3ZlckFyZyhPYmplY3QuZ2V0UHJvdG90eXBlT2YsIE9iamVjdCk7XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0UHJvdG90eXBlO1xuIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYSBwcm90b3R5cGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvdG90eXBlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzUHJvdG90eXBlKHZhbHVlKSB7XG4gIHZhciBDdG9yID0gdmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IsXG4gICAgICBwcm90byA9ICh0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IucHJvdG90eXBlKSB8fCBvYmplY3RQcm90bztcblxuICByZXR1cm4gdmFsdWUgPT09IHByb3RvO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzUHJvdG90eXBlO1xuIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290JyksXG4gICAgc3R1YkZhbHNlID0gcmVxdWlyZSgnLi9zdHViRmFsc2UnKTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbnZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xudmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbnZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBCdWZmZXIgPSBtb2R1bGVFeHBvcnRzID8gcm9vdC5CdWZmZXIgOiB1bmRlZmluZWQ7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVJc0J1ZmZlciA9IEJ1ZmZlciA/IEJ1ZmZlci5pc0J1ZmZlciA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMy4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlciwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQnVmZmVyKG5ldyBCdWZmZXIoMikpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNCdWZmZXIobmV3IFVpbnQ4QXJyYXkoMikpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQnVmZmVyID0gbmF0aXZlSXNCdWZmZXIgfHwgc3R1YkZhbHNlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQnVmZmVyO1xuIiwidmFyIGJhc2VJc1R5cGVkQXJyYXkgPSByZXF1aXJlKCcuL19iYXNlSXNUeXBlZEFycmF5JyksXG4gICAgYmFzZVVuYXJ5ID0gcmVxdWlyZSgnLi9fYmFzZVVuYXJ5JyksXG4gICAgbm9kZVV0aWwgPSByZXF1aXJlKCcuL19ub2RlVXRpbCcpO1xuXG4vKiBOb2RlLmpzIGhlbHBlciByZWZlcmVuY2VzLiAqL1xudmFyIG5vZGVJc1R5cGVkQXJyYXkgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc1R5cGVkQXJyYXk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIHR5cGVkIGFycmF5LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1R5cGVkQXJyYXkobmV3IFVpbnQ4QXJyYXkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KFtdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc1R5cGVkQXJyYXkgPSBub2RlSXNUeXBlZEFycmF5ID8gYmFzZVVuYXJ5KG5vZGVJc1R5cGVkQXJyYXkpIDogYmFzZUlzVHlwZWRBcnJheTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc1R5cGVkQXJyYXk7XG4iLCIvKipcbiAqIEdldHMgdGhlIHZhbHVlIGF0IGBrZXlgLCB1bmxlc3MgYGtleWAgaXMgXCJfX3Byb3RvX19cIiBvciBcImNvbnN0cnVjdG9yXCIuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBzYWZlR2V0KG9iamVjdCwga2V5KSB7XG4gIGlmIChrZXkgPT09ICdjb25zdHJ1Y3RvcicgJiYgdHlwZW9mIG9iamVjdFtrZXldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGtleSA9PSAnX19wcm90b19fJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHJldHVybiBvYmplY3Rba2V5XTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzYWZlR2V0O1xuIiwidmFyIGJhc2VBc3NpZ25WYWx1ZSA9IHJlcXVpcmUoJy4vX2Jhc2VBc3NpZ25WYWx1ZScpLFxuICAgIGVxID0gcmVxdWlyZSgnLi9lcScpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEFzc2lnbnMgYHZhbHVlYCB0byBga2V5YCBvZiBgb2JqZWN0YCBpZiB0aGUgZXhpc3RpbmcgdmFsdWUgaXMgbm90IGVxdWl2YWxlbnRcbiAqIHVzaW5nIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAqL1xuZnVuY3Rpb24gYXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIHZhciBvYmpWYWx1ZSA9IG9iamVjdFtrZXldO1xuICBpZiAoIShoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSAmJiBlcShvYmpWYWx1ZSwgdmFsdWUpKSB8fFxuICAgICAgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkpIHtcbiAgICBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFzc2lnblZhbHVlO1xuIiwidmFyIGFycmF5TGlrZUtleXMgPSByZXF1aXJlKCcuL19hcnJheUxpa2VLZXlzJyksXG4gICAgYmFzZUtleXNJbiA9IHJlcXVpcmUoJy4vX2Jhc2VLZXlzSW4nKSxcbiAgICBpc0FycmF5TGlrZSA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2UnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8ua2V5c0luKG5ldyBGb28pO1xuICogLy8gPT4gWydhJywgJ2InLCAnYyddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKi9cbmZ1bmN0aW9uIGtleXNJbihvYmplY3QpIHtcbiAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iamVjdCkgPyBhcnJheUxpa2VLZXlzKG9iamVjdCwgdHJ1ZSkgOiBiYXNlS2V5c0luKG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ga2V5c0luO1xuIiwiLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIHRoZSBmaXJzdCBhcmd1bWVudCBpdCByZWNlaXZlcy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHsqfSB2YWx1ZSBBbnkgdmFsdWUuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyBgdmFsdWVgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqXG4gKiBjb25zb2xlLmxvZyhfLmlkZW50aXR5KG9iamVjdCkgPT09IG9iamVjdCk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGlkZW50aXR5KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpZGVudGl0eTtcbiIsInZhciBhcHBseSA9IHJlcXVpcmUoJy4vX2FwcGx5Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVNYXggPSBNYXRoLm1heDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VSZXN0YCB3aGljaCB0cmFuc2Zvcm1zIHRoZSByZXN0IGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD1mdW5jLmxlbmd0aC0xXSBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHJlc3QgcGFyYW1ldGVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSByZXN0IGFycmF5IHRyYW5zZm9ybS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBvdmVyUmVzdChmdW5jLCBzdGFydCwgdHJhbnNmb3JtKSB7XG4gIHN0YXJ0ID0gbmF0aXZlTWF4KHN0YXJ0ID09PSB1bmRlZmluZWQgPyAoZnVuYy5sZW5ndGggLSAxKSA6IHN0YXJ0LCAwKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBuYXRpdmVNYXgoYXJncy5sZW5ndGggLSBzdGFydCwgMCksXG4gICAgICAgIGFycmF5ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBhcnJheVtpbmRleF0gPSBhcmdzW3N0YXJ0ICsgaW5kZXhdO1xuICAgIH1cbiAgICBpbmRleCA9IC0xO1xuICAgIHZhciBvdGhlckFyZ3MgPSBBcnJheShzdGFydCArIDEpO1xuICAgIHdoaWxlICgrK2luZGV4IDwgc3RhcnQpIHtcbiAgICAgIG90aGVyQXJnc1tpbmRleF0gPSBhcmdzW2luZGV4XTtcbiAgICB9XG4gICAgb3RoZXJBcmdzW3N0YXJ0XSA9IHRyYW5zZm9ybShhcnJheSk7XG4gICAgcmV0dXJuIGFwcGx5KGZ1bmMsIHRoaXMsIG90aGVyQXJncyk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gb3ZlclJlc3Q7XG4iLCJ2YXIgYmFzZVNldFRvU3RyaW5nID0gcmVxdWlyZSgnLi9fYmFzZVNldFRvU3RyaW5nJyksXG4gICAgc2hvcnRPdXQgPSByZXF1aXJlKCcuL19zaG9ydE91dCcpO1xuXG4vKipcbiAqIFNldHMgdGhlIGB0b1N0cmluZ2AgbWV0aG9kIG9mIGBmdW5jYCB0byByZXR1cm4gYHN0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN0cmluZyBUaGUgYHRvU3RyaW5nYCByZXN1bHQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGZ1bmNgLlxuICovXG52YXIgc2V0VG9TdHJpbmcgPSBzaG9ydE91dChiYXNlU2V0VG9TdHJpbmcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHNldFRvU3RyaW5nO1xuIiwidmFyIGFycmF5TGlrZVRvQXJyYXkgPSByZXF1aXJlKFwiLi9hcnJheUxpa2VUb0FycmF5LmpzXCIpO1xuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7XG4gIGlmICghbykgcmV0dXJuO1xuICBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBhcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG4gIHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTtcbiAgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTtcbiAgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7XG4gIGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheTtcbm1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsiLCJmdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikge1xuICBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHtcbiAgICBhcnIyW2ldID0gYXJyW2ldO1xuICB9XG5cbiAgcmV0dXJuIGFycjI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2FycmF5TGlrZVRvQXJyYXk7XG5tb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7IiwibW9kdWxlLmV4cG9ydHMgPSAwLjAwMDAwMVxuIiwibW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3LCBlbXB0eSB2ZWMyXG4gKlxuICogQHJldHVybnMge3ZlYzJ9IGEgbmV3IDJEIHZlY3RvclxuICovXG5mdW5jdGlvbiBjcmVhdGUoKSB7XG4gICAgdmFyIG91dCA9IG5ldyBGbG9hdDMyQXJyYXkoMilcbiAgICBvdXRbMF0gPSAwXG4gICAgb3V0WzFdID0gMFxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IHN1YnRyYWN0XG5cbi8qKlxuICogU3VidHJhY3RzIHZlY3RvciBiIGZyb20gdmVjdG9yIGFcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmZ1bmN0aW9uIHN1YnRyYWN0KG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gLSBiWzBdXG4gICAgb3V0WzFdID0gYVsxXSAtIGJbMV1cbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSBtdWx0aXBseVxuXG4vKipcbiAqIE11bHRpcGxpZXMgdHdvIHZlYzInc1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZnVuY3Rpb24gbXVsdGlwbHkob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAqIGJbMF1cbiAgICBvdXRbMV0gPSBhWzFdICogYlsxXVxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IGRpdmlkZVxuXG4vKipcbiAqIERpdmlkZXMgdHdvIHZlYzInc1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZnVuY3Rpb24gZGl2aWRlKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gLyBiWzBdXG4gICAgb3V0WzFdID0gYVsxXSAvIGJbMV1cbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSBkaXN0YW5jZVxuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGV1Y2xpZGlhbiBkaXN0YW5jZSBiZXR3ZWVuIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxuICovXG5mdW5jdGlvbiBkaXN0YW5jZShhLCBiKSB7XG4gICAgdmFyIHggPSBiWzBdIC0gYVswXSxcbiAgICAgICAgeSA9IGJbMV0gLSBhWzFdXG4gICAgcmV0dXJuIE1hdGguc3FydCh4KnggKyB5KnkpXG59IiwibW9kdWxlLmV4cG9ydHMgPSBzcXVhcmVkRGlzdGFuY2VcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBzcXVhcmVkIGV1Y2xpZGlhbiBkaXN0YW5jZSBiZXR3ZWVuIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHNxdWFyZWQgZGlzdGFuY2UgYmV0d2VlbiBhIGFuZCBiXG4gKi9cbmZ1bmN0aW9uIHNxdWFyZWREaXN0YW5jZShhLCBiKSB7XG4gICAgdmFyIHggPSBiWzBdIC0gYVswXSxcbiAgICAgICAgeSA9IGJbMV0gLSBhWzFdXG4gICAgcmV0dXJuIHgqeCArIHkqeVxufSIsIm1vZHVsZS5leHBvcnRzID0gbGVuZ3RoXG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgbGVuZ3RoIG9mIGEgdmVjMlxuICpcbiAqIEBwYXJhbSB7dmVjMn0gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIGxlbmd0aCBvZlxuICogQHJldHVybnMge051bWJlcn0gbGVuZ3RoIG9mIGFcbiAqL1xuZnVuY3Rpb24gbGVuZ3RoKGEpIHtcbiAgICB2YXIgeCA9IGFbMF0sXG4gICAgICAgIHkgPSBhWzFdXG4gICAgcmV0dXJuIE1hdGguc3FydCh4KnggKyB5KnkpXG59IiwibW9kdWxlLmV4cG9ydHMgPSBzcXVhcmVkTGVuZ3RoXG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBsZW5ndGggb2YgYSB2ZWMyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBhIHZlY3RvciB0byBjYWxjdWxhdGUgc3F1YXJlZCBsZW5ndGggb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHNxdWFyZWQgbGVuZ3RoIG9mIGFcbiAqL1xuZnVuY3Rpb24gc3F1YXJlZExlbmd0aChhKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXVxuICAgIHJldHVybiB4KnggKyB5Knlcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IDAuMDAwMDAxXG4iLCJtb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3LCBlbXB0eSB2ZWMzXG4gKlxuICogQHJldHVybnMge3ZlYzN9IGEgbmV3IDNEIHZlY3RvclxuICovXG5mdW5jdGlvbiBjcmVhdGUoKSB7XG4gICAgdmFyIG91dCA9IG5ldyBGbG9hdDMyQXJyYXkoMylcbiAgICBvdXRbMF0gPSAwXG4gICAgb3V0WzFdID0gMFxuICAgIG91dFsyXSA9IDBcbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSBmcm9tVmFsdWVzO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgdmVjMyBpbml0aWFsaXplZCB3aXRoIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0geCBYIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB6IFogY29tcG9uZW50XG4gKiBAcmV0dXJucyB7dmVjM30gYSBuZXcgM0QgdmVjdG9yXG4gKi9cbmZ1bmN0aW9uIGZyb21WYWx1ZXMoeCwgeSwgeikge1xuICAgIHZhciBvdXQgPSBuZXcgRmxvYXQzMkFycmF5KDMpXG4gICAgb3V0WzBdID0geFxuICAgIG91dFsxXSA9IHlcbiAgICBvdXRbMl0gPSB6XG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gbm9ybWFsaXplO1xuXG4vKipcbiAqIE5vcm1hbGl6ZSBhIHZlYzNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHZlY3RvciB0byBub3JtYWxpemVcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplKG91dCwgYSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV0sXG4gICAgICAgIHogPSBhWzJdXG4gICAgdmFyIGxlbiA9IHgqeCArIHkqeSArIHoqelxuICAgIGlmIChsZW4gPiAwKSB7XG4gICAgICAgIC8vVE9ETzogZXZhbHVhdGUgdXNlIG9mIGdsbV9pbnZzcXJ0IGhlcmU/XG4gICAgICAgIGxlbiA9IDEgLyBNYXRoLnNxcnQobGVuKVxuICAgICAgICBvdXRbMF0gPSBhWzBdICogbGVuXG4gICAgICAgIG91dFsxXSA9IGFbMV0gKiBsZW5cbiAgICAgICAgb3V0WzJdID0gYVsyXSAqIGxlblxuICAgIH1cbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSBkb3Q7XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZG90IHByb2R1Y3Qgb2YgdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gZG90IHByb2R1Y3Qgb2YgYSBhbmQgYlxuICovXG5mdW5jdGlvbiBkb3QoYSwgYikge1xuICAgIHJldHVybiBhWzBdICogYlswXSArIGFbMV0gKiBiWzFdICsgYVsyXSAqIGJbMl1cbn0iLCJtb2R1bGUuZXhwb3J0cyA9IHN1YnRyYWN0O1xuXG4vKipcbiAqIFN1YnRyYWN0cyB2ZWN0b3IgYiBmcm9tIHZlY3RvciBhXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5mdW5jdGlvbiBzdWJ0cmFjdChvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdIC0gYlswXVxuICAgIG91dFsxXSA9IGFbMV0gLSBiWzFdXG4gICAgb3V0WzJdID0gYVsyXSAtIGJbMl1cbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSBtdWx0aXBseTtcblxuLyoqXG4gKiBNdWx0aXBsaWVzIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmZ1bmN0aW9uIG11bHRpcGx5KG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gKiBiWzBdXG4gICAgb3V0WzFdID0gYVsxXSAqIGJbMV1cbiAgICBvdXRbMl0gPSBhWzJdICogYlsyXVxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IGRpdmlkZTtcblxuLyoqXG4gKiBEaXZpZGVzIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmZ1bmN0aW9uIGRpdmlkZShvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdIC8gYlswXVxuICAgIG91dFsxXSA9IGFbMV0gLyBiWzFdXG4gICAgb3V0WzJdID0gYVsyXSAvIGJbMl1cbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSBkaXN0YW5jZTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcbiAqL1xuZnVuY3Rpb24gZGlzdGFuY2UoYSwgYikge1xuICAgIHZhciB4ID0gYlswXSAtIGFbMF0sXG4gICAgICAgIHkgPSBiWzFdIC0gYVsxXSxcbiAgICAgICAgeiA9IGJbMl0gLSBhWzJdXG4gICAgcmV0dXJuIE1hdGguc3FydCh4KnggKyB5KnkgKyB6KnopXG59IiwibW9kdWxlLmV4cG9ydHMgPSBzcXVhcmVkRGlzdGFuY2U7XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxuICovXG5mdW5jdGlvbiBzcXVhcmVkRGlzdGFuY2UoYSwgYikge1xuICAgIHZhciB4ID0gYlswXSAtIGFbMF0sXG4gICAgICAgIHkgPSBiWzFdIC0gYVsxXSxcbiAgICAgICAgeiA9IGJbMl0gLSBhWzJdXG4gICAgcmV0dXJuIHgqeCArIHkqeSArIHoqelxufSIsIm1vZHVsZS5leHBvcnRzID0gbGVuZ3RoO1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGxlbmd0aCBvZiBhIHZlYzNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBsZW5ndGggb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGxlbmd0aCBvZiBhXG4gKi9cbmZ1bmN0aW9uIGxlbmd0aChhKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXSxcbiAgICAgICAgeiA9IGFbMl1cbiAgICByZXR1cm4gTWF0aC5zcXJ0KHgqeCArIHkqeSArIHoqeilcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IHNxdWFyZWRMZW5ndGg7XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBsZW5ndGggb2YgYSB2ZWMzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBhIHZlY3RvciB0byBjYWxjdWxhdGUgc3F1YXJlZCBsZW5ndGggb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHNxdWFyZWQgbGVuZ3RoIG9mIGFcbiAqL1xuZnVuY3Rpb24gc3F1YXJlZExlbmd0aChhKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXSxcbiAgICAgICAgeiA9IGFbMl1cbiAgICByZXR1cm4geCp4ICsgeSp5ICsgeip6XG59IiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gIEVQU0lMT046IHJlcXVpcmUoJy4vZXBzaWxvbicpXG4gICwgY3JlYXRlOiByZXF1aXJlKCcuL2NyZWF0ZScpXG4gICwgY2xvbmU6IHJlcXVpcmUoJy4vY2xvbmUnKVxuICAsIGFuZ2xlOiByZXF1aXJlKCcuL2FuZ2xlJylcbiAgLCBmcm9tVmFsdWVzOiByZXF1aXJlKCcuL2Zyb21WYWx1ZXMnKVxuICAsIGNvcHk6IHJlcXVpcmUoJy4vY29weScpXG4gICwgc2V0OiByZXF1aXJlKCcuL3NldCcpXG4gICwgZXF1YWxzOiByZXF1aXJlKCcuL2VxdWFscycpXG4gICwgZXhhY3RFcXVhbHM6IHJlcXVpcmUoJy4vZXhhY3RFcXVhbHMnKVxuICAsIGFkZDogcmVxdWlyZSgnLi9hZGQnKVxuICAsIHN1YnRyYWN0OiByZXF1aXJlKCcuL3N1YnRyYWN0JylcbiAgLCBzdWI6IHJlcXVpcmUoJy4vc3ViJylcbiAgLCBtdWx0aXBseTogcmVxdWlyZSgnLi9tdWx0aXBseScpXG4gICwgbXVsOiByZXF1aXJlKCcuL211bCcpXG4gICwgZGl2aWRlOiByZXF1aXJlKCcuL2RpdmlkZScpXG4gICwgZGl2OiByZXF1aXJlKCcuL2RpdicpXG4gICwgbWluOiByZXF1aXJlKCcuL21pbicpXG4gICwgbWF4OiByZXF1aXJlKCcuL21heCcpXG4gICwgZmxvb3I6IHJlcXVpcmUoJy4vZmxvb3InKVxuICAsIGNlaWw6IHJlcXVpcmUoJy4vY2VpbCcpXG4gICwgcm91bmQ6IHJlcXVpcmUoJy4vcm91bmQnKVxuICAsIHNjYWxlOiByZXF1aXJlKCcuL3NjYWxlJylcbiAgLCBzY2FsZUFuZEFkZDogcmVxdWlyZSgnLi9zY2FsZUFuZEFkZCcpXG4gICwgZGlzdGFuY2U6IHJlcXVpcmUoJy4vZGlzdGFuY2UnKVxuICAsIGRpc3Q6IHJlcXVpcmUoJy4vZGlzdCcpXG4gICwgc3F1YXJlZERpc3RhbmNlOiByZXF1aXJlKCcuL3NxdWFyZWREaXN0YW5jZScpXG4gICwgc3FyRGlzdDogcmVxdWlyZSgnLi9zcXJEaXN0JylcbiAgLCBsZW5ndGg6IHJlcXVpcmUoJy4vbGVuZ3RoJylcbiAgLCBsZW46IHJlcXVpcmUoJy4vbGVuJylcbiAgLCBzcXVhcmVkTGVuZ3RoOiByZXF1aXJlKCcuL3NxdWFyZWRMZW5ndGgnKVxuICAsIHNxckxlbjogcmVxdWlyZSgnLi9zcXJMZW4nKVxuICAsIG5lZ2F0ZTogcmVxdWlyZSgnLi9uZWdhdGUnKVxuICAsIGludmVyc2U6IHJlcXVpcmUoJy4vaW52ZXJzZScpXG4gICwgbm9ybWFsaXplOiByZXF1aXJlKCcuL25vcm1hbGl6ZScpXG4gICwgZG90OiByZXF1aXJlKCcuL2RvdCcpXG4gICwgY3Jvc3M6IHJlcXVpcmUoJy4vY3Jvc3MnKVxuICAsIGxlcnA6IHJlcXVpcmUoJy4vbGVycCcpXG4gICwgcmFuZG9tOiByZXF1aXJlKCcuL3JhbmRvbScpXG4gICwgdHJhbnNmb3JtTWF0NDogcmVxdWlyZSgnLi90cmFuc2Zvcm1NYXQ0JylcbiAgLCB0cmFuc2Zvcm1NYXQzOiByZXF1aXJlKCcuL3RyYW5zZm9ybU1hdDMnKVxuICAsIHRyYW5zZm9ybVF1YXQ6IHJlcXVpcmUoJy4vdHJhbnNmb3JtUXVhdCcpXG4gICwgcm90YXRlWDogcmVxdWlyZSgnLi9yb3RhdGVYJylcbiAgLCByb3RhdGVZOiByZXF1aXJlKCcuL3JvdGF0ZVknKVxuICAsIHJvdGF0ZVo6IHJlcXVpcmUoJy4vcm90YXRlWicpXG4gICwgZm9yRWFjaDogcmVxdWlyZSgnLi9mb3JFYWNoJylcbn1cbiIsInZhciBiYXNlUGljayA9IHJlcXVpcmUoJy4vX2Jhc2VQaWNrJyksXG4gICAgZmxhdFJlc3QgPSByZXF1aXJlKCcuL19mbGF0UmVzdCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIHRoZSBwaWNrZWQgYG9iamVjdGAgcHJvcGVydGllcy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHBhcmFtIHsuLi4oc3RyaW5nfHN0cmluZ1tdKX0gW3BhdGhzXSBUaGUgcHJvcGVydHkgcGF0aHMgdG8gcGljay5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAnMicsICdjJzogMyB9O1xuICpcbiAqIF8ucGljayhvYmplY3QsIFsnYScsICdjJ10pO1xuICogLy8gPT4geyAnYSc6IDEsICdjJzogMyB9XG4gKi9cbnZhciBwaWNrID0gZmxhdFJlc3QoZnVuY3Rpb24ob2JqZWN0LCBwYXRocykge1xuICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB7fSA6IGJhc2VQaWNrKG9iamVjdCwgcGF0aHMpO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gcGljaztcbiIsInZhciBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoXCIuL2dldFByb3RvdHlwZU9mLmpzXCIpO1xuXG52YXIgc2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKFwiLi9zZXRQcm90b3R5cGVPZi5qc1wiKTtcblxudmFyIGlzTmF0aXZlRnVuY3Rpb24gPSByZXF1aXJlKFwiLi9pc05hdGl2ZUZ1bmN0aW9uLmpzXCIpO1xuXG52YXIgY29uc3RydWN0ID0gcmVxdWlyZShcIi4vY29uc3RydWN0LmpzXCIpO1xuXG5mdW5jdGlvbiBfd3JhcE5hdGl2ZVN1cGVyKENsYXNzKSB7XG4gIHZhciBfY2FjaGUgPSB0eXBlb2YgTWFwID09PSBcImZ1bmN0aW9uXCIgPyBuZXcgTWFwKCkgOiB1bmRlZmluZWQ7XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBfd3JhcE5hdGl2ZVN1cGVyID0gZnVuY3Rpb24gX3dyYXBOYXRpdmVTdXBlcihDbGFzcykge1xuICAgIGlmIChDbGFzcyA9PT0gbnVsbCB8fCAhaXNOYXRpdmVGdW5jdGlvbihDbGFzcykpIHJldHVybiBDbGFzcztcblxuICAgIGlmICh0eXBlb2YgQ2xhc3MgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgX2NhY2hlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBpZiAoX2NhY2hlLmhhcyhDbGFzcykpIHJldHVybiBfY2FjaGUuZ2V0KENsYXNzKTtcblxuICAgICAgX2NhY2hlLnNldChDbGFzcywgV3JhcHBlcik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gV3JhcHBlcigpIHtcbiAgICAgIHJldHVybiBjb25zdHJ1Y3QoQ2xhc3MsIGFyZ3VtZW50cywgZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3IpO1xuICAgIH1cblxuICAgIFdyYXBwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShDbGFzcy5wcm90b3R5cGUsIHtcbiAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgIHZhbHVlOiBXcmFwcGVyLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBzZXRQcm90b3R5cGVPZihXcmFwcGVyLCBDbGFzcyk7XG4gIH07XG5cbiAgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuICByZXR1cm4gX3dyYXBOYXRpdmVTdXBlcihDbGFzcyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX3dyYXBOYXRpdmVTdXBlcjtcbm1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsiLCJpbXBvcnQgVHJhY2VyIGZyb20gJy4vdHJhY2VyJztcclxuXHJcbi8qKlxyXG4gKiBodHRwOi8vd3d3LmNvZGVwcm9qZWN0LmNvbS9UaXBzLzQwNzE3Mi9Db25uZWN0ZWQtQ29tcG9uZW50LUxhYmVsaW5nLWFuZC1WZWN0b3JpemF0aW9uXHJcbiAqL1xyXG5jb25zdCBSYXN0ZXJpemVyID0ge1xyXG4gICAgY3JlYXRlQ29udG91cjJEKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGRpcjogbnVsbCxcclxuICAgICAgICAgICAgaW5kZXg6IG51bGwsXHJcbiAgICAgICAgICAgIGZpcnN0VmVydGV4OiBudWxsLFxyXG4gICAgICAgICAgICBpbnNpZGVDb250b3VyczogbnVsbCxcclxuICAgICAgICAgICAgbmV4dHBlZXI6IG51bGwsXHJcbiAgICAgICAgICAgIHByZXZwZWVyOiBudWxsLFxyXG4gICAgICAgIH07XHJcbiAgICB9LFxyXG4gICAgQ09OVE9VUl9ESVI6IHtcclxuICAgICAgICBDV19ESVI6IDAsXHJcbiAgICAgICAgQ0NXX0RJUjogMSxcclxuICAgICAgICBVTktOT1dOX0RJUjogMixcclxuICAgIH0sXHJcbiAgICBESVI6IHtcclxuICAgICAgICBPVVRTSURFX0VER0U6IC0zMjc2NyxcclxuICAgICAgICBJTlNJREVfRURHRTogLTMyNzY2LFxyXG4gICAgfSxcclxuICAgIGNyZWF0ZShpbWFnZVdyYXBwZXIsIGxhYmVsV3JhcHBlcikge1xyXG4gICAgICAgIGNvbnN0IGltYWdlRGF0YSA9IGltYWdlV3JhcHBlci5kYXRhO1xyXG4gICAgICAgIGNvbnN0IGxhYmVsRGF0YSA9IGxhYmVsV3JhcHBlci5kYXRhO1xyXG4gICAgICAgIGNvbnN0IHdpZHRoID0gaW1hZ2VXcmFwcGVyLnNpemUueDtcclxuICAgICAgICBjb25zdCBoZWlnaHQgPSBpbWFnZVdyYXBwZXIuc2l6ZS55O1xyXG4gICAgICAgIGNvbnN0IHRyYWNlciA9IFRyYWNlci5jcmVhdGUoaW1hZ2VXcmFwcGVyLCBsYWJlbFdyYXBwZXIpO1xyXG5cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICByYXN0ZXJpemUoZGVwdGhsYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgbGV0IGNvbG9yO1xyXG4gICAgICAgICAgICAgICAgbGV0IGJjO1xyXG4gICAgICAgICAgICAgICAgbGV0IGxjO1xyXG4gICAgICAgICAgICAgICAgbGV0IGxhYmVsaW5kZXg7XHJcbiAgICAgICAgICAgICAgICBsZXQgY3g7XHJcbiAgICAgICAgICAgICAgICBsZXQgY3k7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjb2xvck1hcCA9IFtdO1xyXG4gICAgICAgICAgICAgICAgbGV0IHZlcnRleDtcclxuICAgICAgICAgICAgICAgIGxldCBwO1xyXG4gICAgICAgICAgICAgICAgbGV0IGNjO1xyXG4gICAgICAgICAgICAgICAgbGV0IHNjO1xyXG4gICAgICAgICAgICAgICAgbGV0IHBvcztcclxuICAgICAgICAgICAgICAgIGxldCBjb25uZWN0ZWRDb3VudCA9IDA7XHJcbiAgICAgICAgICAgICAgICBsZXQgaTtcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNDAwOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBjb2xvck1hcFtpXSA9IDA7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgY29sb3JNYXBbMF0gPSBpbWFnZURhdGFbMF07XHJcbiAgICAgICAgICAgICAgICBjYyA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGN5ID0gMTsgY3kgPCBoZWlnaHQgLSAxOyBjeSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGFiZWxpbmRleCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgYmMgPSBjb2xvck1hcFswXTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGN4ID0gMTsgY3ggPCB3aWR0aCAtIDE7IGN4KyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zID0gY3kgKiB3aWR0aCArIGN4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGFiZWxEYXRhW3Bvc10gPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yID0gaW1hZ2VEYXRhW3Bvc107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29sb3IgIT09IGJjKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxhYmVsaW5kZXggPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGMgPSBjb25uZWN0ZWRDb3VudCArIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yTWFwW2xjXSA9IGNvbG9yO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYyA9IGNvbG9yO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZXJ0ZXggPSB0cmFjZXIuY29udG91clRyYWNpbmcoY3ksIGN4LCBsYywgY29sb3IsIFJhc3Rlcml6ZXIuRElSLk9VVFNJREVfRURHRSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2ZXJ0ZXggIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbm5lY3RlZENvdW50Kys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbGluZGV4ID0gbGM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwID0gUmFzdGVyaXplci5jcmVhdGVDb250b3VyMkQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAuZGlyID0gUmFzdGVyaXplci5DT05UT1VSX0RJUi5DV19ESVI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwLmluZGV4ID0gbGFiZWxpbmRleDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAuZmlyc3RWZXJ0ZXggPSB2ZXJ0ZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwLm5leHRwZWVyID0gY2M7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwLmluc2lkZUNvbnRvdXJzID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYyAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNjLnByZXZwZWVyID0gcDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNjID0gcDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlcnRleCA9IHRyYWNlclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmNvbnRvdXJUcmFjaW5nKGN5LCBjeCwgUmFzdGVyaXplci5ESVIuSU5TSURFX0VER0UsIGNvbG9yLCBsYWJlbGluZGV4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZlcnRleCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcCA9IFJhc3Rlcml6ZXIuY3JlYXRlQ29udG91cjJEKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwLmZpcnN0VmVydGV4ID0gdmVydGV4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcC5pbnNpZGVDb250b3VycyA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVwdGhsYWJlbCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAuZGlyID0gUmFzdGVyaXplci5DT05UT1VSX0RJUi5DQ1dfRElSO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwLmRpciA9IFJhc3Rlcml6ZXIuQ09OVE9VUl9ESVIuQ1dfRElSO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcC5pbmRleCA9IGRlcHRobGFiZWw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzYyA9IGNjO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKChzYyAhPT0gbnVsbCkgJiYgc2MuaW5kZXggIT09IGxhYmVsaW5kZXgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzYyA9IHNjLm5leHRwZWVyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNjICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcC5uZXh0cGVlciA9IHNjLmluc2lkZUNvbnRvdXJzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzYy5pbnNpZGVDb250b3VycyAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzYy5pbnNpZGVDb250b3Vycy5wcmV2cGVlciA9IHA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjLmluc2lkZUNvbnRvdXJzID0gcDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWxEYXRhW3Bvc10gPSBsYWJlbGluZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGxhYmVsRGF0YVtwb3NdID09PSBSYXN0ZXJpemVyLkRJUi5PVVRTSURFX0VER0VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8fCBsYWJlbERhdGFbcG9zXSA9PT0gUmFzdGVyaXplci5ESVIuSU5TSURFX0VER0UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsaW5kZXggPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxhYmVsRGF0YVtwb3NdID09PSBSYXN0ZXJpemVyLkRJUi5JTlNJREVfRURHRSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJjID0gaW1hZ2VEYXRhW3Bvc107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJjID0gY29sb3JNYXBbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbGluZGV4ID0gbGFiZWxEYXRhW3Bvc107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYyA9IGNvbG9yTWFwW2xhYmVsaW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgc2MgPSBjYztcclxuICAgICAgICAgICAgICAgIHdoaWxlIChzYyAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNjLmluZGV4ID0gZGVwdGhsYWJlbDtcclxuICAgICAgICAgICAgICAgICAgICBzYyA9IHNjLm5leHRwZWVyO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICBjYyxcclxuICAgICAgICAgICAgICAgICAgICBjb3VudDogY29ubmVjdGVkQ291bnQsXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBkZWJ1Zzoge1xyXG4gICAgICAgICAgICAgICAgZHJhd0NvbnRvdXIoY2FudmFzLCBmaXJzdENvbnRvdXIpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgcHEgPSBmaXJzdENvbnRvdXI7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGlxO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBxO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBwO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSAncmVkJztcclxuICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gJ3JlZCc7XHJcbiAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IDE7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpcSA9IHBxLmluc2lkZUNvbnRvdXJzO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlxID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChwcSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXEgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHEgPSBpcTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlxID0gaXEubmV4dHBlZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxID0gcHE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcSA9IHBxLm5leHRwZWVyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBxICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXEgPSBwcS5pbnNpZGVDb250b3VycztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXEgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHEuZGlyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFJhc3Rlcml6ZXIuQ09OVE9VUl9ESVIuQ1dfRElSOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9ICdyZWQnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBSYXN0ZXJpemVyLkNPTlRPVVJfRElSLkNDV19ESVI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gJ2JsdWUnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBSYXN0ZXJpemVyLkNPTlRPVVJfRElSLlVOS05PV05fRElSOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9ICdncmVlbic7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHAgPSBxLmZpcnN0VmVydGV4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8ocC54LCBwLnkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwID0gcC5uZXh0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVUbyhwLngsIHAueSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKHAgIT09IHEuZmlyc3RWZXJ0ZXgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguc3Ryb2tlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9O1xyXG4gICAgfSxcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IFJhc3Rlcml6ZXI7XHJcbiIsIi8qIGVzbGludC1kaXNhYmxlIG5vLXBhcmFtLXJlYXNzaWduICovXHJcbi8qIGVzbGludC1kaXNhYmxlIG5vLWJpdHdpc2UgKi9cclxuLyogZXNsaW50LWRpc2FibGUgZXFlcWVxICovXHJcblxyXG4vKiBAcHJlc2VydmUgQVNNIEJFR0lOICovXHJcbmZ1bmN0aW9uIFNrZWxldG9uaXplcihzdGRsaWIsIGZvcmVpZ24sIGJ1ZmZlcikge1xyXG4gICAgJ3VzZSBhc20nO1xyXG5cclxuICAgIGNvbnN0IGltYWdlcyA9IG5ldyBzdGRsaWIuVWludDhBcnJheShidWZmZXIpO1xyXG4gICAgY29uc3Qgc2l6ZSA9IGZvcmVpZ24uc2l6ZSB8IDA7XHJcbiAgICBjb25zdCB7IGltdWwgfSA9IHN0ZGxpYi5NYXRoO1xyXG5cclxuICAgIGZ1bmN0aW9uIGVyb2RlKGluSW1hZ2VQdHIsIG91dEltYWdlUHRyKSB7XHJcbiAgICAgICAgaW5JbWFnZVB0ciB8PSAwO1xyXG4gICAgICAgIG91dEltYWdlUHRyIHw9IDA7XHJcblxyXG4gICAgICAgIGxldCB2ID0gMDtcclxuICAgICAgICBsZXQgdSA9IDA7XHJcbiAgICAgICAgbGV0IHN1bSA9IDA7XHJcbiAgICAgICAgbGV0IHlTdGFydDEgPSAwO1xyXG4gICAgICAgIGxldCB5U3RhcnQyID0gMDtcclxuICAgICAgICBsZXQgeFN0YXJ0MSA9IDA7XHJcbiAgICAgICAgbGV0IHhTdGFydDIgPSAwO1xyXG4gICAgICAgIGxldCBvZmZzZXQgPSAwO1xyXG5cclxuICAgICAgICBmb3IgKHYgPSAxOyAodiB8IDApIDwgKChzaXplIC0gMSkgfCAwKTsgdiA9ICh2ICsgMSkgfCAwKSB7XHJcbiAgICAgICAgICAgIG9mZnNldCA9IChvZmZzZXQgKyBzaXplKSB8IDA7XHJcbiAgICAgICAgICAgIGZvciAodSA9IDE7ICh1IHwgMCkgPCAoKHNpemUgLSAxKSB8IDApOyB1ID0gKHUgKyAxKSB8IDApIHtcclxuICAgICAgICAgICAgICAgIHlTdGFydDEgPSAob2Zmc2V0IC0gc2l6ZSkgfCAwO1xyXG4gICAgICAgICAgICAgICAgeVN0YXJ0MiA9IChvZmZzZXQgKyBzaXplKSB8IDA7XHJcbiAgICAgICAgICAgICAgICB4U3RhcnQxID0gKHUgLSAxKSB8IDA7XHJcbiAgICAgICAgICAgICAgICB4U3RhcnQyID0gKHUgKyAxKSB8IDA7XHJcbiAgICAgICAgICAgICAgICBzdW0gPSAoKGltYWdlc1soaW5JbWFnZVB0ciArIHlTdGFydDEgKyB4U3RhcnQxKSB8IDBdIHwgMClcclxuICAgICAgICAgICAgICAgICAgICArIChpbWFnZXNbKGluSW1hZ2VQdHIgKyB5U3RhcnQxICsgeFN0YXJ0MikgfCAwXSB8IDApXHJcbiAgICAgICAgICAgICAgICAgICAgKyAoaW1hZ2VzWyhpbkltYWdlUHRyICsgb2Zmc2V0ICsgdSkgfCAwXSB8IDApXHJcbiAgICAgICAgICAgICAgICAgICAgKyAoaW1hZ2VzWyhpbkltYWdlUHRyICsgeVN0YXJ0MiArIHhTdGFydDEpIHwgMF0gfCAwKVxyXG4gICAgICAgICAgICAgICAgICAgICsgKGltYWdlc1soaW5JbWFnZVB0ciArIHlTdGFydDIgKyB4U3RhcnQyKSB8IDBdIHwgMCkpIHwgMDtcclxuICAgICAgICAgICAgICAgIGlmICgoc3VtIHwgMCkgPT0gKDUgfCAwKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGltYWdlc1sob3V0SW1hZ2VQdHIgKyBvZmZzZXQgKyB1KSB8IDBdID0gMTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2VzWyhvdXRJbWFnZVB0ciArIG9mZnNldCArIHUpIHwgMF0gPSAwO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHN1YnRyYWN0KGFJbWFnZVB0ciwgYkltYWdlUHRyLCBvdXRJbWFnZVB0cikge1xyXG4gICAgICAgIGFJbWFnZVB0ciB8PSAwO1xyXG4gICAgICAgIGJJbWFnZVB0ciB8PSAwO1xyXG4gICAgICAgIG91dEltYWdlUHRyIHw9IDA7XHJcblxyXG4gICAgICAgIGxldCBsZW5ndGggPSAwO1xyXG5cclxuICAgICAgICBsZW5ndGggPSBpbXVsKHNpemUsIHNpemUpIHwgMDtcclxuXHJcbiAgICAgICAgd2hpbGUgKChsZW5ndGggfCAwKSA+IDApIHtcclxuICAgICAgICAgICAgbGVuZ3RoID0gKGxlbmd0aCAtIDEpIHwgMDtcclxuICAgICAgICAgICAgaW1hZ2VzWyhvdXRJbWFnZVB0ciArIGxlbmd0aCkgfCAwXSA9ICgoaW1hZ2VzWyhhSW1hZ2VQdHIgKyBsZW5ndGgpIHwgMF0gfCAwKSAtIChpbWFnZXNbKGJJbWFnZVB0ciArIGxlbmd0aCkgfCAwXSB8IDApKSB8IDA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGJpdHdpc2VPcihhSW1hZ2VQdHIsIGJJbWFnZVB0ciwgb3V0SW1hZ2VQdHIpIHtcclxuICAgICAgICBhSW1hZ2VQdHIgfD0gMDtcclxuICAgICAgICBiSW1hZ2VQdHIgfD0gMDtcclxuICAgICAgICBvdXRJbWFnZVB0ciB8PSAwO1xyXG5cclxuICAgICAgICBsZXQgbGVuZ3RoID0gMDtcclxuXHJcbiAgICAgICAgbGVuZ3RoID0gaW11bChzaXplLCBzaXplKSB8IDA7XHJcblxyXG4gICAgICAgIHdoaWxlICgobGVuZ3RoIHwgMCkgPiAwKSB7XHJcbiAgICAgICAgICAgIGxlbmd0aCA9IChsZW5ndGggLSAxKSB8IDA7XHJcbiAgICAgICAgICAgIGltYWdlc1sob3V0SW1hZ2VQdHIgKyBsZW5ndGgpIHwgMF0gPSAoKGltYWdlc1soYUltYWdlUHRyICsgbGVuZ3RoKSB8IDBdIHwgMCkgfCAoaW1hZ2VzWyhiSW1hZ2VQdHIgKyBsZW5ndGgpIHwgMF0gfCAwKSkgfCAwO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjb3VudE5vblplcm8oaW1hZ2VQdHIpIHtcclxuICAgICAgICBpbWFnZVB0ciB8PSAwO1xyXG5cclxuICAgICAgICBsZXQgc3VtID0gMDtcclxuICAgICAgICBsZXQgbGVuZ3RoID0gMDtcclxuXHJcbiAgICAgICAgbGVuZ3RoID0gaW11bChzaXplLCBzaXplKSB8IDA7XHJcblxyXG4gICAgICAgIHdoaWxlICgobGVuZ3RoIHwgMCkgPiAwKSB7XHJcbiAgICAgICAgICAgIGxlbmd0aCA9IChsZW5ndGggLSAxKSB8IDA7XHJcbiAgICAgICAgICAgIHN1bSA9ICgoc3VtIHwgMCkgKyAoaW1hZ2VzWyhpbWFnZVB0ciArIGxlbmd0aCkgfCAwXSB8IDApKSB8IDA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gKHN1bSB8IDApO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGluaXQoaW1hZ2VQdHIsIHZhbHVlKSB7XHJcbiAgICAgICAgaW1hZ2VQdHIgfD0gMDtcclxuICAgICAgICB2YWx1ZSB8PSAwO1xyXG5cclxuICAgICAgICBsZXQgbGVuZ3RoID0gMDtcclxuXHJcbiAgICAgICAgbGVuZ3RoID0gaW11bChzaXplLCBzaXplKSB8IDA7XHJcblxyXG4gICAgICAgIHdoaWxlICgobGVuZ3RoIHwgMCkgPiAwKSB7XHJcbiAgICAgICAgICAgIGxlbmd0aCA9IChsZW5ndGggLSAxKSB8IDA7XHJcbiAgICAgICAgICAgIGltYWdlc1soaW1hZ2VQdHIgKyBsZW5ndGgpIHwgMF0gPSB2YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZGlsYXRlKGluSW1hZ2VQdHIsIG91dEltYWdlUHRyKSB7XHJcbiAgICAgICAgaW5JbWFnZVB0ciB8PSAwO1xyXG4gICAgICAgIG91dEltYWdlUHRyIHw9IDA7XHJcblxyXG4gICAgICAgIGxldCB2ID0gMDtcclxuICAgICAgICBsZXQgdSA9IDA7XHJcbiAgICAgICAgbGV0IHN1bSA9IDA7XHJcbiAgICAgICAgbGV0IHlTdGFydDEgPSAwO1xyXG4gICAgICAgIGxldCB5U3RhcnQyID0gMDtcclxuICAgICAgICBsZXQgeFN0YXJ0MSA9IDA7XHJcbiAgICAgICAgbGV0IHhTdGFydDIgPSAwO1xyXG4gICAgICAgIGxldCBvZmZzZXQgPSAwO1xyXG5cclxuICAgICAgICBmb3IgKHYgPSAxOyAodiB8IDApIDwgKChzaXplIC0gMSkgfCAwKTsgdiA9ICh2ICsgMSkgfCAwKSB7XHJcbiAgICAgICAgICAgIG9mZnNldCA9IChvZmZzZXQgKyBzaXplKSB8IDA7XHJcbiAgICAgICAgICAgIGZvciAodSA9IDE7ICh1IHwgMCkgPCAoKHNpemUgLSAxKSB8IDApOyB1ID0gKHUgKyAxKSB8IDApIHtcclxuICAgICAgICAgICAgICAgIHlTdGFydDEgPSAob2Zmc2V0IC0gc2l6ZSkgfCAwO1xyXG4gICAgICAgICAgICAgICAgeVN0YXJ0MiA9IChvZmZzZXQgKyBzaXplKSB8IDA7XHJcbiAgICAgICAgICAgICAgICB4U3RhcnQxID0gKHUgLSAxKSB8IDA7XHJcbiAgICAgICAgICAgICAgICB4U3RhcnQyID0gKHUgKyAxKSB8IDA7XHJcbiAgICAgICAgICAgICAgICBzdW0gPSAoKGltYWdlc1soaW5JbWFnZVB0ciArIHlTdGFydDEgKyB4U3RhcnQxKSB8IDBdIHwgMClcclxuICAgICAgICAgICAgICAgICAgICArIChpbWFnZXNbKGluSW1hZ2VQdHIgKyB5U3RhcnQxICsgeFN0YXJ0MikgfCAwXSB8IDApXHJcbiAgICAgICAgICAgICAgICAgICAgKyAoaW1hZ2VzWyhpbkltYWdlUHRyICsgb2Zmc2V0ICsgdSkgfCAwXSB8IDApXHJcbiAgICAgICAgICAgICAgICAgICAgKyAoaW1hZ2VzWyhpbkltYWdlUHRyICsgeVN0YXJ0MiArIHhTdGFydDEpIHwgMF0gfCAwKVxyXG4gICAgICAgICAgICAgICAgICAgICsgKGltYWdlc1soaW5JbWFnZVB0ciArIHlTdGFydDIgKyB4U3RhcnQyKSB8IDBdIHwgMCkpIHwgMDtcclxuICAgICAgICAgICAgICAgIGlmICgoc3VtIHwgMCkgPiAoMCB8IDApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2VzWyhvdXRJbWFnZVB0ciArIG9mZnNldCArIHUpIHwgMF0gPSAxO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpbWFnZXNbKG91dEltYWdlUHRyICsgb2Zmc2V0ICsgdSkgfCAwXSA9IDA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gbWVtY3B5KHNyY0ltYWdlUHRyLCBkc3RJbWFnZVB0cikge1xyXG4gICAgICAgIHNyY0ltYWdlUHRyIHw9IDA7XHJcbiAgICAgICAgZHN0SW1hZ2VQdHIgfD0gMDtcclxuXHJcbiAgICAgICAgbGV0IGxlbmd0aCA9IDA7XHJcblxyXG4gICAgICAgIGxlbmd0aCA9IGltdWwoc2l6ZSwgc2l6ZSkgfCAwO1xyXG5cclxuICAgICAgICB3aGlsZSAoKGxlbmd0aCB8IDApID4gMCkge1xyXG4gICAgICAgICAgICBsZW5ndGggPSAobGVuZ3RoIC0gMSkgfCAwO1xyXG4gICAgICAgICAgICBpbWFnZXNbKGRzdEltYWdlUHRyICsgbGVuZ3RoKSB8IDBdID0gKGltYWdlc1soc3JjSW1hZ2VQdHIgKyBsZW5ndGgpIHwgMF0gfCAwKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gemVyb0JvcmRlcihpbWFnZVB0cikge1xyXG4gICAgICAgIGltYWdlUHRyIHw9IDA7XHJcblxyXG4gICAgICAgIGxldCB4ID0gMDtcclxuICAgICAgICBsZXQgeSA9IDA7XHJcblxyXG4gICAgICAgIGZvciAoeCA9IDA7ICh4IHwgMCkgPCAoKHNpemUgLSAxKSB8IDApOyB4ID0gKHggKyAxKSB8IDApIHtcclxuICAgICAgICAgICAgaW1hZ2VzWyhpbWFnZVB0ciArIHgpIHwgMF0gPSAwO1xyXG4gICAgICAgICAgICBpbWFnZXNbKGltYWdlUHRyICsgeSkgfCAwXSA9IDA7XHJcbiAgICAgICAgICAgIHkgPSAoKHkgKyBzaXplKSAtIDEpIHwgMDtcclxuICAgICAgICAgICAgaW1hZ2VzWyhpbWFnZVB0ciArIHkpIHwgMF0gPSAwO1xyXG4gICAgICAgICAgICB5ID0gKHkgKyAxKSB8IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAoeCA9IDA7ICh4IHwgMCkgPCAoc2l6ZSB8IDApOyB4ID0gKHggKyAxKSB8IDApIHtcclxuICAgICAgICAgICAgaW1hZ2VzWyhpbWFnZVB0ciArIHkpIHwgMF0gPSAwO1xyXG4gICAgICAgICAgICB5ID0gKHkgKyAxKSB8IDA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHNrZWxldG9uaXplKCkge1xyXG4gICAgICAgIGNvbnN0IHN1YkltYWdlUHRyID0gMDtcclxuICAgICAgICBsZXQgZXJvZGVkSW1hZ2VQdHIgPSAwO1xyXG4gICAgICAgIGxldCB0ZW1wSW1hZ2VQdHIgPSAwO1xyXG4gICAgICAgIGxldCBza2VsSW1hZ2VQdHIgPSAwO1xyXG4gICAgICAgIGxldCBzdW0gPSAwO1xyXG4gICAgICAgIGxldCBkb25lID0gMDtcclxuXHJcbiAgICAgICAgZXJvZGVkSW1hZ2VQdHIgPSBpbXVsKHNpemUsIHNpemUpIHwgMDtcclxuICAgICAgICB0ZW1wSW1hZ2VQdHIgPSAoZXJvZGVkSW1hZ2VQdHIgKyBlcm9kZWRJbWFnZVB0cikgfCAwO1xyXG4gICAgICAgIHNrZWxJbWFnZVB0ciA9ICh0ZW1wSW1hZ2VQdHIgKyBlcm9kZWRJbWFnZVB0cikgfCAwO1xyXG5cclxuICAgICAgICAvLyBpbml0IHNrZWwtaW1hZ2VcclxuICAgICAgICBpbml0KHNrZWxJbWFnZVB0ciwgMCk7XHJcbiAgICAgICAgemVyb0JvcmRlcihzdWJJbWFnZVB0cik7XHJcblxyXG4gICAgICAgIGRvIHtcclxuICAgICAgICAgICAgZXJvZGUoc3ViSW1hZ2VQdHIsIGVyb2RlZEltYWdlUHRyKTtcclxuICAgICAgICAgICAgZGlsYXRlKGVyb2RlZEltYWdlUHRyLCB0ZW1wSW1hZ2VQdHIpO1xyXG4gICAgICAgICAgICBzdWJ0cmFjdChzdWJJbWFnZVB0ciwgdGVtcEltYWdlUHRyLCB0ZW1wSW1hZ2VQdHIpO1xyXG4gICAgICAgICAgICBiaXR3aXNlT3Ioc2tlbEltYWdlUHRyLCB0ZW1wSW1hZ2VQdHIsIHNrZWxJbWFnZVB0cik7XHJcbiAgICAgICAgICAgIG1lbWNweShlcm9kZWRJbWFnZVB0ciwgc3ViSW1hZ2VQdHIpO1xyXG4gICAgICAgICAgICBzdW0gPSBjb3VudE5vblplcm8oc3ViSW1hZ2VQdHIpIHwgMDtcclxuICAgICAgICAgICAgZG9uZSA9ICgoc3VtIHwgMCkgPT0gMCB8IDApO1xyXG4gICAgICAgIH0gd2hpbGUgKCFkb25lKTtcclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgc2tlbGV0b25pemUsXHJcbiAgICB9O1xyXG59XHJcbi8qIEBwcmVzZXJ2ZSBBU00gRU5EICovXHJcbmV4cG9ydCBkZWZhdWx0IFNrZWxldG9uaXplcjtcclxuLyogZXNsaW50LWVuYWJsZSBlcWVxZXEgKi9cclxuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiZ2V0LXBpeGVsc1wiKTsiLCIvLyBOT1RFIEZPUiBBTllPTkUgSU4gSEVSRSBJTiBUSEUgRlVUVVJFOiBUaGlzIG1vZHVsZSBpcyB1c2VkIHdoZW4gdGhlIG1vZHVsZSBpcyBidWlsdCBmb3IgdXNlIGluIE5vZGUuXHJcbi8vIFdlYnBhY2suY29uZmlnLmpzIGV4cGxpY2l0bHkgUkVQTEFDRVMgdGhpcyBtb2R1bGUgd2l0aCB0aGUgZmlsZSBjYWxsZWQgZnJhbWVfZ3JhYmJlcl9icm93c2VyIHdoZW4gaXQgaXMgcGFja2luZyB0aGUgQnJvd3NlciBkaXN0cmlidXRpb24uXHJcblxyXG5jb25zdCBDVlV0aWxzID0gcmVxdWlyZSgnLi4vY29tbW9uL2N2X3V0aWxzJyk7XHJcbmNvbnN0IE5kYXJyYXkgPSByZXF1aXJlKCduZGFycmF5Jyk7XHJcbmNvbnN0IEludGVycDJEID0gcmVxdWlyZSgnbmRhcnJheS1saW5lYXItaW50ZXJwb2xhdGUnKS5kMjtcclxuXHJcbmNvbnN0IEZyYW1lR3JhYmJlciA9IHt9O1xyXG5cclxuRnJhbWVHcmFiYmVyLmNyZWF0ZSA9IGZ1bmN0aW9uIChpbnB1dFN0cmVhbSwgY2FudmFzKSB7XHJcbiAgICBjb25zdCBfdGhhdCA9IHt9O1xyXG4gICAgY29uc3QgX3ZpZGVvU2l6ZSA9IENWVXRpbHMuaW1hZ2VSZWYoaW5wdXRTdHJlYW0uZ2V0UmVhbFdpZHRoKCksIGlucHV0U3RyZWFtLmdldFJlYWxIZWlnaHQoKSk7XHJcbiAgICBjb25zdCBfY2FudmFzU2l6ZSA9IGlucHV0U3RyZWFtLmdldENhbnZhc1NpemUoKTtcclxuICAgIGNvbnN0IF9zaXplID0gQ1ZVdGlscy5pbWFnZVJlZihpbnB1dFN0cmVhbS5nZXRXaWR0aCgpLCBpbnB1dFN0cmVhbS5nZXRIZWlnaHQoKSk7XHJcbiAgICBjb25zdCBfdG9wUmlnaHQgPSBpbnB1dFN0cmVhbS5nZXRUb3BSaWdodCgpO1xyXG4gICAgbGV0IF9kYXRhID0gbmV3IFVpbnQ4QXJyYXkoX3NpemUueCAqIF9zaXplLnkpO1xyXG4gICAgY29uc3QgX2dyYXlEYXRhID0gbmV3IFVpbnQ4QXJyYXkoX3ZpZGVvU2l6ZS54ICogX3ZpZGVvU2l6ZS55KTtcclxuICAgIGNvbnN0IF9jYW52YXNEYXRhID0gbmV3IFVpbnQ4QXJyYXkoX2NhbnZhc1NpemUueCAqIF9jYW52YXNTaXplLnkpO1xyXG4gICAgLyogZXNsaW50LWRpc2FibGUgbmV3LWNhcCAqL1xyXG4gICAgY29uc3QgX2dyYXlJbWFnZUFycmF5ID0gTmRhcnJheShfZ3JheURhdGEsIFtfdmlkZW9TaXplLnksIF92aWRlb1NpemUueF0pLnRyYW5zcG9zZSgxLCAwKTtcclxuICAgIGNvbnN0IF9jYW52YXNJbWFnZUFycmF5ID0gTmRhcnJheShfY2FudmFzRGF0YSwgW19jYW52YXNTaXplLnksIF9jYW52YXNTaXplLnhdKS50cmFuc3Bvc2UoMSwgMCk7XHJcbiAgICBjb25zdCBfdGFyZ2V0SW1hZ2VBcnJheSA9IF9jYW52YXNJbWFnZUFycmF5XHJcbiAgICAgICAgLmhpKF90b3BSaWdodC54ICsgX3NpemUueCwgX3RvcFJpZ2h0LnkgKyBfc2l6ZS55KVxyXG4gICAgICAgIC5sbyhfdG9wUmlnaHQueCwgX3RvcFJpZ2h0LnkpO1xyXG4gICAgY29uc3QgX3N0ZXBTaXplWCA9IF92aWRlb1NpemUueCAvIF9jYW52YXNTaXplLng7XHJcbiAgICBjb25zdCBfc3RlcFNpemVZID0gX3ZpZGVvU2l6ZS55IC8gX2NhbnZhc1NpemUueTtcclxuXHJcbiAgICBpZiAoRU5WLmRldmVsb3BtZW50KSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ0ZyYW1lR3JhYmJlcicsIEpTT04uc3RyaW5naWZ5KHtcclxuICAgICAgICAgICAgdmlkZW9TaXplOiBfZ3JheUltYWdlQXJyYXkuc2hhcGUsXHJcbiAgICAgICAgICAgIGNhbnZhc1NpemU6IF9jYW52YXNJbWFnZUFycmF5LnNoYXBlLFxyXG4gICAgICAgICAgICBzdGVwU2l6ZTogW19zdGVwU2l6ZVgsIF9zdGVwU2l6ZVldLFxyXG4gICAgICAgICAgICBzaXplOiBfdGFyZ2V0SW1hZ2VBcnJheS5zaGFwZSxcclxuICAgICAgICAgICAgdG9wUmlnaHQ6IF90b3BSaWdodCxcclxuICAgICAgICB9KSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBVc2VzIHRoZSBnaXZlbiBhcnJheSBhcyBmcmFtZS1idWZmZXJcclxuICAgICAqL1xyXG4gICAgX3RoYXQuYXR0YWNoRGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgX2RhdGEgPSBkYXRhO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHVzZWQgZnJhbWUtYnVmZmVyXHJcbiAgICAgKi9cclxuICAgIF90aGF0LmdldERhdGEgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9kYXRhO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEZldGNoZXMgYSBmcmFtZSBmcm9tIHRoZSBpbnB1dC1zdHJlYW0gYW5kIHB1dHMgaW50byB0aGUgZnJhbWUtYnVmZmVyLlxyXG4gICAgICogVGhlIGltYWdlLWRhdGEgaXMgY29udmVydGVkIHRvIGdyYXktc2NhbGUgYW5kIHRoZW4gaGFsZi1zYW1wbGVkIGlmIGNvbmZpZ3VyZWQuXHJcbiAgICAgKi9cclxuICAgIF90aGF0LmdyYWIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgY29uc3QgZnJhbWUgPSBpbnB1dFN0cmVhbS5nZXRGcmFtZSgpO1xyXG5cclxuICAgICAgICBpZiAoZnJhbWUpIHtcclxuICAgICAgICAgICAgdGhpcy5zY2FsZUFuZENyb3AoZnJhbWUpO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcclxuICAgIF90aGF0LnNjYWxlQW5kQ3JvcCA9IGZ1bmN0aW9uKGZyYW1lKSB7XHJcbiAgICAgICAgLy8gMS4gY29tcHV0ZSBmdWxsLXNpemVkIGdyYXkgaW1hZ2VcclxuICAgICAgICBDVlV0aWxzLmNvbXB1dGVHcmF5KGZyYW1lLmRhdGEsIF9ncmF5RGF0YSk7XHJcblxyXG4gICAgICAgIC8vIDIuIGludGVycG9sYXRlXHJcbiAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCBfY2FudmFzU2l6ZS55OyB5KyspIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCBfY2FudmFzU2l6ZS54OyB4KyspIHtcclxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1iaXR3aXNlXHJcbiAgICAgICAgICAgICAgICBfY2FudmFzSW1hZ2VBcnJheS5zZXQoeCwgeSwgKEludGVycDJEKF9ncmF5SW1hZ2VBcnJheSwgeCAqIF9zdGVwU2l6ZVgsIHkgKiBfc3RlcFNpemVZKSkgfCAwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gdGFyZ2V0SW1hZ2VBcnJheSBtdXN0IGJlIGVxdWFsIHRvIHRhcmdldFNpemVcclxuICAgICAgICBpZiAoX3RhcmdldEltYWdlQXJyYXkuc2hhcGVbMF0gIT09IF9zaXplLnhcclxuICAgICAgICAgICAgfHwgX3RhcmdldEltYWdlQXJyYXkuc2hhcGVbMV0gIT09IF9zaXplLnkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTaGFwZXMgZG8gbm90IG1hdGNoIScpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gMy4gY3JvcFxyXG4gICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgX3NpemUueTsgeSsrKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgX3NpemUueDsgeCsrKSB7XHJcbiAgICAgICAgICAgICAgICBfZGF0YVt5ICogX3NpemUueCArIHhdID0gX3RhcmdldEltYWdlQXJyYXkuZ2V0KHgsIHkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBfdGhhdC5nZXRTaXplID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBfc2l6ZTtcclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIF90aGF0O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBGcmFtZUdyYWJiZXI7XHJcbiIsInZhciBTdGFjayA9IHJlcXVpcmUoJy4vX1N0YWNrJyksXG4gICAgYXNzaWduTWVyZ2VWYWx1ZSA9IHJlcXVpcmUoJy4vX2Fzc2lnbk1lcmdlVmFsdWUnKSxcbiAgICBiYXNlRm9yID0gcmVxdWlyZSgnLi9fYmFzZUZvcicpLFxuICAgIGJhc2VNZXJnZURlZXAgPSByZXF1aXJlKCcuL19iYXNlTWVyZ2VEZWVwJyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0JyksXG4gICAga2V5c0luID0gcmVxdWlyZSgnLi9rZXlzSW4nKSxcbiAgICBzYWZlR2V0ID0gcmVxdWlyZSgnLi9fc2FmZUdldCcpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1lcmdlYCB3aXRob3V0IHN1cHBvcnQgZm9yIG11bHRpcGxlIHNvdXJjZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcGFyYW0ge251bWJlcn0gc3JjSW5kZXggVGhlIGluZGV4IG9mIGBzb3VyY2VgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgbWVyZ2VkIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgc291cmNlIHZhbHVlcyBhbmQgdGhlaXIgbWVyZ2VkXG4gKiAgY291bnRlcnBhcnRzLlxuICovXG5mdW5jdGlvbiBiYXNlTWVyZ2Uob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4LCBjdXN0b21pemVyLCBzdGFjaykge1xuICBpZiAob2JqZWN0ID09PSBzb3VyY2UpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgYmFzZUZvcihzb3VyY2UsIGZ1bmN0aW9uKHNyY1ZhbHVlLCBrZXkpIHtcbiAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICAgIGlmIChpc09iamVjdChzcmNWYWx1ZSkpIHtcbiAgICAgIGJhc2VNZXJnZURlZXAob2JqZWN0LCBzb3VyY2UsIGtleSwgc3JjSW5kZXgsIGJhc2VNZXJnZSwgY3VzdG9taXplciwgc3RhY2spO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHZhciBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXJcbiAgICAgICAgPyBjdXN0b21pemVyKHNhZmVHZXQob2JqZWN0LCBrZXkpLCBzcmNWYWx1ZSwgKGtleSArICcnKSwgb2JqZWN0LCBzb3VyY2UsIHN0YWNrKVxuICAgICAgICA6IHVuZGVmaW5lZDtcblxuICAgICAgaWYgKG5ld1ZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbmV3VmFsdWUgPSBzcmNWYWx1ZTtcbiAgICAgIH1cbiAgICAgIGFzc2lnbk1lcmdlVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbiAgICB9XG4gIH0sIGtleXNJbik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZU1lcmdlO1xuIiwidmFyIExpc3RDYWNoZSA9IHJlcXVpcmUoJy4vX0xpc3RDYWNoZScpLFxuICAgIHN0YWNrQ2xlYXIgPSByZXF1aXJlKCcuL19zdGFja0NsZWFyJyksXG4gICAgc3RhY2tEZWxldGUgPSByZXF1aXJlKCcuL19zdGFja0RlbGV0ZScpLFxuICAgIHN0YWNrR2V0ID0gcmVxdWlyZSgnLi9fc3RhY2tHZXQnKSxcbiAgICBzdGFja0hhcyA9IHJlcXVpcmUoJy4vX3N0YWNrSGFzJyksXG4gICAgc3RhY2tTZXQgPSByZXF1aXJlKCcuL19zdGFja1NldCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBzdGFjayBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBTdGFjayhlbnRyaWVzKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGUoZW50cmllcyk7XG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYFN0YWNrYC5cblN0YWNrLnByb3RvdHlwZS5jbGVhciA9IHN0YWNrQ2xlYXI7XG5TdGFjay5wcm90b3R5cGVbJ2RlbGV0ZSddID0gc3RhY2tEZWxldGU7XG5TdGFjay5wcm90b3R5cGUuZ2V0ID0gc3RhY2tHZXQ7XG5TdGFjay5wcm90b3R5cGUuaGFzID0gc3RhY2tIYXM7XG5TdGFjay5wcm90b3R5cGUuc2V0ID0gc3RhY2tTZXQ7XG5cbm1vZHVsZS5leHBvcnRzID0gU3RhY2s7XG4iLCIvKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUNsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gW107XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlQ2xlYXI7XG4iLCJ2YXIgYXNzb2NJbmRleE9mID0gcmVxdWlyZSgnLi9fYXNzb2NJbmRleE9mJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzcGxpY2UgPSBhcnJheVByb3RvLnNwbGljZTtcblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlRGVsZXRlKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIGlmIChpbmRleCA8IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGxhc3RJbmRleCA9IGRhdGEubGVuZ3RoIC0gMTtcbiAgaWYgKGluZGV4ID09IGxhc3RJbmRleCkge1xuICAgIGRhdGEucG9wKCk7XG4gIH0gZWxzZSB7XG4gICAgc3BsaWNlLmNhbGwoZGF0YSwgaW5kZXgsIDEpO1xuICB9XG4gIC0tdGhpcy5zaXplO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVEZWxldGU7XG4iLCJ2YXIgYXNzb2NJbmRleE9mID0gcmVxdWlyZSgnLi9fYXNzb2NJbmRleE9mJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUdldChrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICByZXR1cm4gaW5kZXggPCAwID8gdW5kZWZpbmVkIDogZGF0YVtpbmRleF1bMV07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlR2V0O1xuIiwidmFyIGFzc29jSW5kZXhPZiA9IHJlcXVpcmUoJy4vX2Fzc29jSW5kZXhPZicpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlSGFzKGtleSkge1xuICByZXR1cm4gYXNzb2NJbmRleE9mKHRoaXMuX19kYXRhX18sIGtleSkgPiAtMTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVIYXM7XG4iLCJ2YXIgYXNzb2NJbmRleE9mID0gcmVxdWlyZSgnLi9fYXNzb2NJbmRleE9mJyk7XG5cbi8qKlxuICogU2V0cyB0aGUgbGlzdCBjYWNoZSBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbGlzdCBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgKyt0aGlzLnNpemU7XG4gICAgZGF0YS5wdXNoKFtrZXksIHZhbHVlXSk7XG4gIH0gZWxzZSB7XG4gICAgZGF0YVtpbmRleF1bMV0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVTZXQ7XG4iLCJ2YXIgTGlzdENhY2hlID0gcmVxdWlyZSgnLi9fTGlzdENhY2hlJyk7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgc3RhY2suXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqL1xuZnVuY3Rpb24gc3RhY2tDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGU7XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tDbGVhcjtcbiIsIi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIHN0YWNrLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrRGVsZXRlKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICByZXN1bHQgPSBkYXRhWydkZWxldGUnXShrZXkpO1xuXG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja0RlbGV0ZTtcbiIsIi8qKlxuICogR2V0cyB0aGUgc3RhY2sgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrR2V0KGtleSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5nZXQoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja0dldDtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGEgc3RhY2sgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzdGFja0hhcyhrZXkpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tIYXM7XG4iLCJ2YXIgTGlzdENhY2hlID0gcmVxdWlyZSgnLi9fTGlzdENhY2hlJyksXG4gICAgTWFwID0gcmVxdWlyZSgnLi9fTWFwJyksXG4gICAgTWFwQ2FjaGUgPSByZXF1aXJlKCcuL19NYXBDYWNoZScpO1xuXG4vKiogVXNlZCBhcyB0aGUgc2l6ZSB0byBlbmFibGUgbGFyZ2UgYXJyYXkgb3B0aW1pemF0aW9ucy4gKi9cbnZhciBMQVJHRV9BUlJBWV9TSVpFID0gMjAwO1xuXG4vKipcbiAqIFNldHMgdGhlIHN0YWNrIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIHN0YWNrIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBzdGFja1NldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgaWYgKGRhdGEgaW5zdGFuY2VvZiBMaXN0Q2FjaGUpIHtcbiAgICB2YXIgcGFpcnMgPSBkYXRhLl9fZGF0YV9fO1xuICAgIGlmICghTWFwIHx8IChwYWlycy5sZW5ndGggPCBMQVJHRV9BUlJBWV9TSVpFIC0gMSkpIHtcbiAgICAgIHBhaXJzLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICAgIHRoaXMuc2l6ZSA9ICsrZGF0YS5zaXplO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRhdGEgPSB0aGlzLl9fZGF0YV9fID0gbmV3IE1hcENhY2hlKHBhaXJzKTtcbiAgfVxuICBkYXRhLnNldChrZXksIHZhbHVlKTtcbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja1NldDtcbiIsInZhciBpc0Z1bmN0aW9uID0gcmVxdWlyZSgnLi9pc0Z1bmN0aW9uJyksXG4gICAgaXNNYXNrZWQgPSByZXF1aXJlKCcuL19pc01hc2tlZCcpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpLFxuICAgIHRvU291cmNlID0gcmVxdWlyZSgnLi9fdG9Tb3VyY2UnKTtcblxuLyoqXG4gKiBVc2VkIHRvIG1hdGNoIGBSZWdFeHBgXG4gKiBbc3ludGF4IGNoYXJhY3RlcnNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXBhdHRlcm5zKS5cbiAqL1xudmFyIHJlUmVnRXhwQ2hhciA9IC9bXFxcXF4kLiorPygpW1xcXXt9fF0vZztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGhvc3QgY29uc3RydWN0b3JzIChTYWZhcmkpLiAqL1xudmFyIHJlSXNIb3N0Q3RvciA9IC9eXFxbb2JqZWN0IC4rP0NvbnN0cnVjdG9yXFxdJC87XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGUsXG4gICAgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaWYgYSBtZXRob2QgaXMgbmF0aXZlLiAqL1xudmFyIHJlSXNOYXRpdmUgPSBSZWdFeHAoJ14nICtcbiAgZnVuY1RvU3RyaW5nLmNhbGwoaGFzT3duUHJvcGVydHkpLnJlcGxhY2UocmVSZWdFeHBDaGFyLCAnXFxcXCQmJylcbiAgLnJlcGxhY2UoL2hhc093blByb3BlcnR5fChmdW5jdGlvbikuKj8oPz1cXFxcXFwoKXwgZm9yIC4rPyg/PVxcXFxcXF0pL2csICckMS4qPycpICsgJyQnXG4pO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTmF0aXZlYCB3aXRob3V0IGJhZCBzaGltIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbixcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc05hdGl2ZSh2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSB8fCBpc01hc2tlZCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHBhdHRlcm4gPSBpc0Z1bmN0aW9uKHZhbHVlKSA/IHJlSXNOYXRpdmUgOiByZUlzSG9zdEN0b3I7XG4gIHJldHVybiBwYXR0ZXJuLnRlc3QodG9Tb3VyY2UodmFsdWUpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNOYXRpdmU7XG4iLCJ2YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fU3ltYm9sJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1Ub1N0cmluZ1RhZyA9IFN5bWJvbCA/IFN5bWJvbC50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VHZXRUYWdgIHdoaWNoIGlnbm9yZXMgYFN5bWJvbC50b1N0cmluZ1RhZ2AgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHJhdyBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBnZXRSYXdUYWcodmFsdWUpIHtcbiAgdmFyIGlzT3duID0gaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgc3ltVG9TdHJpbmdUYWcpLFxuICAgICAgdGFnID0gdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuXG4gIHRyeSB7XG4gICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdW5kZWZpbmVkO1xuICAgIHZhciB1bm1hc2tlZCA9IHRydWU7XG4gIH0gY2F0Y2ggKGUpIHt9XG5cbiAgdmFyIHJlc3VsdCA9IG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICBpZiAodW5tYXNrZWQpIHtcbiAgICBpZiAoaXNPd24pIHtcbiAgICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHRhZztcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRSYXdUYWc7XG4iLCIvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIHVzaW5nIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBvYmplY3RUb1N0cmluZztcbiIsInZhciBjb3JlSnNEYXRhID0gcmVxdWlyZSgnLi9fY29yZUpzRGF0YScpO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgbWV0aG9kcyBtYXNxdWVyYWRpbmcgYXMgbmF0aXZlLiAqL1xudmFyIG1hc2tTcmNLZXkgPSAoZnVuY3Rpb24oKSB7XG4gIHZhciB1aWQgPSAvW14uXSskLy5leGVjKGNvcmVKc0RhdGEgJiYgY29yZUpzRGF0YS5rZXlzICYmIGNvcmVKc0RhdGEua2V5cy5JRV9QUk9UTyB8fCAnJyk7XG4gIHJldHVybiB1aWQgPyAoJ1N5bWJvbChzcmMpXzEuJyArIHVpZCkgOiAnJztcbn0oKSk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBmdW5jYCBoYXMgaXRzIHNvdXJjZSBtYXNrZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBmdW5jYCBpcyBtYXNrZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNNYXNrZWQoZnVuYykge1xuICByZXR1cm4gISFtYXNrU3JjS2V5ICYmIChtYXNrU3JjS2V5IGluIGZ1bmMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzTWFza2VkO1xuIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBvdmVycmVhY2hpbmcgY29yZS1qcyBzaGltcy4gKi9cbnZhciBjb3JlSnNEYXRhID0gcm9vdFsnX19jb3JlLWpzX3NoYXJlZF9fJ107XG5cbm1vZHVsZS5leHBvcnRzID0gY29yZUpzRGF0YTtcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKlxuICogQ29udmVydHMgYGZ1bmNgIHRvIGl0cyBzb3VyY2UgY29kZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHNvdXJjZSBjb2RlLlxuICovXG5mdW5jdGlvbiB0b1NvdXJjZShmdW5jKSB7XG4gIGlmIChmdW5jICE9IG51bGwpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZ1bmNUb1N0cmluZy5jYWxsKGZ1bmMpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiAoZnVuYyArICcnKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9XG4gIHJldHVybiAnJztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b1NvdXJjZTtcbiIsIi8qKlxuICogR2V0cyB0aGUgdmFsdWUgYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGdldFZhbHVlKG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFZhbHVlO1xuIiwidmFyIEhhc2ggPSByZXF1aXJlKCcuL19IYXNoJyksXG4gICAgTGlzdENhY2hlID0gcmVxdWlyZSgnLi9fTGlzdENhY2hlJyksXG4gICAgTWFwID0gcmVxdWlyZSgnLi9fTWFwJyk7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuc2l6ZSA9IDA7XG4gIHRoaXMuX19kYXRhX18gPSB7XG4gICAgJ2hhc2gnOiBuZXcgSGFzaCxcbiAgICAnbWFwJzogbmV3IChNYXAgfHwgTGlzdENhY2hlKSxcbiAgICAnc3RyaW5nJzogbmV3IEhhc2hcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZUNsZWFyO1xuIiwidmFyIGhhc2hDbGVhciA9IHJlcXVpcmUoJy4vX2hhc2hDbGVhcicpLFxuICAgIGhhc2hEZWxldGUgPSByZXF1aXJlKCcuL19oYXNoRGVsZXRlJyksXG4gICAgaGFzaEdldCA9IHJlcXVpcmUoJy4vX2hhc2hHZXQnKSxcbiAgICBoYXNoSGFzID0gcmVxdWlyZSgnLi9faGFzaEhhcycpLFxuICAgIGhhc2hTZXQgPSByZXF1aXJlKCcuL19oYXNoU2V0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGhhc2ggb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBIYXNoKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYEhhc2hgLlxuSGFzaC5wcm90b3R5cGUuY2xlYXIgPSBoYXNoQ2xlYXI7XG5IYXNoLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBoYXNoRGVsZXRlO1xuSGFzaC5wcm90b3R5cGUuZ2V0ID0gaGFzaEdldDtcbkhhc2gucHJvdG90eXBlLmhhcyA9IGhhc2hIYXM7XG5IYXNoLnByb3RvdHlwZS5zZXQgPSBoYXNoU2V0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEhhc2g7XG4iLCJ2YXIgbmF0aXZlQ3JlYXRlID0gcmVxdWlyZSgnLi9fbmF0aXZlQ3JlYXRlJyk7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgaGFzaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKi9cbmZ1bmN0aW9uIGhhc2hDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IG5hdGl2ZUNyZWF0ZSA/IG5hdGl2ZUNyZWF0ZShudWxsKSA6IHt9O1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hDbGVhcjtcbiIsIi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7T2JqZWN0fSBoYXNoIFRoZSBoYXNoIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNoRGVsZXRlKGtleSkge1xuICB2YXIgcmVzdWx0ID0gdGhpcy5oYXMoa2V5KSAmJiBkZWxldGUgdGhpcy5fX2RhdGFfX1trZXldO1xuICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzaERlbGV0ZTtcbiIsInZhciBuYXRpdmVDcmVhdGUgPSByZXF1aXJlKCcuL19uYXRpdmVDcmVhdGUnKTtcblxuLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xudmFyIEhBU0hfVU5ERUZJTkVEID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEdldHMgdGhlIGhhc2ggdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gaGFzaEdldChrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICBpZiAobmF0aXZlQ3JlYXRlKSB7XG4gICAgdmFyIHJlc3VsdCA9IGRhdGFba2V5XTtcbiAgICByZXR1cm4gcmVzdWx0ID09PSBIQVNIX1VOREVGSU5FRCA/IHVuZGVmaW5lZCA6IHJlc3VsdDtcbiAgfVxuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpID8gZGF0YVtrZXldIDogdW5kZWZpbmVkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hHZXQ7XG4iLCJ2YXIgbmF0aXZlQ3JlYXRlID0gcmVxdWlyZSgnLi9fbmF0aXZlQ3JlYXRlJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgaGFzaCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaEhhcyhrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICByZXR1cm4gbmF0aXZlQ3JlYXRlID8gKGRhdGFba2V5XSAhPT0gdW5kZWZpbmVkKSA6IGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoSGFzO1xuIiwidmFyIG5hdGl2ZUNyZWF0ZSA9IHJlcXVpcmUoJy4vX25hdGl2ZUNyZWF0ZScpO1xuXG4vKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG52YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbi8qKlxuICogU2V0cyB0aGUgaGFzaCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGhhc2ggaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGhhc2hTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIHRoaXMuc2l6ZSArPSB0aGlzLmhhcyhrZXkpID8gMCA6IDE7XG4gIGRhdGFba2V5XSA9IChuYXRpdmVDcmVhdGUgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkgPyBIQVNIX1VOREVGSU5FRCA6IHZhbHVlO1xuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoU2V0O1xuIiwidmFyIGdldE1hcERhdGEgPSByZXF1aXJlKCcuL19nZXRNYXBEYXRhJyk7XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIG1hcC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZURlbGV0ZShrZXkpIHtcbiAgdmFyIHJlc3VsdCA9IGdldE1hcERhdGEodGhpcywga2V5KVsnZGVsZXRlJ10oa2V5KTtcbiAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcENhY2hlRGVsZXRlO1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSBmb3IgdXNlIGFzIHVuaXF1ZSBvYmplY3Qga2V5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzS2V5YWJsZSh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuICh0eXBlID09ICdzdHJpbmcnIHx8IHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJylcbiAgICA/ICh2YWx1ZSAhPT0gJ19fcHJvdG9fXycpXG4gICAgOiAodmFsdWUgPT09IG51bGwpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzS2V5YWJsZTtcbiIsInZhciBnZXRNYXBEYXRhID0gcmVxdWlyZSgnLi9fZ2V0TWFwRGF0YScpO1xuXG4vKipcbiAqIEdldHMgdGhlIG1hcCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVHZXQoa2V5KSB7XG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuZ2V0KGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVHZXQ7XG4iLCJ2YXIgZ2V0TWFwRGF0YSA9IHJlcXVpcmUoJy4vX2dldE1hcERhdGEnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBtYXAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5oYXMoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZUhhcztcbiIsInZhciBnZXRNYXBEYXRhID0gcmVxdWlyZSgnLi9fZ2V0TWFwRGF0YScpO1xuXG4vKipcbiAqIFNldHMgdGhlIG1hcCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBtYXAgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSksXG4gICAgICBzaXplID0gZGF0YS5zaXplO1xuXG4gIGRhdGEuc2V0KGtleSwgdmFsdWUpO1xuICB0aGlzLnNpemUgKz0gZGF0YS5zaXplID09IHNpemUgPyAwIDogMTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVTZXQ7XG4iLCJ2YXIgY3JlYXRlQmFzZUZvciA9IHJlcXVpcmUoJy4vX2NyZWF0ZUJhc2VGb3InKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgYmFzZUZvck93bmAgd2hpY2ggaXRlcmF0ZXMgb3ZlciBgb2JqZWN0YFxuICogcHJvcGVydGllcyByZXR1cm5lZCBieSBga2V5c0Z1bmNgIGFuZCBpbnZva2VzIGBpdGVyYXRlZWAgZm9yIGVhY2ggcHJvcGVydHkuXG4gKiBJdGVyYXRlZSBmdW5jdGlvbnMgbWF5IGV4aXQgaXRlcmF0aW9uIGVhcmx5IGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBgb2JqZWN0YC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbnZhciBiYXNlRm9yID0gY3JlYXRlQmFzZUZvcigpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VGb3I7XG4iLCIvKipcbiAqIENyZWF0ZXMgYSBiYXNlIGZ1bmN0aW9uIGZvciBtZXRob2RzIGxpa2UgYF8uZm9ySW5gIGFuZCBgXy5mb3JPd25gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJhc2UgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUJhc2VGb3IoZnJvbVJpZ2h0KSB7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QsIGl0ZXJhdGVlLCBrZXlzRnVuYykge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBpdGVyYWJsZSA9IE9iamVjdChvYmplY3QpLFxuICAgICAgICBwcm9wcyA9IGtleXNGdW5jKG9iamVjdCksXG4gICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgdmFyIGtleSA9IHByb3BzW2Zyb21SaWdodCA/IGxlbmd0aCA6ICsraW5kZXhdO1xuICAgICAgaWYgKGl0ZXJhdGVlKGl0ZXJhYmxlW2tleV0sIGtleSwgaXRlcmFibGUpID09PSBmYWxzZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVCYXNlRm9yO1xuIiwidmFyIGFzc2lnbk1lcmdlVmFsdWUgPSByZXF1aXJlKCcuL19hc3NpZ25NZXJnZVZhbHVlJyksXG4gICAgY2xvbmVCdWZmZXIgPSByZXF1aXJlKCcuL19jbG9uZUJ1ZmZlcicpLFxuICAgIGNsb25lVHlwZWRBcnJheSA9IHJlcXVpcmUoJy4vX2Nsb25lVHlwZWRBcnJheScpLFxuICAgIGNvcHlBcnJheSA9IHJlcXVpcmUoJy4vX2NvcHlBcnJheScpLFxuICAgIGluaXRDbG9uZU9iamVjdCA9IHJlcXVpcmUoJy4vX2luaXRDbG9uZU9iamVjdCcpLFxuICAgIGlzQXJndW1lbnRzID0gcmVxdWlyZSgnLi9pc0FyZ3VtZW50cycpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc0FycmF5TGlrZU9iamVjdCA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2VPYmplY3QnKSxcbiAgICBpc0J1ZmZlciA9IHJlcXVpcmUoJy4vaXNCdWZmZXInKSxcbiAgICBpc0Z1bmN0aW9uID0gcmVxdWlyZSgnLi9pc0Z1bmN0aW9uJyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0JyksXG4gICAgaXNQbGFpbk9iamVjdCA9IHJlcXVpcmUoJy4vaXNQbGFpbk9iamVjdCcpLFxuICAgIGlzVHlwZWRBcnJheSA9IHJlcXVpcmUoJy4vaXNUeXBlZEFycmF5JyksXG4gICAgc2FmZUdldCA9IHJlcXVpcmUoJy4vX3NhZmVHZXQnKSxcbiAgICB0b1BsYWluT2JqZWN0ID0gcmVxdWlyZSgnLi90b1BsYWluT2JqZWN0Jyk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlTWVyZ2VgIGZvciBhcnJheXMgYW5kIG9iamVjdHMgd2hpY2ggcGVyZm9ybXNcbiAqIGRlZXAgbWVyZ2VzIGFuZCB0cmFja3MgdHJhdmVyc2VkIG9iamVjdHMgZW5hYmxpbmcgb2JqZWN0cyB3aXRoIGNpcmN1bGFyXG4gKiByZWZlcmVuY2VzIHRvIGJlIG1lcmdlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gbWVyZ2UuXG4gKiBAcGFyYW0ge251bWJlcn0gc3JjSW5kZXggVGhlIGluZGV4IG9mIGBzb3VyY2VgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gbWVyZ2VGdW5jIFRoZSBmdW5jdGlvbiB0byBtZXJnZSB2YWx1ZXMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBhc3NpZ25lZCB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIHNvdXJjZSB2YWx1ZXMgYW5kIHRoZWlyIG1lcmdlZFxuICogIGNvdW50ZXJwYXJ0cy5cbiAqL1xuZnVuY3Rpb24gYmFzZU1lcmdlRGVlcChvYmplY3QsIHNvdXJjZSwga2V5LCBzcmNJbmRleCwgbWVyZ2VGdW5jLCBjdXN0b21pemVyLCBzdGFjaykge1xuICB2YXIgb2JqVmFsdWUgPSBzYWZlR2V0KG9iamVjdCwga2V5KSxcbiAgICAgIHNyY1ZhbHVlID0gc2FmZUdldChzb3VyY2UsIGtleSksXG4gICAgICBzdGFja2VkID0gc3RhY2suZ2V0KHNyY1ZhbHVlKTtcblxuICBpZiAoc3RhY2tlZCkge1xuICAgIGFzc2lnbk1lcmdlVmFsdWUob2JqZWN0LCBrZXksIHN0YWNrZWQpO1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbmV3VmFsdWUgPSBjdXN0b21pemVyXG4gICAgPyBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSwgKGtleSArICcnKSwgb2JqZWN0LCBzb3VyY2UsIHN0YWNrKVxuICAgIDogdW5kZWZpbmVkO1xuXG4gIHZhciBpc0NvbW1vbiA9IG5ld1ZhbHVlID09PSB1bmRlZmluZWQ7XG5cbiAgaWYgKGlzQ29tbW9uKSB7XG4gICAgdmFyIGlzQXJyID0gaXNBcnJheShzcmNWYWx1ZSksXG4gICAgICAgIGlzQnVmZiA9ICFpc0FyciAmJiBpc0J1ZmZlcihzcmNWYWx1ZSksXG4gICAgICAgIGlzVHlwZWQgPSAhaXNBcnIgJiYgIWlzQnVmZiAmJiBpc1R5cGVkQXJyYXkoc3JjVmFsdWUpO1xuXG4gICAgbmV3VmFsdWUgPSBzcmNWYWx1ZTtcbiAgICBpZiAoaXNBcnIgfHwgaXNCdWZmIHx8IGlzVHlwZWQpIHtcbiAgICAgIGlmIChpc0FycmF5KG9ialZhbHVlKSkge1xuICAgICAgICBuZXdWYWx1ZSA9IG9ialZhbHVlO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoaXNBcnJheUxpa2VPYmplY3Qob2JqVmFsdWUpKSB7XG4gICAgICAgIG5ld1ZhbHVlID0gY29weUFycmF5KG9ialZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGlzQnVmZikge1xuICAgICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgICAgICBuZXdWYWx1ZSA9IGNsb25lQnVmZmVyKHNyY1ZhbHVlLCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGlzVHlwZWQpIHtcbiAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICAgICAgbmV3VmFsdWUgPSBjbG9uZVR5cGVkQXJyYXkoc3JjVmFsdWUsIHRydWUpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIG5ld1ZhbHVlID0gW107XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzUGxhaW5PYmplY3Qoc3JjVmFsdWUpIHx8IGlzQXJndW1lbnRzKHNyY1ZhbHVlKSkge1xuICAgICAgbmV3VmFsdWUgPSBvYmpWYWx1ZTtcbiAgICAgIGlmIChpc0FyZ3VtZW50cyhvYmpWYWx1ZSkpIHtcbiAgICAgICAgbmV3VmFsdWUgPSB0b1BsYWluT2JqZWN0KG9ialZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKCFpc09iamVjdChvYmpWYWx1ZSkgfHwgaXNGdW5jdGlvbihvYmpWYWx1ZSkpIHtcbiAgICAgICAgbmV3VmFsdWUgPSBpbml0Q2xvbmVPYmplY3Qoc3JjVmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIGlmIChpc0NvbW1vbikge1xuICAgIC8vIFJlY3Vyc2l2ZWx5IG1lcmdlIG9iamVjdHMgYW5kIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIHN0YWNrLnNldChzcmNWYWx1ZSwgbmV3VmFsdWUpO1xuICAgIG1lcmdlRnVuYyhuZXdWYWx1ZSwgc3JjVmFsdWUsIHNyY0luZGV4LCBjdXN0b21pemVyLCBzdGFjayk7XG4gICAgc3RhY2tbJ2RlbGV0ZSddKHNyY1ZhbHVlKTtcbiAgfVxuICBhc3NpZ25NZXJnZVZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZU1lcmdlRGVlcDtcbiIsInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIEJ1ZmZlciA9IG1vZHVsZUV4cG9ydHMgPyByb290LkJ1ZmZlciA6IHVuZGVmaW5lZCxcbiAgICBhbGxvY1Vuc2FmZSA9IEJ1ZmZlciA/IEJ1ZmZlci5hbGxvY1Vuc2FmZSA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgIGBidWZmZXJgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmZmVyIFRoZSBidWZmZXIgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHJldHVybnMge0J1ZmZlcn0gUmV0dXJucyB0aGUgY2xvbmVkIGJ1ZmZlci5cbiAqL1xuZnVuY3Rpb24gY2xvbmVCdWZmZXIoYnVmZmVyLCBpc0RlZXApIHtcbiAgaWYgKGlzRGVlcCkge1xuICAgIHJldHVybiBidWZmZXIuc2xpY2UoKTtcbiAgfVxuICB2YXIgbGVuZ3RoID0gYnVmZmVyLmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IGFsbG9jVW5zYWZlID8gYWxsb2NVbnNhZmUobGVuZ3RoKSA6IG5ldyBidWZmZXIuY29uc3RydWN0b3IobGVuZ3RoKTtcblxuICBidWZmZXIuY29weShyZXN1bHQpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lQnVmZmVyO1xuIiwidmFyIGNsb25lQXJyYXlCdWZmZXIgPSByZXF1aXJlKCcuL19jbG9uZUFycmF5QnVmZmVyJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGB0eXBlZEFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHR5cGVkQXJyYXkgVGhlIHR5cGVkIGFycmF5IHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCB0eXBlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gY2xvbmVUeXBlZEFycmF5KHR5cGVkQXJyYXksIGlzRGVlcCkge1xuICB2YXIgYnVmZmVyID0gaXNEZWVwID8gY2xvbmVBcnJheUJ1ZmZlcih0eXBlZEFycmF5LmJ1ZmZlcikgOiB0eXBlZEFycmF5LmJ1ZmZlcjtcbiAgcmV0dXJuIG5ldyB0eXBlZEFycmF5LmNvbnN0cnVjdG9yKGJ1ZmZlciwgdHlwZWRBcnJheS5ieXRlT2Zmc2V0LCB0eXBlZEFycmF5Lmxlbmd0aCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmVUeXBlZEFycmF5O1xuIiwidmFyIFVpbnQ4QXJyYXkgPSByZXF1aXJlKCcuL19VaW50OEFycmF5Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGBhcnJheUJ1ZmZlcmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGFycmF5QnVmZmVyIFRoZSBhcnJheSBidWZmZXIgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7QXJyYXlCdWZmZXJ9IFJldHVybnMgdGhlIGNsb25lZCBhcnJheSBidWZmZXIuXG4gKi9cbmZ1bmN0aW9uIGNsb25lQXJyYXlCdWZmZXIoYXJyYXlCdWZmZXIpIHtcbiAgdmFyIHJlc3VsdCA9IG5ldyBhcnJheUJ1ZmZlci5jb25zdHJ1Y3RvcihhcnJheUJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgbmV3IFVpbnQ4QXJyYXkocmVzdWx0KS5zZXQobmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIpKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZUFycmF5QnVmZmVyO1xuIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIFVpbnQ4QXJyYXkgPSByb290LlVpbnQ4QXJyYXk7XG5cbm1vZHVsZS5leHBvcnRzID0gVWludDhBcnJheTtcbiIsIi8qKlxuICogQ29waWVzIHRoZSB2YWx1ZXMgb2YgYHNvdXJjZWAgdG8gYGFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gc291cmNlIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyBmcm9tLlxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5PVtdXSBUaGUgYXJyYXkgdG8gY29weSB2YWx1ZXMgdG8uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gY29weUFycmF5KHNvdXJjZSwgYXJyYXkpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBzb3VyY2UubGVuZ3RoO1xuXG4gIGFycmF5IHx8IChhcnJheSA9IEFycmF5KGxlbmd0aCkpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGFycmF5W2luZGV4XSA9IHNvdXJjZVtpbmRleF07XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcHlBcnJheTtcbiIsInZhciBiYXNlQ3JlYXRlID0gcmVxdWlyZSgnLi9fYmFzZUNyZWF0ZScpLFxuICAgIGdldFByb3RvdHlwZSA9IHJlcXVpcmUoJy4vX2dldFByb3RvdHlwZScpLFxuICAgIGlzUHJvdG90eXBlID0gcmVxdWlyZSgnLi9faXNQcm90b3R5cGUnKTtcblxuLyoqXG4gKiBJbml0aWFsaXplcyBhbiBvYmplY3QgY2xvbmUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGluaXRpYWxpemVkIGNsb25lLlxuICovXG5mdW5jdGlvbiBpbml0Q2xvbmVPYmplY3Qob2JqZWN0KSB7XG4gIHJldHVybiAodHlwZW9mIG9iamVjdC5jb25zdHJ1Y3RvciA9PSAnZnVuY3Rpb24nICYmICFpc1Byb3RvdHlwZShvYmplY3QpKVxuICAgID8gYmFzZUNyZWF0ZShnZXRQcm90b3R5cGUob2JqZWN0KSlcbiAgICA6IHt9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGluaXRDbG9uZU9iamVjdDtcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0Q3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jcmVhdGVgIHdpdGhvdXQgc3VwcG9ydCBmb3IgYXNzaWduaW5nXG4gKiBwcm9wZXJ0aWVzIHRvIHRoZSBjcmVhdGVkIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHByb3RvIFRoZSBvYmplY3QgdG8gaW5oZXJpdCBmcm9tLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAqL1xudmFyIGJhc2VDcmVhdGUgPSAoZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIG9iamVjdCgpIHt9XG4gIHJldHVybiBmdW5jdGlvbihwcm90bykge1xuICAgIGlmICghaXNPYmplY3QocHJvdG8pKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGlmIChvYmplY3RDcmVhdGUpIHtcbiAgICAgIHJldHVybiBvYmplY3RDcmVhdGUocHJvdG8pO1xuICAgIH1cbiAgICBvYmplY3QucHJvdG90eXBlID0gcHJvdG87XG4gICAgdmFyIHJlc3VsdCA9IG5ldyBvYmplY3Q7XG4gICAgb2JqZWN0LnByb3RvdHlwZSA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufSgpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlQ3JlYXRlO1xuIiwiLyoqXG4gKiBDcmVhdGVzIGEgdW5hcnkgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGl0cyBhcmd1bWVudCB0cmFuc2Zvcm1lZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgYXJndW1lbnQgdHJhbnNmb3JtLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG92ZXJBcmcoZnVuYywgdHJhbnNmb3JtKSB7XG4gIHJldHVybiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gZnVuYyh0cmFuc2Zvcm0oYXJnKSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gb3ZlckFyZztcbiIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNBcmd1bWVudHNgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAqL1xuZnVuY3Rpb24gYmFzZUlzQXJndW1lbnRzKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IGFyZ3NUYWc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzQXJndW1lbnRzO1xuIiwidmFyIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZScpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKlxuICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5pc0FycmF5TGlrZWAgZXhjZXB0IHRoYXQgaXQgYWxzbyBjaGVja3MgaWYgYHZhbHVlYFxuICogaXMgYW4gb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LWxpa2Ugb2JqZWN0LFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdCgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGlzQXJyYXlMaWtlKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0FycmF5TGlrZU9iamVjdDtcbiIsIi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBgZmFsc2VgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4xMy4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50aW1lcygyLCBfLnN0dWJGYWxzZSk7XG4gKiAvLyA9PiBbZmFsc2UsIGZhbHNlXVxuICovXG5mdW5jdGlvbiBzdHViRmFsc2UoKSB7XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdHViRmFsc2U7XG4iLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBnZXRQcm90b3R5cGUgPSByZXF1aXJlKCcuL19nZXRQcm90b3R5cGUnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XSc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGUsXG4gICAgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogVXNlZCB0byBpbmZlciB0aGUgYE9iamVjdGAgY29uc3RydWN0b3IuICovXG52YXIgb2JqZWN0Q3RvclN0cmluZyA9IGZ1bmNUb1N0cmluZy5jYWxsKE9iamVjdCk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIHRoYXQgaXMsIGFuIG9iamVjdCBjcmVhdGVkIGJ5IHRoZVxuICogYE9iamVjdGAgY29uc3RydWN0b3Igb3Igb25lIHdpdGggYSBgW1tQcm90b3R5cGVdXWAgb2YgYG51bGxgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC44LjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqIH1cbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QobmV3IEZvbyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QoeyAneCc6IDAsICd5JzogMCB9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QoT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdExpa2UodmFsdWUpIHx8IGJhc2VHZXRUYWcodmFsdWUpICE9IG9iamVjdFRhZykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgcHJvdG8gPSBnZXRQcm90b3R5cGUodmFsdWUpO1xuICBpZiAocHJvdG8gPT09IG51bGwpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB2YXIgQ3RvciA9IGhhc093blByb3BlcnR5LmNhbGwocHJvdG8sICdjb25zdHJ1Y3RvcicpICYmIHByb3RvLmNvbnN0cnVjdG9yO1xuICByZXR1cm4gdHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yIGluc3RhbmNlb2YgQ3RvciAmJlxuICAgIGZ1bmNUb1N0cmluZy5jYWxsKEN0b3IpID09IG9iamVjdEN0b3JTdHJpbmc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNQbGFpbk9iamVjdDtcbiIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzTGVuZ3RoID0gcmVxdWlyZSgnLi9pc0xlbmd0aCcpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XScsXG4gICAgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcbiAgICBpbnQ4VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgdWludDhUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgIHVpbnQzMlRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XG5cbi8qKiBVc2VkIHRvIGlkZW50aWZ5IGB0b1N0cmluZ1RhZ2AgdmFsdWVzIG9mIHR5cGVkIGFycmF5cy4gKi9cbnZhciB0eXBlZEFycmF5VGFncyA9IHt9O1xudHlwZWRBcnJheVRhZ3NbZmxvYXQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1tmbG9hdDY0VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQ4VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2ludDE2VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50OFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDhDbGFtcGVkVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDMyVGFnXSA9IHRydWU7XG50eXBlZEFycmF5VGFnc1thcmdzVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2FycmF5VGFnXSA9XG50eXBlZEFycmF5VGFnc1thcnJheUJ1ZmZlclRhZ10gPSB0eXBlZEFycmF5VGFnc1tib29sVGFnXSA9XG50eXBlZEFycmF5VGFnc1tkYXRhVmlld1RhZ10gPSB0eXBlZEFycmF5VGFnc1tkYXRlVGFnXSA9XG50eXBlZEFycmF5VGFnc1tlcnJvclRhZ10gPSB0eXBlZEFycmF5VGFnc1tmdW5jVGFnXSA9XG50eXBlZEFycmF5VGFnc1ttYXBUYWddID0gdHlwZWRBcnJheVRhZ3NbbnVtYmVyVGFnXSA9XG50eXBlZEFycmF5VGFnc1tvYmplY3RUYWddID0gdHlwZWRBcnJheVRhZ3NbcmVnZXhwVGFnXSA9XG50eXBlZEFycmF5VGFnc1tzZXRUYWddID0gdHlwZWRBcnJheVRhZ3Nbc3RyaW5nVGFnXSA9XG50eXBlZEFycmF5VGFnc1t3ZWFrTWFwVGFnXSA9IGZhbHNlO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzVHlwZWRBcnJheWAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNUeXBlZEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmXG4gICAgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhIXR5cGVkQXJyYXlUYWdzW2Jhc2VHZXRUYWcodmFsdWUpXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNUeXBlZEFycmF5O1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51bmFyeWAgd2l0aG91dCBzdXBwb3J0IGZvciBzdG9yaW5nIG1ldGFkYXRhLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjYXAgYXJndW1lbnRzIGZvci5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNhcHBlZCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVVuYXJ5KGZ1bmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIGZ1bmModmFsdWUpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VVbmFyeTtcbiIsInZhciBmcmVlR2xvYmFsID0gcmVxdWlyZSgnLi9fZnJlZUdsb2JhbCcpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgcHJvY2Vzc2AgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVQcm9jZXNzID0gbW9kdWxlRXhwb3J0cyAmJiBmcmVlR2xvYmFsLnByb2Nlc3M7XG5cbi8qKiBVc2VkIHRvIGFjY2VzcyBmYXN0ZXIgTm9kZS5qcyBoZWxwZXJzLiAqL1xudmFyIG5vZGVVdGlsID0gKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIC8vIFVzZSBgdXRpbC50eXBlc2AgZm9yIE5vZGUuanMgMTArLlxuICAgIHZhciB0eXBlcyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5yZXF1aXJlICYmIGZyZWVNb2R1bGUucmVxdWlyZSgndXRpbCcpLnR5cGVzO1xuXG4gICAgaWYgKHR5cGVzKSB7XG4gICAgICByZXR1cm4gdHlwZXM7XG4gICAgfVxuXG4gICAgLy8gTGVnYWN5IGBwcm9jZXNzLmJpbmRpbmcoJ3V0aWwnKWAgZm9yIE5vZGUuanMgPCAxMC5cbiAgICByZXR1cm4gZnJlZVByb2Nlc3MgJiYgZnJlZVByb2Nlc3MuYmluZGluZyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nKCd1dGlsJyk7XG4gIH0gY2F0Y2ggKGUpIHt9XG59KCkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5vZGVVdGlsO1xuIiwidmFyIGNvcHlPYmplY3QgPSByZXF1aXJlKCcuL19jb3B5T2JqZWN0JyksXG4gICAga2V5c0luID0gcmVxdWlyZSgnLi9rZXlzSW4nKTtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgcGxhaW4gb2JqZWN0IGZsYXR0ZW5pbmcgaW5oZXJpdGVkIGVudW1lcmFibGUgc3RyaW5nXG4gKiBrZXllZCBwcm9wZXJ0aWVzIG9mIGB2YWx1ZWAgdG8gb3duIHByb3BlcnRpZXMgb2YgdGhlIHBsYWluIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBwbGFpbiBvYmplY3QuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8uYXNzaWduKHsgJ2EnOiAxIH0sIG5ldyBGb28pO1xuICogLy8gPT4geyAnYSc6IDEsICdiJzogMiB9XG4gKlxuICogXy5hc3NpZ24oeyAnYSc6IDEgfSwgXy50b1BsYWluT2JqZWN0KG5ldyBGb28pKTtcbiAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMyB9XG4gKi9cbmZ1bmN0aW9uIHRvUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIGNvcHlPYmplY3QodmFsdWUsIGtleXNJbih2YWx1ZSkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvUGxhaW5PYmplY3Q7XG4iLCJ2YXIgYXNzaWduVmFsdWUgPSByZXF1aXJlKCcuL19hc3NpZ25WYWx1ZScpLFxuICAgIGJhc2VBc3NpZ25WYWx1ZSA9IHJlcXVpcmUoJy4vX2Jhc2VBc3NpZ25WYWx1ZScpO1xuXG4vKipcbiAqIENvcGllcyBwcm9wZXJ0aWVzIG9mIGBzb3VyY2VgIHRvIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIGZyb20uXG4gKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgaWRlbnRpZmllcnMgdG8gY29weS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0PXt9XSBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyB0by5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvcGllZCB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBjb3B5T2JqZWN0KHNvdXJjZSwgcHJvcHMsIG9iamVjdCwgY3VzdG9taXplcikge1xuICB2YXIgaXNOZXcgPSAhb2JqZWN0O1xuICBvYmplY3QgfHwgKG9iamVjdCA9IHt9KTtcblxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBrZXkgPSBwcm9wc1tpbmRleF07XG5cbiAgICB2YXIgbmV3VmFsdWUgPSBjdXN0b21pemVyXG4gICAgICA/IGN1c3RvbWl6ZXIob2JqZWN0W2tleV0sIHNvdXJjZVtrZXldLCBrZXksIG9iamVjdCwgc291cmNlKVxuICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICBpZiAobmV3VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgbmV3VmFsdWUgPSBzb3VyY2Vba2V5XTtcbiAgICB9XG4gICAgaWYgKGlzTmV3KSB7XG4gICAgICBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzaWduVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9iamVjdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb3B5T2JqZWN0O1xuIiwidmFyIGJhc2VUaW1lcyA9IHJlcXVpcmUoJy4vX2Jhc2VUaW1lcycpLFxuICAgIGlzQXJndW1lbnRzID0gcmVxdWlyZSgnLi9pc0FyZ3VtZW50cycpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc0J1ZmZlciA9IHJlcXVpcmUoJy4vaXNCdWZmZXInKSxcbiAgICBpc0luZGV4ID0gcmVxdWlyZSgnLi9faXNJbmRleCcpLFxuICAgIGlzVHlwZWRBcnJheSA9IHJlcXVpcmUoJy4vaXNUeXBlZEFycmF5Jyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiB0aGUgYXJyYXktbGlrZSBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5oZXJpdGVkIFNwZWNpZnkgcmV0dXJuaW5nIGluaGVyaXRlZCBwcm9wZXJ0eSBuYW1lcy5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGFycmF5TGlrZUtleXModmFsdWUsIGluaGVyaXRlZCkge1xuICB2YXIgaXNBcnIgPSBpc0FycmF5KHZhbHVlKSxcbiAgICAgIGlzQXJnID0gIWlzQXJyICYmIGlzQXJndW1lbnRzKHZhbHVlKSxcbiAgICAgIGlzQnVmZiA9ICFpc0FyciAmJiAhaXNBcmcgJiYgaXNCdWZmZXIodmFsdWUpLFxuICAgICAgaXNUeXBlID0gIWlzQXJyICYmICFpc0FyZyAmJiAhaXNCdWZmICYmIGlzVHlwZWRBcnJheSh2YWx1ZSksXG4gICAgICBza2lwSW5kZXhlcyA9IGlzQXJyIHx8IGlzQXJnIHx8IGlzQnVmZiB8fCBpc1R5cGUsXG4gICAgICByZXN1bHQgPSBza2lwSW5kZXhlcyA/IGJhc2VUaW1lcyh2YWx1ZS5sZW5ndGgsIFN0cmluZykgOiBbXSxcbiAgICAgIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG5cbiAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgaWYgKChpbmhlcml0ZWQgfHwgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwga2V5KSkgJiZcbiAgICAgICAgIShza2lwSW5kZXhlcyAmJiAoXG4gICAgICAgICAgIC8vIFNhZmFyaSA5IGhhcyBlbnVtZXJhYmxlIGBhcmd1bWVudHMubGVuZ3RoYCBpbiBzdHJpY3QgbW9kZS5cbiAgICAgICAgICAga2V5ID09ICdsZW5ndGgnIHx8XG4gICAgICAgICAgIC8vIE5vZGUuanMgMC4xMCBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiBidWZmZXJzLlxuICAgICAgICAgICAoaXNCdWZmICYmIChrZXkgPT0gJ29mZnNldCcgfHwga2V5ID09ICdwYXJlbnQnKSkgfHxcbiAgICAgICAgICAgLy8gUGhhbnRvbUpTIDIgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gdHlwZWQgYXJyYXlzLlxuICAgICAgICAgICAoaXNUeXBlICYmIChrZXkgPT0gJ2J1ZmZlcicgfHwga2V5ID09ICdieXRlTGVuZ3RoJyB8fCBrZXkgPT0gJ2J5dGVPZmZzZXQnKSkgfHxcbiAgICAgICAgICAgLy8gU2tpcCBpbmRleCBwcm9wZXJ0aWVzLlxuICAgICAgICAgICBpc0luZGV4KGtleSwgbGVuZ3RoKVxuICAgICAgICApKSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheUxpa2VLZXlzO1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50aW1lc2Agd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzXG4gKiBvciBtYXggYXJyYXkgbGVuZ3RoIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiB0aW1lcyB0byBpbnZva2UgYGl0ZXJhdGVlYC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHJlc3VsdHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VUaW1lcyhuLCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KG4pO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbikge1xuICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShpbmRleCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlVGltZXM7XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0JyksXG4gICAgaXNQcm90b3R5cGUgPSByZXF1aXJlKCcuL19pc1Byb3RvdHlwZScpLFxuICAgIG5hdGl2ZUtleXNJbiA9IHJlcXVpcmUoJy4vX25hdGl2ZUtleXNJbicpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmtleXNJbmAgd2hpY2ggZG9lc24ndCB0cmVhdCBzcGFyc2UgYXJyYXlzIGFzIGRlbnNlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBiYXNlS2V5c0luKG9iamVjdCkge1xuICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICByZXR1cm4gbmF0aXZlS2V5c0luKG9iamVjdCk7XG4gIH1cbiAgdmFyIGlzUHJvdG8gPSBpc1Byb3RvdHlwZShvYmplY3QpLFxuICAgICAgcmVzdWx0ID0gW107XG5cbiAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgIGlmICghKGtleSA9PSAnY29uc3RydWN0b3InICYmIChpc1Byb3RvIHx8ICFoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VLZXlzSW47XG4iLCIvKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZVxuICogW2BPYmplY3Qua2V5c2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5rZXlzKVxuICogZXhjZXB0IHRoYXQgaXQgaW5jbHVkZXMgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydGllcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gbmF0aXZlS2V5c0luKG9iamVjdCkge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGlmIChvYmplY3QgIT0gbnVsbCkge1xuICAgIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBuYXRpdmVLZXlzSW47XG4iLCJ2YXIgYmFzZVJlc3QgPSByZXF1aXJlKCcuL19iYXNlUmVzdCcpLFxuICAgIGlzSXRlcmF0ZWVDYWxsID0gcmVxdWlyZSgnLi9faXNJdGVyYXRlZUNhbGwnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gbGlrZSBgXy5hc3NpZ25gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBhc3NpZ25lciBUaGUgZnVuY3Rpb24gdG8gYXNzaWduIHZhbHVlcy5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFzc2lnbmVyIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVBc3NpZ25lcihhc3NpZ25lcikge1xuICByZXR1cm4gYmFzZVJlc3QoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2VzKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IHNvdXJjZXMubGVuZ3RoLFxuICAgICAgICBjdXN0b21pemVyID0gbGVuZ3RoID4gMSA/IHNvdXJjZXNbbGVuZ3RoIC0gMV0gOiB1bmRlZmluZWQsXG4gICAgICAgIGd1YXJkID0gbGVuZ3RoID4gMiA/IHNvdXJjZXNbMl0gOiB1bmRlZmluZWQ7XG5cbiAgICBjdXN0b21pemVyID0gKGFzc2lnbmVyLmxlbmd0aCA+IDMgJiYgdHlwZW9mIGN1c3RvbWl6ZXIgPT0gJ2Z1bmN0aW9uJylcbiAgICAgID8gKGxlbmd0aC0tLCBjdXN0b21pemVyKVxuICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICBpZiAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwoc291cmNlc1swXSwgc291cmNlc1sxXSwgZ3VhcmQpKSB7XG4gICAgICBjdXN0b21pemVyID0gbGVuZ3RoIDwgMyA/IHVuZGVmaW5lZCA6IGN1c3RvbWl6ZXI7XG4gICAgICBsZW5ndGggPSAxO1xuICAgIH1cbiAgICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgdmFyIHNvdXJjZSA9IHNvdXJjZXNbaW5kZXhdO1xuICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICBhc3NpZ25lcihvYmplY3QsIHNvdXJjZSwgaW5kZXgsIGN1c3RvbWl6ZXIpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0O1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVBc3NpZ25lcjtcbiIsInZhciBpZGVudGl0eSA9IHJlcXVpcmUoJy4vaWRlbnRpdHknKSxcbiAgICBvdmVyUmVzdCA9IHJlcXVpcmUoJy4vX292ZXJSZXN0JyksXG4gICAgc2V0VG9TdHJpbmcgPSByZXF1aXJlKCcuL19zZXRUb1N0cmluZycpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnJlc3RgIHdoaWNoIGRvZXNuJ3QgdmFsaWRhdGUgb3IgY29lcmNlIGFyZ3VtZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9ZnVuYy5sZW5ndGgtMV0gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSByZXN0IHBhcmFtZXRlci5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlUmVzdChmdW5jLCBzdGFydCkge1xuICByZXR1cm4gc2V0VG9TdHJpbmcob3ZlclJlc3QoZnVuYywgc3RhcnQsIGlkZW50aXR5KSwgZnVuYyArICcnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlUmVzdDtcbiIsIi8qKlxuICogQSBmYXN0ZXIgYWx0ZXJuYXRpdmUgdG8gYEZ1bmN0aW9uI2FwcGx5YCwgdGhpcyBmdW5jdGlvbiBpbnZva2VzIGBmdW5jYFxuICogd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgYHRoaXNBcmdgIGFuZCB0aGUgYXJndW1lbnRzIG9mIGBhcmdzYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaW52b2tlLlxuICogQHBhcmFtIHsqfSB0aGlzQXJnIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gKiBAcGFyYW0ge0FycmF5fSBhcmdzIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIGBmdW5jYCB3aXRoLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc3VsdCBvZiBgZnVuY2AuXG4gKi9cbmZ1bmN0aW9uIGFwcGx5KGZ1bmMsIHRoaXNBcmcsIGFyZ3MpIHtcbiAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgIGNhc2UgMDogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnKTtcbiAgICBjYXNlIDE6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSk7XG4gICAgY2FzZSAyOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgIGNhc2UgMzogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgfVxuICByZXR1cm4gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcHBseTtcbiIsInZhciBjb25zdGFudCA9IHJlcXVpcmUoJy4vY29uc3RhbnQnKSxcbiAgICBkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX2RlZmluZVByb3BlcnR5JyksXG4gICAgaWRlbnRpdHkgPSByZXF1aXJlKCcuL2lkZW50aXR5Jyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYHNldFRvU3RyaW5nYCB3aXRob3V0IHN1cHBvcnQgZm9yIGhvdCBsb29wIHNob3J0aW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdHJpbmcgVGhlIGB0b1N0cmluZ2AgcmVzdWx0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBmdW5jYC5cbiAqL1xudmFyIGJhc2VTZXRUb1N0cmluZyA9ICFkZWZpbmVQcm9wZXJ0eSA/IGlkZW50aXR5IDogZnVuY3Rpb24oZnVuYywgc3RyaW5nKSB7XG4gIHJldHVybiBkZWZpbmVQcm9wZXJ0eShmdW5jLCAndG9TdHJpbmcnLCB7XG4gICAgJ2NvbmZpZ3VyYWJsZSc6IHRydWUsXG4gICAgJ2VudW1lcmFibGUnOiBmYWxzZSxcbiAgICAndmFsdWUnOiBjb25zdGFudChzdHJpbmcpLFxuICAgICd3cml0YWJsZSc6IHRydWVcbiAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VTZXRUb1N0cmluZztcbiIsIi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBgdmFsdWVgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMi40LjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byByZXR1cm4gZnJvbSB0aGUgbmV3IGZ1bmN0aW9uLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY29uc3RhbnQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3RzID0gXy50aW1lcygyLCBfLmNvbnN0YW50KHsgJ2EnOiAxIH0pKTtcbiAqXG4gKiBjb25zb2xlLmxvZyhvYmplY3RzKTtcbiAqIC8vID0+IFt7ICdhJzogMSB9LCB7ICdhJzogMSB9XVxuICpcbiAqIGNvbnNvbGUubG9nKG9iamVjdHNbMF0gPT09IG9iamVjdHNbMV0pO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBjb25zdGFudCh2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnN0YW50O1xuIiwiLyoqIFVzZWQgdG8gZGV0ZWN0IGhvdCBmdW5jdGlvbnMgYnkgbnVtYmVyIG9mIGNhbGxzIHdpdGhpbiBhIHNwYW4gb2YgbWlsbGlzZWNvbmRzLiAqL1xudmFyIEhPVF9DT1VOVCA9IDgwMCxcbiAgICBIT1RfU1BBTiA9IDE2O1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlTm93ID0gRGF0ZS5ub3c7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQnbGwgc2hvcnQgb3V0IGFuZCBpbnZva2UgYGlkZW50aXR5YCBpbnN0ZWFkXG4gKiBvZiBgZnVuY2Agd2hlbiBpdCdzIGNhbGxlZCBgSE9UX0NPVU5UYCBvciBtb3JlIHRpbWVzIGluIGBIT1RfU1BBTmBcbiAqIG1pbGxpc2Vjb25kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcmVzdHJpY3QuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzaG9ydGFibGUgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIHNob3J0T3V0KGZ1bmMpIHtcbiAgdmFyIGNvdW50ID0gMCxcbiAgICAgIGxhc3RDYWxsZWQgPSAwO1xuXG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc3RhbXAgPSBuYXRpdmVOb3coKSxcbiAgICAgICAgcmVtYWluaW5nID0gSE9UX1NQQU4gLSAoc3RhbXAgLSBsYXN0Q2FsbGVkKTtcblxuICAgIGxhc3RDYWxsZWQgPSBzdGFtcDtcbiAgICBpZiAocmVtYWluaW5nID4gMCkge1xuICAgICAgaWYgKCsrY291bnQgPj0gSE9UX0NPVU5UKSB7XG4gICAgICAgIHJldHVybiBhcmd1bWVudHNbMF07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvdW50ID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmMuYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNob3J0T3V0O1xuIiwidmFyIGVxID0gcmVxdWlyZSgnLi9lcScpLFxuICAgIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZScpLFxuICAgIGlzSW5kZXggPSByZXF1aXJlKCcuL19pc0luZGV4JyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0Jyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBhcmd1bWVudHMgYXJlIGZyb20gYW4gaXRlcmF0ZWUgY2FsbC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIHZhbHVlIGFyZ3VtZW50LlxuICogQHBhcmFtIHsqfSBpbmRleCBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIGluZGV4IG9yIGtleSBhcmd1bWVudC5cbiAqIEBwYXJhbSB7Kn0gb2JqZWN0IFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgb2JqZWN0IGFyZ3VtZW50LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBhcmd1bWVudHMgYXJlIGZyb20gYW4gaXRlcmF0ZWUgY2FsbCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSXRlcmF0ZWVDYWxsKHZhbHVlLCBpbmRleCwgb2JqZWN0KSB7XG4gIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdHlwZSA9IHR5cGVvZiBpbmRleDtcbiAgaWYgKHR5cGUgPT0gJ251bWJlcidcbiAgICAgICAgPyAoaXNBcnJheUxpa2Uob2JqZWN0KSAmJiBpc0luZGV4KGluZGV4LCBvYmplY3QubGVuZ3RoKSlcbiAgICAgICAgOiAodHlwZSA9PSAnc3RyaW5nJyAmJiBpbmRleCBpbiBvYmplY3QpXG4gICAgICApIHtcbiAgICByZXR1cm4gZXEob2JqZWN0W2luZGV4XSwgdmFsdWUpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0l0ZXJhdGVlQ2FsbDtcbiIsIi8qXHJcbiAqIHR5cGVkZWZzLmpzXHJcbiAqIE5vcm1hbGl6ZXMgYnJvd3Nlci1zcGVjaWZpYyBwcmVmaXhlcyBhbmQgcHJvdmlkZSBzb21lIGJhc2ljIHBvbHlmaWxsc1xyXG4gKi9cclxuXHJcbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgaWYgKCF3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKSB7XHJcbiAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB3aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lXHJcbiAgICAgICAgICAgICAgICB8fCB3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lXHJcbiAgICAgICAgICAgICAgICB8fCB3aW5kb3cub1JlcXVlc3RBbmltYXRpb25GcmFtZVxyXG4gICAgICAgICAgICAgICAgfHwgd2luZG93Lm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lXHJcbiAgICAgICAgICAgICAgICB8fCBmdW5jdGlvbiAoLyogZnVuY3Rpb24gRnJhbWVSZXF1ZXN0Q2FsbGJhY2sgKi8gY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgICAgICB3aW5kb3cuc2V0VGltZW91dChjYWxsYmFjaywgMTAwMCAvIDYwKTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSgpKTtcclxuICAgIH1cclxufVxyXG5cclxuaWYgKHR5cGVvZiBNYXRoLmltdWwgIT09ICdmdW5jdGlvbicpIHtcclxuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWJpdHdpc2UgKi9cclxuICAgIE1hdGguaW11bCA9IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgY29uc3QgYWggPSAoYSA+Pj4gMTYpICYgMHhmZmZmO1xyXG4gICAgICAgIGNvbnN0IGFsID0gYSAmIDB4ZmZmZjtcclxuICAgICAgICBjb25zdCBiaCA9IChiID4+PiAxNikgJiAweGZmZmY7XHJcbiAgICAgICAgY29uc3QgYmwgPSBiICYgMHhmZmZmO1xyXG4gICAgICAgIC8vIHRoZSBzaGlmdCBieSAwIGZpeGVzIHRoZSBzaWduIG9uIHRoZSBoaWdoIHBhcnRcclxuICAgICAgICAvLyB0aGUgZmluYWwgfDAgY29udmVydHMgdGhlIHVuc2lnbmVkIHZhbHVlIGludG8gYSBzaWduZWQgdmFsdWVcclxuICAgICAgICByZXR1cm4gKChhbCAqIGJsKSArICgoKGFoICogYmwgKyBhbCAqIGJoKSA8PCAxNikgPj4+IDApIHwgMCk7XHJcbiAgICB9O1xyXG4gICAgLyogZXNsaW50LWVuYWJsZSBuby1iaXR3aXNlICovXHJcbn1cclxuXHJcbmlmICh0eXBlb2YgT2JqZWN0LmFzc2lnbiAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgT2JqZWN0LmFzc2lnbiA9IGZ1bmN0aW9uICh0YXJnZXQpIHsgLy8gLmxlbmd0aCBvZiBmdW5jdGlvbiBpcyAyXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG4gICAgICAgIGlmICh0YXJnZXQgPT09IG51bGwpIHsgLy8gVHlwZUVycm9yIGlmIHVuZGVmaW5lZCBvciBudWxsXHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjb252ZXJ0IHVuZGVmaW5lZCBvciBudWxsIHRvIG9iamVjdCcpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgdG8gPSBPYmplY3QodGFyZ2V0KTtcclxuXHJcbiAgICAgICAgZm9yIChsZXQgaW5kZXggPSAxOyBpbmRleCA8IGFyZ3VtZW50cy5sZW5ndGg7IGluZGV4KyspIHtcclxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1yZXN0LXBhcmFtc1xyXG4gICAgICAgICAgICBjb25zdCBuZXh0U291cmNlID0gYXJndW1lbnRzW2luZGV4XTtcclxuXHJcbiAgICAgICAgICAgIGlmIChuZXh0U291cmNlICE9PSBudWxsKSB7IC8vIFNraXAgb3ZlciBpZiB1bmRlZmluZWQgb3IgbnVsbFxyXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IG5leHRLZXkgaW4gbmV4dFNvdXJjZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEF2b2lkIGJ1Z3Mgd2hlbiBoYXNPd25Qcm9wZXJ0eSBpcyBzaGFkb3dlZFxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobmV4dFNvdXJjZSwgbmV4dEtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdG9bbmV4dEtleV0gPSBuZXh0U291cmNlW25leHRLZXldO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdG87XHJcbiAgICB9O1xyXG59XHJcbiIsImZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfYXJyYXlXaXRoSG9sZXM7XG5tb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7IiwiZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkge1xuICB2YXIgX2kgPSBhcnIgPT0gbnVsbCA/IG51bGwgOiB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIGFycltTeW1ib2wuaXRlcmF0b3JdIHx8IGFycltcIkBAaXRlcmF0b3JcIl07XG5cbiAgaWYgKF9pID09IG51bGwpIHJldHVybjtcbiAgdmFyIF9hcnIgPSBbXTtcbiAgdmFyIF9uID0gdHJ1ZTtcbiAgdmFyIF9kID0gZmFsc2U7XG5cbiAgdmFyIF9zLCBfZTtcblxuICB0cnkge1xuICAgIGZvciAoX2kgPSBfaS5jYWxsKGFycik7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHtcbiAgICAgIF9hcnIucHVzaChfcy52YWx1ZSk7XG5cbiAgICAgIGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhaztcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9kID0gdHJ1ZTtcbiAgICBfZSA9IGVycjtcbiAgfSBmaW5hbGx5IHtcbiAgICB0cnkge1xuICAgICAgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSAhPSBudWxsKSBfaVtcInJldHVyblwiXSgpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAoX2QpIHRocm93IF9lO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBfYXJyO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9pdGVyYWJsZVRvQXJyYXlMaW1pdDtcbm1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsiLCJmdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9ub25JdGVyYWJsZVJlc3Q7XG5tb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7IiwibW9kdWxlLmV4cG9ydHMgPSBjbG9uZVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgdmVjMiBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIHZlY3RvclxuICpcbiAqIEBwYXJhbSB7dmVjMn0gYSB2ZWN0b3IgdG8gY2xvbmVcbiAqIEByZXR1cm5zIHt2ZWMyfSBhIG5ldyAyRCB2ZWN0b3JcbiAqL1xuZnVuY3Rpb24gY2xvbmUoYSkge1xuICAgIHZhciBvdXQgPSBuZXcgRmxvYXQzMkFycmF5KDIpXG4gICAgb3V0WzBdID0gYVswXVxuICAgIG91dFsxXSA9IGFbMV1cbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSBmcm9tVmFsdWVzXG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB2ZWMyIGluaXRpYWxpemVkIHdpdGggdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxuICogQHJldHVybnMge3ZlYzJ9IGEgbmV3IDJEIHZlY3RvclxuICovXG5mdW5jdGlvbiBmcm9tVmFsdWVzKHgsIHkpIHtcbiAgICB2YXIgb3V0ID0gbmV3IEZsb2F0MzJBcnJheSgyKVxuICAgIG91dFswXSA9IHhcbiAgICBvdXRbMV0gPSB5XG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gY29weVxuXG4vKipcbiAqIENvcHkgdGhlIHZhbHVlcyBmcm9tIG9uZSB2ZWMyIHRvIGFub3RoZXJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBzb3VyY2UgdmVjdG9yXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmZ1bmN0aW9uIGNvcHkob3V0LCBhKSB7XG4gICAgb3V0WzBdID0gYVswXVxuICAgIG91dFsxXSA9IGFbMV1cbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSBzZXRcblxuLyoqXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMyIHRvIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmZ1bmN0aW9uIHNldChvdXQsIHgsIHkpIHtcbiAgICBvdXRbMF0gPSB4XG4gICAgb3V0WzFdID0geVxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IGVxdWFsc1xuXG52YXIgRVBTSUxPTiA9IHJlcXVpcmUoJy4vZXBzaWxvbicpXG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgdmVjdG9ycyBoYXZlIGFwcHJveGltYXRlbHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24uXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBhIFRoZSBmaXJzdCB2ZWN0b3IuXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgVGhlIHNlY29uZCB2ZWN0b3IuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmVjdG9ycyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gZXF1YWxzKGEsIGIpIHtcbiAgdmFyIGEwID0gYVswXVxuICB2YXIgYTEgPSBhWzFdXG4gIHZhciBiMCA9IGJbMF1cbiAgdmFyIGIxID0gYlsxXVxuICByZXR1cm4gKE1hdGguYWJzKGEwIC0gYjApIDw9IEVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEwKSwgTWF0aC5hYnMoYjApKSAmJlxuICAgICAgICAgIE1hdGguYWJzKGExIC0gYjEpIDw9IEVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExKSwgTWF0aC5hYnMoYjEpKSlcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gZXhhY3RFcXVhbHNcblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSB2ZWN0b3JzIGV4YWN0bHkgaGF2ZSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbiAod2hlbiBjb21wYXJlZCB3aXRoID09PSlcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgVGhlIGZpcnN0IHZlY3Rvci5cbiAqIEBwYXJhbSB7dmVjMn0gYiBUaGUgc2Vjb25kIHZlY3Rvci5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSB2ZWN0b3JzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBleGFjdEVxdWFscyhhLCBiKSB7XG4gIHJldHVybiBhWzBdID09PSBiWzBdICYmIGFbMV0gPT09IGJbMV1cbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gYWRkXG5cbi8qKlxuICogQWRkcyB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5mdW5jdGlvbiBhZGQob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSArIGJbMF1cbiAgICBvdXRbMV0gPSBhWzFdICsgYlsxXVxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vc3VidHJhY3QnKVxuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL211bHRpcGx5JylcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9kaXZpZGUnKVxuIiwibW9kdWxlLmV4cG9ydHMgPSBpbnZlcnNlXG5cbi8qKlxuICogUmV0dXJucyB0aGUgaW52ZXJzZSBvZiB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHZlY3RvciB0byBpbnZlcnRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZnVuY3Rpb24gaW52ZXJzZShvdXQsIGEpIHtcbiAgb3V0WzBdID0gMS4wIC8gYVswXVxuICBvdXRbMV0gPSAxLjAgLyBhWzFdXG4gIHJldHVybiBvdXRcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gbWluXG5cbi8qKlxuICogUmV0dXJucyB0aGUgbWluaW11bSBvZiB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5mdW5jdGlvbiBtaW4ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gTWF0aC5taW4oYVswXSwgYlswXSlcbiAgICBvdXRbMV0gPSBNYXRoLm1pbihhWzFdLCBiWzFdKVxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IG1heFxuXG4vKipcbiAqIFJldHVybnMgdGhlIG1heGltdW0gb2YgdHdvIHZlYzInc1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZnVuY3Rpb24gbWF4KG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IE1hdGgubWF4KGFbMF0sIGJbMF0pXG4gICAgb3V0WzFdID0gTWF0aC5tYXgoYVsxXSwgYlsxXSlcbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSByb3RhdGVcblxuLyoqXG4gKiBSb3RhdGVzIGEgdmVjMiBieSBhbiBhbmdsZVxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIHZlY3RvciB0byByb3RhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBhbmdsZSB0aGUgYW5nbGUgb2Ygcm90YXRpb24gKGluIHJhZGlhbnMpXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmZ1bmN0aW9uIHJvdGF0ZShvdXQsIGEsIGFuZ2xlKSB7XG4gIHZhciBjID0gTWF0aC5jb3MoYW5nbGUpLFxuICAgICAgcyA9IE1hdGguc2luKGFuZ2xlKVxuICB2YXIgeCA9IGFbMF0sXG4gICAgICB5ID0gYVsxXVxuXG4gIG91dFswXSA9IHggKiBjIC0geSAqIHNcbiAgb3V0WzFdID0geCAqIHMgKyB5ICogY1xuXG4gIHJldHVybiBvdXRcbn1cblxuIiwibW9kdWxlLmV4cG9ydHMgPSBmbG9vclxuXG4vKipcbiAqIE1hdGguZmxvb3IgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB2ZWN0b3IgdG8gZmxvb3JcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZnVuY3Rpb24gZmxvb3Iob3V0LCBhKSB7XG4gIG91dFswXSA9IE1hdGguZmxvb3IoYVswXSlcbiAgb3V0WzFdID0gTWF0aC5mbG9vcihhWzFdKVxuICByZXR1cm4gb3V0XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGNlaWxcblxuLyoqXG4gKiBNYXRoLmNlaWwgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB2ZWN0b3IgdG8gY2VpbFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5mdW5jdGlvbiBjZWlsKG91dCwgYSkge1xuICBvdXRbMF0gPSBNYXRoLmNlaWwoYVswXSlcbiAgb3V0WzFdID0gTWF0aC5jZWlsKGFbMV0pXG4gIHJldHVybiBvdXRcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gcm91bmRcblxuLyoqXG4gKiBNYXRoLnJvdW5kIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjMlxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdmVjdG9yIHRvIHJvdW5kXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmZ1bmN0aW9uIHJvdW5kKG91dCwgYSkge1xuICBvdXRbMF0gPSBNYXRoLnJvdW5kKGFbMF0pXG4gIG91dFsxXSA9IE1hdGgucm91bmQoYVsxXSlcbiAgcmV0dXJuIG91dFxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBzY2FsZVxuXG4vKipcbiAqIFNjYWxlcyBhIHZlYzIgYnkgYSBzY2FsYXIgbnVtYmVyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgdmVjdG9yIHRvIHNjYWxlXG4gKiBAcGFyYW0ge051bWJlcn0gYiBhbW91bnQgdG8gc2NhbGUgdGhlIHZlY3RvciBieVxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5mdW5jdGlvbiBzY2FsZShvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdICogYlxuICAgIG91dFsxXSA9IGFbMV0gKiBiXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gc2NhbGVBbmRBZGRcblxuLyoqXG4gKiBBZGRzIHR3byB2ZWMyJ3MgYWZ0ZXIgc2NhbGluZyB0aGUgc2Vjb25kIG9wZXJhbmQgYnkgYSBzY2FsYXIgdmFsdWVcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gc2NhbGUgdGhlIGFtb3VudCB0byBzY2FsZSBiIGJ5IGJlZm9yZSBhZGRpbmdcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZnVuY3Rpb24gc2NhbGVBbmRBZGQob3V0LCBhLCBiLCBzY2FsZSkge1xuICAgIG91dFswXSA9IGFbMF0gKyAoYlswXSAqIHNjYWxlKVxuICAgIG91dFsxXSA9IGFbMV0gKyAoYlsxXSAqIHNjYWxlKVxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGlzdGFuY2UnKVxuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3NxdWFyZWREaXN0YW5jZScpXG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGVuZ3RoJylcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9zcXVhcmVkTGVuZ3RoJylcbiIsIm1vZHVsZS5leHBvcnRzID0gbmVnYXRlXG5cbi8qKlxuICogTmVnYXRlcyB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHZlY3RvciB0byBuZWdhdGVcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZnVuY3Rpb24gbmVnYXRlKG91dCwgYSkge1xuICAgIG91dFswXSA9IC1hWzBdXG4gICAgb3V0WzFdID0gLWFbMV1cbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSBub3JtYWxpemVcblxuLyoqXG4gKiBOb3JtYWxpemUgYSB2ZWMyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB2ZWN0b3IgdG8gbm9ybWFsaXplXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZShvdXQsIGEpIHtcbiAgICB2YXIgeCA9IGFbMF0sXG4gICAgICAgIHkgPSBhWzFdXG4gICAgdmFyIGxlbiA9IHgqeCArIHkqeVxuICAgIGlmIChsZW4gPiAwKSB7XG4gICAgICAgIC8vVE9ETzogZXZhbHVhdGUgdXNlIG9mIGdsbV9pbnZzcXJ0IGhlcmU/XG4gICAgICAgIGxlbiA9IDEgLyBNYXRoLnNxcnQobGVuKVxuICAgICAgICBvdXRbMF0gPSBhWzBdICogbGVuXG4gICAgICAgIG91dFsxXSA9IGFbMV0gKiBsZW5cbiAgICB9XG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gZG90XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZG90IHByb2R1Y3Qgb2YgdHdvIHZlYzInc1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gZG90IHByb2R1Y3Qgb2YgYSBhbmQgYlxuICovXG5mdW5jdGlvbiBkb3QoYSwgYikge1xuICAgIHJldHVybiBhWzBdICogYlswXSArIGFbMV0gKiBiWzFdXG59IiwibW9kdWxlLmV4cG9ydHMgPSBjcm9zc1xuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBjcm9zcyBwcm9kdWN0IG9mIHR3byB2ZWMyJ3NcbiAqIE5vdGUgdGhhdCB0aGUgY3Jvc3MgcHJvZHVjdCBtdXN0IGJ5IGRlZmluaXRpb24gcHJvZHVjZSBhIDNEIHZlY3RvclxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZnVuY3Rpb24gY3Jvc3Mob3V0LCBhLCBiKSB7XG4gICAgdmFyIHogPSBhWzBdICogYlsxXSAtIGFbMV0gKiBiWzBdXG4gICAgb3V0WzBdID0gb3V0WzFdID0gMFxuICAgIG91dFsyXSA9IHpcbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSBsZXJwXG5cbi8qKlxuICogUGVyZm9ybXMgYSBsaW5lYXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gdCBpbnRlcnBvbGF0aW9uIGFtb3VudCBiZXR3ZWVuIHRoZSB0d28gaW5wdXRzXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmZ1bmN0aW9uIGxlcnAob3V0LCBhLCBiLCB0KSB7XG4gICAgdmFyIGF4ID0gYVswXSxcbiAgICAgICAgYXkgPSBhWzFdXG4gICAgb3V0WzBdID0gYXggKyB0ICogKGJbMF0gLSBheClcbiAgICBvdXRbMV0gPSBheSArIHQgKiAoYlsxXSAtIGF5KVxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IHJhbmRvbVxuXG4vKipcbiAqIEdlbmVyYXRlcyBhIHJhbmRvbSB2ZWN0b3Igd2l0aCB0aGUgZ2l2ZW4gc2NhbGVcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtOdW1iZXJ9IFtzY2FsZV0gTGVuZ3RoIG9mIHRoZSByZXN1bHRpbmcgdmVjdG9yLiBJZiBvbW1pdHRlZCwgYSB1bml0IHZlY3RvciB3aWxsIGJlIHJldHVybmVkXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmZ1bmN0aW9uIHJhbmRvbShvdXQsIHNjYWxlKSB7XG4gICAgc2NhbGUgPSBzY2FsZSB8fCAxLjBcbiAgICB2YXIgciA9IE1hdGgucmFuZG9tKCkgKiAyLjAgKiBNYXRoLlBJXG4gICAgb3V0WzBdID0gTWF0aC5jb3MocikgKiBzY2FsZVxuICAgIG91dFsxXSA9IE1hdGguc2luKHIpICogc2NhbGVcbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSB0cmFuc2Zvcm1NYXQyXG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjMiB3aXRoIGEgbWF0MlxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7bWF0Mn0gbSBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZnVuY3Rpb24gdHJhbnNmb3JtTWF0MihvdXQsIGEsIG0pIHtcbiAgICB2YXIgeCA9IGFbMF0sXG4gICAgICAgIHkgPSBhWzFdXG4gICAgb3V0WzBdID0gbVswXSAqIHggKyBtWzJdICogeVxuICAgIG91dFsxXSA9IG1bMV0gKiB4ICsgbVszXSAqIHlcbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSB0cmFuc2Zvcm1NYXQyZFxuXG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzIgd2l0aCBhIG1hdDJkXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHttYXQyZH0gbSBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZnVuY3Rpb24gdHJhbnNmb3JtTWF0MmQob3V0LCBhLCBtKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXVxuICAgIG91dFswXSA9IG1bMF0gKiB4ICsgbVsyXSAqIHkgKyBtWzRdXG4gICAgb3V0WzFdID0gbVsxXSAqIHggKyBtWzNdICogeSArIG1bNV1cbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSB0cmFuc2Zvcm1NYXQzXG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjMiB3aXRoIGEgbWF0M1xuICogM3JkIHZlY3RvciBjb21wb25lbnQgaXMgaW1wbGljaXRseSAnMSdcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge21hdDN9IG0gbWF0cml4IHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmZ1bmN0aW9uIHRyYW5zZm9ybU1hdDMob3V0LCBhLCBtKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXVxuICAgIG91dFswXSA9IG1bMF0gKiB4ICsgbVszXSAqIHkgKyBtWzZdXG4gICAgb3V0WzFdID0gbVsxXSAqIHggKyBtWzRdICogeSArIG1bN11cbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSB0cmFuc2Zvcm1NYXQ0XG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjMiB3aXRoIGEgbWF0NFxuICogM3JkIHZlY3RvciBjb21wb25lbnQgaXMgaW1wbGljaXRseSAnMCdcbiAqIDR0aCB2ZWN0b3IgY29tcG9uZW50IGlzIGltcGxpY2l0bHkgJzEnXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHttYXQ0fSBtIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5mdW5jdGlvbiB0cmFuc2Zvcm1NYXQ0KG91dCwgYSwgbSkge1xuICAgIHZhciB4ID0gYVswXSwgXG4gICAgICAgIHkgPSBhWzFdXG4gICAgb3V0WzBdID0gbVswXSAqIHggKyBtWzRdICogeSArIG1bMTJdXG4gICAgb3V0WzFdID0gbVsxXSAqIHggKyBtWzVdICogeSArIG1bMTNdXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gZm9yRWFjaFxuXG52YXIgdmVjID0gcmVxdWlyZSgnLi9jcmVhdGUnKSgpXG5cbi8qKlxuICogUGVyZm9ybSBzb21lIG9wZXJhdGlvbiBvdmVyIGFuIGFycmF5IG9mIHZlYzJzLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGEgdGhlIGFycmF5IG9mIHZlY3RvcnMgdG8gaXRlcmF0ZSBvdmVyXG4gKiBAcGFyYW0ge051bWJlcn0gc3RyaWRlIE51bWJlciBvZiBlbGVtZW50cyBiZXR3ZWVuIHRoZSBzdGFydCBvZiBlYWNoIHZlYzIuIElmIDAgYXNzdW1lcyB0aWdodGx5IHBhY2tlZFxuICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldCBOdW1iZXIgb2YgZWxlbWVudHMgdG8gc2tpcCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBhcnJheVxuICogQHBhcmFtIHtOdW1iZXJ9IGNvdW50IE51bWJlciBvZiB2ZWMycyB0byBpdGVyYXRlIG92ZXIuIElmIDAgaXRlcmF0ZXMgb3ZlciBlbnRpcmUgYXJyYXlcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIEZ1bmN0aW9uIHRvIGNhbGwgZm9yIGVhY2ggdmVjdG9yIGluIHRoZSBhcnJheVxuICogQHBhcmFtIHtPYmplY3R9IFthcmddIGFkZGl0aW9uYWwgYXJndW1lbnQgdG8gcGFzcyB0byBmblxuICogQHJldHVybnMge0FycmF5fSBhXG4gKiBAZnVuY3Rpb25cbiAqL1xuZnVuY3Rpb24gZm9yRWFjaChhLCBzdHJpZGUsIG9mZnNldCwgY291bnQsIGZuLCBhcmcpIHtcbiAgICB2YXIgaSwgbFxuICAgIGlmKCFzdHJpZGUpIHtcbiAgICAgICAgc3RyaWRlID0gMlxuICAgIH1cblxuICAgIGlmKCFvZmZzZXQpIHtcbiAgICAgICAgb2Zmc2V0ID0gMFxuICAgIH1cbiAgICBcbiAgICBpZihjb3VudCkge1xuICAgICAgICBsID0gTWF0aC5taW4oKGNvdW50ICogc3RyaWRlKSArIG9mZnNldCwgYS5sZW5ndGgpXG4gICAgfSBlbHNlIHtcbiAgICAgICAgbCA9IGEubGVuZ3RoXG4gICAgfVxuXG4gICAgZm9yKGkgPSBvZmZzZXQ7IGkgPCBsOyBpICs9IHN0cmlkZSkge1xuICAgICAgICB2ZWNbMF0gPSBhW2ldXG4gICAgICAgIHZlY1sxXSA9IGFbaSsxXVxuICAgICAgICBmbih2ZWMsIHZlYywgYXJnKVxuICAgICAgICBhW2ldID0gdmVjWzBdXG4gICAgICAgIGFbaSsxXSA9IHZlY1sxXVxuICAgIH1cbiAgICBcbiAgICByZXR1cm4gYVxufSIsIm1vZHVsZS5leHBvcnRzID0gbGltaXQ7XG5cbi8qKlxuICogTGltaXQgdGhlIG1hZ25pdHVkZSBvZiB0aGlzIHZlY3RvciB0byB0aGUgdmFsdWUgdXNlZCBmb3IgdGhlIGBtYXhgXG4gKiBwYXJhbWV0ZXIuXG4gKlxuICogQHBhcmFtICB7dmVjMn0gdGhlIHZlY3RvciB0byBsaW1pdFxuICogQHBhcmFtICB7TnVtYmVyfSBtYXggdGhlIG1heGltdW0gbWFnbml0dWRlIGZvciB0aGUgdmVjdG9yXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmZ1bmN0aW9uIGxpbWl0KG91dCwgYSwgbWF4KSB7XG4gIHZhciBtU3EgPSBhWzBdICogYVswXSArIGFbMV0gKiBhWzFdO1xuXG4gIGlmIChtU3EgPiBtYXggKiBtYXgpIHtcbiAgICB2YXIgbiA9IE1hdGguc3FydChtU3EpO1xuICAgIG91dFswXSA9IGFbMF0gLyBuICogbWF4O1xuICAgIG91dFsxXSA9IGFbMV0gLyBuICogbWF4O1xuICB9IGVsc2Uge1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsxXTtcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGNsb25lO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgdmVjMyBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIHZlY3RvclxuICpcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gY2xvbmVcbiAqIEByZXR1cm5zIHt2ZWMzfSBhIG5ldyAzRCB2ZWN0b3JcbiAqL1xuZnVuY3Rpb24gY2xvbmUoYSkge1xuICAgIHZhciBvdXQgPSBuZXcgRmxvYXQzMkFycmF5KDMpXG4gICAgb3V0WzBdID0gYVswXVxuICAgIG91dFsxXSA9IGFbMV1cbiAgICBvdXRbMl0gPSBhWzJdXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gYW5nbGVcblxudmFyIGZyb21WYWx1ZXMgPSByZXF1aXJlKCcuL2Zyb21WYWx1ZXMnKVxudmFyIG5vcm1hbGl6ZSA9IHJlcXVpcmUoJy4vbm9ybWFsaXplJylcbnZhciBkb3QgPSByZXF1aXJlKCcuL2RvdCcpXG5cbi8qKlxuICogR2V0IHRoZSBhbmdsZSBiZXR3ZWVuIHR3byAzRCB2ZWN0b3JzXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiBUaGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBhbmdsZSBpbiByYWRpYW5zXG4gKi9cbmZ1bmN0aW9uIGFuZ2xlKGEsIGIpIHtcbiAgICB2YXIgdGVtcEEgPSBmcm9tVmFsdWVzKGFbMF0sIGFbMV0sIGFbMl0pXG4gICAgdmFyIHRlbXBCID0gZnJvbVZhbHVlcyhiWzBdLCBiWzFdLCBiWzJdKVxuIFxuICAgIG5vcm1hbGl6ZSh0ZW1wQSwgdGVtcEEpXG4gICAgbm9ybWFsaXplKHRlbXBCLCB0ZW1wQilcbiBcbiAgICB2YXIgY29zaW5lID0gZG90KHRlbXBBLCB0ZW1wQilcblxuICAgIGlmKGNvc2luZSA+IDEuMCl7XG4gICAgICAgIHJldHVybiAwXG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIE1hdGguYWNvcyhjb3NpbmUpXG4gICAgfSAgICAgXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGNvcHk7XG5cbi8qKlxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIHZlYzMgdG8gYW5vdGhlclxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIHNvdXJjZSB2ZWN0b3JcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZnVuY3Rpb24gY29weShvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSBhWzBdXG4gICAgb3V0WzFdID0gYVsxXVxuICAgIG91dFsyXSA9IGFbMl1cbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSBzZXQ7XG5cbi8qKlxuICogU2V0IHRoZSBjb21wb25lbnRzIG9mIGEgdmVjMyB0byB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHogWiBjb21wb25lbnRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZnVuY3Rpb24gc2V0KG91dCwgeCwgeSwgeikge1xuICAgIG91dFswXSA9IHhcbiAgICBvdXRbMV0gPSB5XG4gICAgb3V0WzJdID0gelxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IGVxdWFsc1xuXG52YXIgRVBTSUxPTiA9IHJlcXVpcmUoJy4vZXBzaWxvbicpXG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgdmVjdG9ycyBoYXZlIGFwcHJveGltYXRlbHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24uXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSBmaXJzdCB2ZWN0b3IuXG4gKiBAcGFyYW0ge3ZlYzN9IGIgVGhlIHNlY29uZCB2ZWN0b3IuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmVjdG9ycyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gZXF1YWxzKGEsIGIpIHtcbiAgdmFyIGEwID0gYVswXVxuICB2YXIgYTEgPSBhWzFdXG4gIHZhciBhMiA9IGFbMl1cbiAgdmFyIGIwID0gYlswXVxuICB2YXIgYjEgPSBiWzFdXG4gIHZhciBiMiA9IGJbMl1cbiAgcmV0dXJuIChNYXRoLmFicyhhMCAtIGIwKSA8PSBFUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMCksIE1hdGguYWJzKGIwKSkgJiZcbiAgICAgICAgICBNYXRoLmFicyhhMSAtIGIxKSA8PSBFUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMSksIE1hdGguYWJzKGIxKSkgJiZcbiAgICAgICAgICBNYXRoLmFicyhhMiAtIGIyKSA8PSBFUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMiksIE1hdGguYWJzKGIyKSkpXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGV4YWN0RXF1YWxzXG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgdmVjdG9ycyBleGFjdGx5IGhhdmUgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24gKHdoZW4gY29tcGFyZWQgd2l0aCA9PT0pXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSBmaXJzdCB2ZWN0b3IuXG4gKiBAcGFyYW0ge3ZlYzN9IGIgVGhlIHNlY29uZCB2ZWN0b3IuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmVjdG9ycyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gZXhhY3RFcXVhbHMoYSwgYikge1xuICByZXR1cm4gYVswXSA9PT0gYlswXSAmJiBhWzFdID09PSBiWzFdICYmIGFbMl0gPT09IGJbMl1cbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gYWRkO1xuXG4vKipcbiAqIEFkZHMgdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZnVuY3Rpb24gYWRkKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gKyBiWzBdXG4gICAgb3V0WzFdID0gYVsxXSArIGJbMV1cbiAgICBvdXRbMl0gPSBhWzJdICsgYlsyXVxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vc3VidHJhY3QnKVxuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL211bHRpcGx5JylcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9kaXZpZGUnKVxuIiwibW9kdWxlLmV4cG9ydHMgPSBtaW47XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbWluaW11bSBvZiB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5mdW5jdGlvbiBtaW4ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gTWF0aC5taW4oYVswXSwgYlswXSlcbiAgICBvdXRbMV0gPSBNYXRoLm1pbihhWzFdLCBiWzFdKVxuICAgIG91dFsyXSA9IE1hdGgubWluKGFbMl0sIGJbMl0pXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gbWF4O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG1heGltdW0gb2YgdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZnVuY3Rpb24gbWF4KG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IE1hdGgubWF4KGFbMF0sIGJbMF0pXG4gICAgb3V0WzFdID0gTWF0aC5tYXgoYVsxXSwgYlsxXSlcbiAgICBvdXRbMl0gPSBNYXRoLm1heChhWzJdLCBiWzJdKVxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IGZsb29yXG5cbi8qKlxuICogTWF0aC5mbG9vciB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHZlY3RvciB0byBmbG9vclxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5mdW5jdGlvbiBmbG9vcihvdXQsIGEpIHtcbiAgb3V0WzBdID0gTWF0aC5mbG9vcihhWzBdKVxuICBvdXRbMV0gPSBNYXRoLmZsb29yKGFbMV0pXG4gIG91dFsyXSA9IE1hdGguZmxvb3IoYVsyXSlcbiAgcmV0dXJuIG91dFxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBjZWlsXG5cbi8qKlxuICogTWF0aC5jZWlsIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjM1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdmVjdG9yIHRvIGNlaWxcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZnVuY3Rpb24gY2VpbChvdXQsIGEpIHtcbiAgb3V0WzBdID0gTWF0aC5jZWlsKGFbMF0pXG4gIG91dFsxXSA9IE1hdGguY2VpbChhWzFdKVxuICBvdXRbMl0gPSBNYXRoLmNlaWwoYVsyXSlcbiAgcmV0dXJuIG91dFxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSByb3VuZFxuXG4vKipcbiAqIE1hdGgucm91bmQgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gcm91bmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZnVuY3Rpb24gcm91bmQob3V0LCBhKSB7XG4gIG91dFswXSA9IE1hdGgucm91bmQoYVswXSlcbiAgb3V0WzFdID0gTWF0aC5yb3VuZChhWzFdKVxuICBvdXRbMl0gPSBNYXRoLnJvdW5kKGFbMl0pXG4gIHJldHVybiBvdXRcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gc2NhbGU7XG5cbi8qKlxuICogU2NhbGVzIGEgdmVjMyBieSBhIHNjYWxhciBudW1iZXJcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSB2ZWN0b3IgdG8gc2NhbGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBiIGFtb3VudCB0byBzY2FsZSB0aGUgdmVjdG9yIGJ5XG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmZ1bmN0aW9uIHNjYWxlKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gKiBiXG4gICAgb3V0WzFdID0gYVsxXSAqIGJcbiAgICBvdXRbMl0gPSBhWzJdICogYlxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IHNjYWxlQW5kQWRkO1xuXG4vKipcbiAqIEFkZHMgdHdvIHZlYzMncyBhZnRlciBzY2FsaW5nIHRoZSBzZWNvbmQgb3BlcmFuZCBieSBhIHNjYWxhciB2YWx1ZVxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZSB0aGUgYW1vdW50IHRvIHNjYWxlIGIgYnkgYmVmb3JlIGFkZGluZ1xuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5mdW5jdGlvbiBzY2FsZUFuZEFkZChvdXQsIGEsIGIsIHNjYWxlKSB7XG4gICAgb3V0WzBdID0gYVswXSArIChiWzBdICogc2NhbGUpXG4gICAgb3V0WzFdID0gYVsxXSArIChiWzFdICogc2NhbGUpXG4gICAgb3V0WzJdID0gYVsyXSArIChiWzJdICogc2NhbGUpXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9kaXN0YW5jZScpXG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vc3F1YXJlZERpc3RhbmNlJylcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9sZW5ndGgnKVxuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3NxdWFyZWRMZW5ndGgnKVxuIiwibW9kdWxlLmV4cG9ydHMgPSBuZWdhdGU7XG5cbi8qKlxuICogTmVnYXRlcyB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHZlY3RvciB0byBuZWdhdGVcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZnVuY3Rpb24gbmVnYXRlKG91dCwgYSkge1xuICAgIG91dFswXSA9IC1hWzBdXG4gICAgb3V0WzFdID0gLWFbMV1cbiAgICBvdXRbMl0gPSAtYVsyXVxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IGludmVyc2U7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgaW52ZXJzZSBvZiB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHZlY3RvciB0byBpbnZlcnRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZnVuY3Rpb24gaW52ZXJzZShvdXQsIGEpIHtcbiAgb3V0WzBdID0gMS4wIC8gYVswXVxuICBvdXRbMV0gPSAxLjAgLyBhWzFdXG4gIG91dFsyXSA9IDEuMCAvIGFbMl1cbiAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gY3Jvc3M7XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIGNyb3NzIHByb2R1Y3Qgb2YgdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZnVuY3Rpb24gY3Jvc3Mob3V0LCBhLCBiKSB7XG4gICAgdmFyIGF4ID0gYVswXSwgYXkgPSBhWzFdLCBheiA9IGFbMl0sXG4gICAgICAgIGJ4ID0gYlswXSwgYnkgPSBiWzFdLCBieiA9IGJbMl1cblxuICAgIG91dFswXSA9IGF5ICogYnogLSBheiAqIGJ5XG4gICAgb3V0WzFdID0gYXogKiBieCAtIGF4ICogYnpcbiAgICBvdXRbMl0gPSBheCAqIGJ5IC0gYXkgKiBieFxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IGxlcnA7XG5cbi8qKlxuICogUGVyZm9ybXMgYSBsaW5lYXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gdCBpbnRlcnBvbGF0aW9uIGFtb3VudCBiZXR3ZWVuIHRoZSB0d28gaW5wdXRzXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmZ1bmN0aW9uIGxlcnAob3V0LCBhLCBiLCB0KSB7XG4gICAgdmFyIGF4ID0gYVswXSxcbiAgICAgICAgYXkgPSBhWzFdLFxuICAgICAgICBheiA9IGFbMl1cbiAgICBvdXRbMF0gPSBheCArIHQgKiAoYlswXSAtIGF4KVxuICAgIG91dFsxXSA9IGF5ICsgdCAqIChiWzFdIC0gYXkpXG4gICAgb3V0WzJdID0gYXogKyB0ICogKGJbMl0gLSBheilcbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSByYW5kb207XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgcmFuZG9tIHZlY3RvciB3aXRoIHRoZSBnaXZlbiBzY2FsZVxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge051bWJlcn0gW3NjYWxlXSBMZW5ndGggb2YgdGhlIHJlc3VsdGluZyB2ZWN0b3IuIElmIG9tbWl0dGVkLCBhIHVuaXQgdmVjdG9yIHdpbGwgYmUgcmV0dXJuZWRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZnVuY3Rpb24gcmFuZG9tKG91dCwgc2NhbGUpIHtcbiAgICBzY2FsZSA9IHNjYWxlIHx8IDEuMFxuXG4gICAgdmFyIHIgPSBNYXRoLnJhbmRvbSgpICogMi4wICogTWF0aC5QSVxuICAgIHZhciB6ID0gKE1hdGgucmFuZG9tKCkgKiAyLjApIC0gMS4wXG4gICAgdmFyIHpTY2FsZSA9IE1hdGguc3FydCgxLjAteip6KSAqIHNjYWxlXG5cbiAgICBvdXRbMF0gPSBNYXRoLmNvcyhyKSAqIHpTY2FsZVxuICAgIG91dFsxXSA9IE1hdGguc2luKHIpICogelNjYWxlXG4gICAgb3V0WzJdID0geiAqIHNjYWxlXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gdHJhbnNmb3JtTWF0NDtcblxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMzIHdpdGggYSBtYXQ0LlxuICogNHRoIHZlY3RvciBjb21wb25lbnQgaXMgaW1wbGljaXRseSAnMSdcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge21hdDR9IG0gbWF0cml4IHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmZ1bmN0aW9uIHRyYW5zZm9ybU1hdDQob3V0LCBhLCBtKSB7XG4gICAgdmFyIHggPSBhWzBdLCB5ID0gYVsxXSwgeiA9IGFbMl0sXG4gICAgICAgIHcgPSBtWzNdICogeCArIG1bN10gKiB5ICsgbVsxMV0gKiB6ICsgbVsxNV1cbiAgICB3ID0gdyB8fCAxLjBcbiAgICBvdXRbMF0gPSAobVswXSAqIHggKyBtWzRdICogeSArIG1bOF0gKiB6ICsgbVsxMl0pIC8gd1xuICAgIG91dFsxXSA9IChtWzFdICogeCArIG1bNV0gKiB5ICsgbVs5XSAqIHogKyBtWzEzXSkgLyB3XG4gICAgb3V0WzJdID0gKG1bMl0gKiB4ICsgbVs2XSAqIHkgKyBtWzEwXSAqIHogKyBtWzE0XSkgLyB3XG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gdHJhbnNmb3JtTWF0MztcblxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMzIHdpdGggYSBtYXQzLlxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7bWF0NH0gbSB0aGUgM3gzIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5mdW5jdGlvbiB0cmFuc2Zvcm1NYXQzKG91dCwgYSwgbSkge1xuICAgIHZhciB4ID0gYVswXSwgeSA9IGFbMV0sIHogPSBhWzJdXG4gICAgb3V0WzBdID0geCAqIG1bMF0gKyB5ICogbVszXSArIHogKiBtWzZdXG4gICAgb3V0WzFdID0geCAqIG1bMV0gKyB5ICogbVs0XSArIHogKiBtWzddXG4gICAgb3V0WzJdID0geCAqIG1bMl0gKyB5ICogbVs1XSArIHogKiBtWzhdXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gdHJhbnNmb3JtUXVhdDtcblxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMzIHdpdGggYSBxdWF0XG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHtxdWF0fSBxIHF1YXRlcm5pb24gdG8gdHJhbnNmb3JtIHdpdGhcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZnVuY3Rpb24gdHJhbnNmb3JtUXVhdChvdXQsIGEsIHEpIHtcbiAgICAvLyBiZW5jaG1hcmtzOiBodHRwOi8vanNwZXJmLmNvbS9xdWF0ZXJuaW9uLXRyYW5zZm9ybS12ZWMzLWltcGxlbWVudGF0aW9uc1xuXG4gICAgdmFyIHggPSBhWzBdLCB5ID0gYVsxXSwgeiA9IGFbMl0sXG4gICAgICAgIHF4ID0gcVswXSwgcXkgPSBxWzFdLCBxeiA9IHFbMl0sIHF3ID0gcVszXSxcblxuICAgICAgICAvLyBjYWxjdWxhdGUgcXVhdCAqIHZlY1xuICAgICAgICBpeCA9IHF3ICogeCArIHF5ICogeiAtIHF6ICogeSxcbiAgICAgICAgaXkgPSBxdyAqIHkgKyBxeiAqIHggLSBxeCAqIHosXG4gICAgICAgIGl6ID0gcXcgKiB6ICsgcXggKiB5IC0gcXkgKiB4LFxuICAgICAgICBpdyA9IC1xeCAqIHggLSBxeSAqIHkgLSBxeiAqIHpcblxuICAgIC8vIGNhbGN1bGF0ZSByZXN1bHQgKiBpbnZlcnNlIHF1YXRcbiAgICBvdXRbMF0gPSBpeCAqIHF3ICsgaXcgKiAtcXggKyBpeSAqIC1xeiAtIGl6ICogLXF5XG4gICAgb3V0WzFdID0gaXkgKiBxdyArIGl3ICogLXF5ICsgaXogKiAtcXggLSBpeCAqIC1xelxuICAgIG91dFsyXSA9IGl6ICogcXcgKyBpdyAqIC1xeiArIGl4ICogLXF5IC0gaXkgKiAtcXhcbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSByb3RhdGVYO1xuXG4vKipcbiAqIFJvdGF0ZSBhIDNEIHZlY3RvciBhcm91bmQgdGhlIHgtYXhpc1xuICogQHBhcmFtIHt2ZWMzfSBvdXQgVGhlIHJlY2VpdmluZyB2ZWMzXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVGhlIHZlYzMgcG9pbnQgdG8gcm90YXRlXG4gKiBAcGFyYW0ge3ZlYzN9IGIgVGhlIG9yaWdpbiBvZiB0aGUgcm90YXRpb25cbiAqIEBwYXJhbSB7TnVtYmVyfSBjIFRoZSBhbmdsZSBvZiByb3RhdGlvblxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5mdW5jdGlvbiByb3RhdGVYKG91dCwgYSwgYiwgYyl7XG4gICAgdmFyIGJ5ID0gYlsxXVxuICAgIHZhciBieiA9IGJbMl1cblxuICAgIC8vIFRyYW5zbGF0ZSBwb2ludCB0byB0aGUgb3JpZ2luXG4gICAgdmFyIHB5ID0gYVsxXSAtIGJ5XG4gICAgdmFyIHB6ID0gYVsyXSAtIGJ6XG5cbiAgICB2YXIgc2MgPSBNYXRoLnNpbihjKVxuICAgIHZhciBjYyA9IE1hdGguY29zKGMpXG5cbiAgICAvLyBwZXJmb3JtIHJvdGF0aW9uIGFuZCB0cmFuc2xhdGUgdG8gY29ycmVjdCBwb3NpdGlvblxuICAgIG91dFswXSA9IGFbMF1cbiAgICBvdXRbMV0gPSBieSArIHB5ICogY2MgLSBweiAqIHNjXG4gICAgb3V0WzJdID0gYnogKyBweSAqIHNjICsgcHogKiBjY1xuXG4gICAgcmV0dXJuIG91dFxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSByb3RhdGVZO1xuXG4vKipcbiAqIFJvdGF0ZSBhIDNEIHZlY3RvciBhcm91bmQgdGhlIHktYXhpc1xuICogQHBhcmFtIHt2ZWMzfSBvdXQgVGhlIHJlY2VpdmluZyB2ZWMzXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVGhlIHZlYzMgcG9pbnQgdG8gcm90YXRlXG4gKiBAcGFyYW0ge3ZlYzN9IGIgVGhlIG9yaWdpbiBvZiB0aGUgcm90YXRpb25cbiAqIEBwYXJhbSB7TnVtYmVyfSBjIFRoZSBhbmdsZSBvZiByb3RhdGlvblxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5mdW5jdGlvbiByb3RhdGVZKG91dCwgYSwgYiwgYyl7XG4gICAgdmFyIGJ4ID0gYlswXVxuICAgIHZhciBieiA9IGJbMl1cblxuICAgIC8vIHRyYW5zbGF0ZSBwb2ludCB0byB0aGUgb3JpZ2luXG4gICAgdmFyIHB4ID0gYVswXSAtIGJ4XG4gICAgdmFyIHB6ID0gYVsyXSAtIGJ6XG4gICAgXG4gICAgdmFyIHNjID0gTWF0aC5zaW4oYylcbiAgICB2YXIgY2MgPSBNYXRoLmNvcyhjKVxuICBcbiAgICAvLyBwZXJmb3JtIHJvdGF0aW9uIGFuZCB0cmFuc2xhdGUgdG8gY29ycmVjdCBwb3NpdGlvblxuICAgIG91dFswXSA9IGJ4ICsgcHogKiBzYyArIHB4ICogY2NcbiAgICBvdXRbMV0gPSBhWzFdXG4gICAgb3V0WzJdID0gYnogKyBweiAqIGNjIC0gcHggKiBzY1xuICBcbiAgICByZXR1cm4gb3V0XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJvdGF0ZVo7XG5cbi8qKlxuICogUm90YXRlIGEgM0QgdmVjdG9yIGFyb3VuZCB0aGUgei1heGlzXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCBUaGUgcmVjZWl2aW5nIHZlYzNcbiAqIEBwYXJhbSB7dmVjM30gYSBUaGUgdmVjMyBwb2ludCB0byByb3RhdGVcbiAqIEBwYXJhbSB7dmVjM30gYiBUaGUgb3JpZ2luIG9mIHRoZSByb3RhdGlvblxuICogQHBhcmFtIHtOdW1iZXJ9IGMgVGhlIGFuZ2xlIG9mIHJvdGF0aW9uXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmZ1bmN0aW9uIHJvdGF0ZVoob3V0LCBhLCBiLCBjKXtcbiAgICB2YXIgYnggPSBiWzBdXG4gICAgdmFyIGJ5ID0gYlsxXVxuXG4gICAgLy9UcmFuc2xhdGUgcG9pbnQgdG8gdGhlIG9yaWdpblxuICAgIHZhciBweCA9IGFbMF0gLSBieFxuICAgIHZhciBweSA9IGFbMV0gLSBieVxuICBcbiAgICB2YXIgc2MgPSBNYXRoLnNpbihjKVxuICAgIHZhciBjYyA9IE1hdGguY29zKGMpXG5cbiAgICAvLyBwZXJmb3JtIHJvdGF0aW9uIGFuZCB0cmFuc2xhdGUgdG8gY29ycmVjdCBwb3NpdGlvblxuICAgIG91dFswXSA9IGJ4ICsgcHggKiBjYyAtIHB5ICogc2NcbiAgICBvdXRbMV0gPSBieSArIHB4ICogc2MgKyBweSAqIGNjXG4gICAgb3V0WzJdID0gYVsyXVxuICBcbiAgICByZXR1cm4gb3V0XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZvckVhY2g7XG5cbnZhciB2ZWMgPSByZXF1aXJlKCcuL2NyZWF0ZScpKClcblxuLyoqXG4gKiBQZXJmb3JtIHNvbWUgb3BlcmF0aW9uIG92ZXIgYW4gYXJyYXkgb2YgdmVjM3MuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYSB0aGUgYXJyYXkgb2YgdmVjdG9ycyB0byBpdGVyYXRlIG92ZXJcbiAqIEBwYXJhbSB7TnVtYmVyfSBzdHJpZGUgTnVtYmVyIG9mIGVsZW1lbnRzIGJldHdlZW4gdGhlIHN0YXJ0IG9mIGVhY2ggdmVjMy4gSWYgMCBhc3N1bWVzIHRpZ2h0bHkgcGFja2VkXG4gKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0IE51bWJlciBvZiBlbGVtZW50cyB0byBza2lwIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGFycmF5XG4gKiBAcGFyYW0ge051bWJlcn0gY291bnQgTnVtYmVyIG9mIHZlYzNzIHRvIGl0ZXJhdGUgb3Zlci4gSWYgMCBpdGVyYXRlcyBvdmVyIGVudGlyZSBhcnJheVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gRnVuY3Rpb24gdG8gY2FsbCBmb3IgZWFjaCB2ZWN0b3IgaW4gdGhlIGFycmF5XG4gKiBAcGFyYW0ge09iamVjdH0gW2FyZ10gYWRkaXRpb25hbCBhcmd1bWVudCB0byBwYXNzIHRvIGZuXG4gKiBAcmV0dXJucyB7QXJyYXl9IGFcbiAqIEBmdW5jdGlvblxuICovXG5mdW5jdGlvbiBmb3JFYWNoKGEsIHN0cmlkZSwgb2Zmc2V0LCBjb3VudCwgZm4sIGFyZykge1xuICAgICAgICB2YXIgaSwgbFxuICAgICAgICBpZighc3RyaWRlKSB7XG4gICAgICAgICAgICBzdHJpZGUgPSAzXG4gICAgICAgIH1cblxuICAgICAgICBpZighb2Zmc2V0KSB7XG4gICAgICAgICAgICBvZmZzZXQgPSAwXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmKGNvdW50KSB7XG4gICAgICAgICAgICBsID0gTWF0aC5taW4oKGNvdW50ICogc3RyaWRlKSArIG9mZnNldCwgYS5sZW5ndGgpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsID0gYS5sZW5ndGhcbiAgICAgICAgfVxuXG4gICAgICAgIGZvcihpID0gb2Zmc2V0OyBpIDwgbDsgaSArPSBzdHJpZGUpIHtcbiAgICAgICAgICAgIHZlY1swXSA9IGFbaV0gXG4gICAgICAgICAgICB2ZWNbMV0gPSBhW2krMV0gXG4gICAgICAgICAgICB2ZWNbMl0gPSBhW2krMl1cbiAgICAgICAgICAgIGZuKHZlYywgdmVjLCBhcmcpXG4gICAgICAgICAgICBhW2ldID0gdmVjWzBdIFxuICAgICAgICAgICAgYVtpKzFdID0gdmVjWzFdIFxuICAgICAgICAgICAgYVtpKzJdID0gdmVjWzJdXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiBhXG59IiwidmFyIGFycmF5TGlrZVRvQXJyYXkgPSByZXF1aXJlKFwiLi9hcnJheUxpa2VUb0FycmF5LmpzXCIpO1xuXG5mdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnJheUxpa2VUb0FycmF5KGFycik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2FycmF5V2l0aG91dEhvbGVzO1xubW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlOyIsImZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkoaXRlcikge1xuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBpdGVyW1N5bWJvbC5pdGVyYXRvcl0gIT0gbnVsbCB8fCBpdGVyW1wiQEBpdGVyYXRvclwiXSAhPSBudWxsKSByZXR1cm4gQXJyYXkuZnJvbShpdGVyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfaXRlcmFibGVUb0FycmF5O1xubW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlOyIsImZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX25vbkl0ZXJhYmxlU3ByZWFkO1xubW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlOyIsInZhciBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoXCIuL2dldFByb3RvdHlwZU9mLmpzXCIpO1xuXG5mdW5jdGlvbiBfc3VwZXJQcm9wQmFzZShvYmplY3QsIHByb3BlcnR5KSB7XG4gIHdoaWxlICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7XG4gICAgb2JqZWN0ID0gZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTtcbiAgICBpZiAob2JqZWN0ID09PSBudWxsKSBicmVhaztcbiAgfVxuXG4gIHJldHVybiBvYmplY3Q7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX3N1cGVyUHJvcEJhc2U7XG5tb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7IiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG52YXIgcnVudGltZSA9IChmdW5jdGlvbiAoZXhwb3J0cykge1xuICBcInVzZSBzdHJpY3RcIjtcblxuICB2YXIgT3AgPSBPYmplY3QucHJvdG90eXBlO1xuICB2YXIgaGFzT3duID0gT3AuaGFzT3duUHJvcGVydHk7XG4gIHZhciB1bmRlZmluZWQ7IC8vIE1vcmUgY29tcHJlc3NpYmxlIHRoYW4gdm9pZCAwLlxuICB2YXIgJFN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiA/IFN5bWJvbCA6IHt9O1xuICB2YXIgaXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLml0ZXJhdG9yIHx8IFwiQEBpdGVyYXRvclwiO1xuICB2YXIgYXN5bmNJdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuYXN5bmNJdGVyYXRvciB8fCBcIkBAYXN5bmNJdGVyYXRvclwiO1xuICB2YXIgdG9TdHJpbmdUYWdTeW1ib2wgPSAkU3ltYm9sLnRvU3RyaW5nVGFnIHx8IFwiQEB0b1N0cmluZ1RhZ1wiO1xuXG4gIGZ1bmN0aW9uIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBJZiBvdXRlckZuIHByb3ZpZGVkIGFuZCBvdXRlckZuLnByb3RvdHlwZSBpcyBhIEdlbmVyYXRvciwgdGhlbiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvci5cbiAgICB2YXIgcHJvdG9HZW5lcmF0b3IgPSBvdXRlckZuICYmIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yID8gb3V0ZXJGbiA6IEdlbmVyYXRvcjtcbiAgICB2YXIgZ2VuZXJhdG9yID0gT2JqZWN0LmNyZWF0ZShwcm90b0dlbmVyYXRvci5wcm90b3R5cGUpO1xuICAgIHZhciBjb250ZXh0ID0gbmV3IENvbnRleHQodHJ5TG9jc0xpc3QgfHwgW10pO1xuXG4gICAgLy8gVGhlIC5faW52b2tlIG1ldGhvZCB1bmlmaWVzIHRoZSBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlIC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcy5cbiAgICBnZW5lcmF0b3IuX2ludm9rZSA9IG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG5cbiAgICByZXR1cm4gZ2VuZXJhdG9yO1xuICB9XG4gIGV4cG9ydHMud3JhcCA9IHdyYXA7XG5cbiAgLy8gVHJ5L2NhdGNoIGhlbHBlciB0byBtaW5pbWl6ZSBkZW9wdGltaXphdGlvbnMuIFJldHVybnMgYSBjb21wbGV0aW9uXG4gIC8vIHJlY29yZCBsaWtlIGNvbnRleHQudHJ5RW50cmllc1tpXS5jb21wbGV0aW9uLiBUaGlzIGludGVyZmFjZSBjb3VsZFxuICAvLyBoYXZlIGJlZW4gKGFuZCB3YXMgcHJldmlvdXNseSkgZGVzaWduZWQgdG8gdGFrZSBhIGNsb3N1cmUgdG8gYmVcbiAgLy8gaW52b2tlZCB3aXRob3V0IGFyZ3VtZW50cywgYnV0IGluIGFsbCB0aGUgY2FzZXMgd2UgY2FyZSBhYm91dCB3ZVxuICAvLyBhbHJlYWR5IGhhdmUgYW4gZXhpc3RpbmcgbWV0aG9kIHdlIHdhbnQgdG8gY2FsbCwgc28gdGhlcmUncyBubyBuZWVkXG4gIC8vIHRvIGNyZWF0ZSBhIG5ldyBmdW5jdGlvbiBvYmplY3QuIFdlIGNhbiBldmVuIGdldCBhd2F5IHdpdGggYXNzdW1pbmdcbiAgLy8gdGhlIG1ldGhvZCB0YWtlcyBleGFjdGx5IG9uZSBhcmd1bWVudCwgc2luY2UgdGhhdCBoYXBwZW5zIHRvIGJlIHRydWVcbiAgLy8gaW4gZXZlcnkgY2FzZSwgc28gd2UgZG9uJ3QgaGF2ZSB0byB0b3VjaCB0aGUgYXJndW1lbnRzIG9iamVjdC4gVGhlXG4gIC8vIG9ubHkgYWRkaXRpb25hbCBhbGxvY2F0aW9uIHJlcXVpcmVkIGlzIHRoZSBjb21wbGV0aW9uIHJlY29yZCwgd2hpY2hcbiAgLy8gaGFzIGEgc3RhYmxlIHNoYXBlIGFuZCBzbyBob3BlZnVsbHkgc2hvdWxkIGJlIGNoZWFwIHRvIGFsbG9jYXRlLlxuICBmdW5jdGlvbiB0cnlDYXRjaChmbiwgb2JqLCBhcmcpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJub3JtYWxcIiwgYXJnOiBmbi5jYWxsKG9iaiwgYXJnKSB9O1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJ0aHJvd1wiLCBhcmc6IGVyciB9O1xuICAgIH1cbiAgfVxuXG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0ID0gXCJzdXNwZW5kZWRTdGFydFwiO1xuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRZaWVsZCA9IFwic3VzcGVuZGVkWWllbGRcIjtcbiAgdmFyIEdlblN0YXRlRXhlY3V0aW5nID0gXCJleGVjdXRpbmdcIjtcbiAgdmFyIEdlblN0YXRlQ29tcGxldGVkID0gXCJjb21wbGV0ZWRcIjtcblxuICAvLyBSZXR1cm5pbmcgdGhpcyBvYmplY3QgZnJvbSB0aGUgaW5uZXJGbiBoYXMgdGhlIHNhbWUgZWZmZWN0IGFzXG4gIC8vIGJyZWFraW5nIG91dCBvZiB0aGUgZGlzcGF0Y2ggc3dpdGNoIHN0YXRlbWVudC5cbiAgdmFyIENvbnRpbnVlU2VudGluZWwgPSB7fTtcblxuICAvLyBEdW1teSBjb25zdHJ1Y3RvciBmdW5jdGlvbnMgdGhhdCB3ZSB1c2UgYXMgdGhlIC5jb25zdHJ1Y3RvciBhbmRcbiAgLy8gLmNvbnN0cnVjdG9yLnByb3RvdHlwZSBwcm9wZXJ0aWVzIGZvciBmdW5jdGlvbnMgdGhhdCByZXR1cm4gR2VuZXJhdG9yXG4gIC8vIG9iamVjdHMuIEZvciBmdWxsIHNwZWMgY29tcGxpYW5jZSwgeW91IG1heSB3aXNoIHRvIGNvbmZpZ3VyZSB5b3VyXG4gIC8vIG1pbmlmaWVyIG5vdCB0byBtYW5nbGUgdGhlIG5hbWVzIG9mIHRoZXNlIHR3byBmdW5jdGlvbnMuXG4gIGZ1bmN0aW9uIEdlbmVyYXRvcigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUoKSB7fVxuXG4gIC8vIFRoaXMgaXMgYSBwb2x5ZmlsbCBmb3IgJUl0ZXJhdG9yUHJvdG90eXBlJSBmb3IgZW52aXJvbm1lbnRzIHRoYXRcbiAgLy8gZG9uJ3QgbmF0aXZlbHkgc3VwcG9ydCBpdC5cbiAgdmFyIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XG4gIEl0ZXJhdG9yUHJvdG90eXBlW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICB2YXIgZ2V0UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG4gIHZhciBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvICYmIGdldFByb3RvKGdldFByb3RvKHZhbHVlcyhbXSkpKTtcbiAgaWYgKE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICYmXG4gICAgICBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAhPT0gT3AgJiZcbiAgICAgIGhhc093bi5jYWxsKE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlLCBpdGVyYXRvclN5bWJvbCkpIHtcbiAgICAvLyBUaGlzIGVudmlyb25tZW50IGhhcyBhIG5hdGl2ZSAlSXRlcmF0b3JQcm90b3R5cGUlOyB1c2UgaXQgaW5zdGVhZFxuICAgIC8vIG9mIHRoZSBwb2x5ZmlsbC5cbiAgICBJdGVyYXRvclByb3RvdHlwZSA9IE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlO1xuICB9XG5cbiAgdmFyIEdwID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUucHJvdG90eXBlID1cbiAgICBHZW5lcmF0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSk7XG4gIEdlbmVyYXRvckZ1bmN0aW9uLnByb3RvdHlwZSA9IEdwLmNvbnN0cnVjdG9yID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLmNvbnN0cnVjdG9yID0gR2VuZXJhdG9yRnVuY3Rpb247XG4gIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlW3RvU3RyaW5nVGFnU3ltYm9sXSA9XG4gICAgR2VuZXJhdG9yRnVuY3Rpb24uZGlzcGxheU5hbWUgPSBcIkdlbmVyYXRvckZ1bmN0aW9uXCI7XG5cbiAgLy8gSGVscGVyIGZvciBkZWZpbmluZyB0aGUgLm5leHQsIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcyBvZiB0aGVcbiAgLy8gSXRlcmF0b3IgaW50ZXJmYWNlIGluIHRlcm1zIG9mIGEgc2luZ2xlIC5faW52b2tlIG1ldGhvZC5cbiAgZnVuY3Rpb24gZGVmaW5lSXRlcmF0b3JNZXRob2RzKHByb3RvdHlwZSkge1xuICAgIFtcIm5leHRcIiwgXCJ0aHJvd1wiLCBcInJldHVyblwiXS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgICAgcHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludm9rZShtZXRob2QsIGFyZyk7XG4gICAgICB9O1xuICAgIH0pO1xuICB9XG5cbiAgZXhwb3J0cy5pc0dlbmVyYXRvckZ1bmN0aW9uID0gZnVuY3Rpb24oZ2VuRnVuKSB7XG4gICAgdmFyIGN0b3IgPSB0eXBlb2YgZ2VuRnVuID09PSBcImZ1bmN0aW9uXCIgJiYgZ2VuRnVuLmNvbnN0cnVjdG9yO1xuICAgIHJldHVybiBjdG9yXG4gICAgICA/IGN0b3IgPT09IEdlbmVyYXRvckZ1bmN0aW9uIHx8XG4gICAgICAgIC8vIEZvciB0aGUgbmF0aXZlIEdlbmVyYXRvckZ1bmN0aW9uIGNvbnN0cnVjdG9yLCB0aGUgYmVzdCB3ZSBjYW5cbiAgICAgICAgLy8gZG8gaXMgdG8gY2hlY2sgaXRzIC5uYW1lIHByb3BlcnR5LlxuICAgICAgICAoY3Rvci5kaXNwbGF5TmFtZSB8fCBjdG9yLm5hbWUpID09PSBcIkdlbmVyYXRvckZ1bmN0aW9uXCJcbiAgICAgIDogZmFsc2U7XG4gIH07XG5cbiAgZXhwb3J0cy5tYXJrID0gZnVuY3Rpb24oZ2VuRnVuKSB7XG4gICAgaWYgKE9iamVjdC5zZXRQcm90b3R5cGVPZikge1xuICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGdlbkZ1biwgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBnZW5GdW4uX19wcm90b19fID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gICAgICBpZiAoISh0b1N0cmluZ1RhZ1N5bWJvbCBpbiBnZW5GdW4pKSB7XG4gICAgICAgIGdlbkZ1blt0b1N0cmluZ1RhZ1N5bWJvbF0gPSBcIkdlbmVyYXRvckZ1bmN0aW9uXCI7XG4gICAgICB9XG4gICAgfVxuICAgIGdlbkZ1bi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEdwKTtcbiAgICByZXR1cm4gZ2VuRnVuO1xuICB9O1xuXG4gIC8vIFdpdGhpbiB0aGUgYm9keSBvZiBhbnkgYXN5bmMgZnVuY3Rpb24sIGBhd2FpdCB4YCBpcyB0cmFuc2Zvcm1lZCB0b1xuICAvLyBgeWllbGQgcmVnZW5lcmF0b3JSdW50aW1lLmF3cmFwKHgpYCwgc28gdGhhdCB0aGUgcnVudGltZSBjYW4gdGVzdFxuICAvLyBgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKWAgdG8gZGV0ZXJtaW5lIGlmIHRoZSB5aWVsZGVkIHZhbHVlIGlzXG4gIC8vIG1lYW50IHRvIGJlIGF3YWl0ZWQuXG4gIGV4cG9ydHMuYXdyYXAgPSBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4geyBfX2F3YWl0OiBhcmcgfTtcbiAgfTtcblxuICBmdW5jdGlvbiBBc3luY0l0ZXJhdG9yKGdlbmVyYXRvciwgUHJvbWlzZUltcGwpIHtcbiAgICBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGdlbmVyYXRvclttZXRob2RdLCBnZW5lcmF0b3IsIGFyZyk7XG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICByZWplY3QocmVjb3JkLmFyZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcmVzdWx0ID0gcmVjb3JkLmFyZztcbiAgICAgICAgdmFyIHZhbHVlID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICBpZiAodmFsdWUgJiZcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKSkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlSW1wbC5yZXNvbHZlKHZhbHVlLl9fYXdhaXQpLnRoZW4oZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIGludm9rZShcIm5leHRcIiwgdmFsdWUsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICBpbnZva2UoXCJ0aHJvd1wiLCBlcnIsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gUHJvbWlzZUltcGwucmVzb2x2ZSh2YWx1ZSkudGhlbihmdW5jdGlvbih1bndyYXBwZWQpIHtcbiAgICAgICAgICAvLyBXaGVuIGEgeWllbGRlZCBQcm9taXNlIGlzIHJlc29sdmVkLCBpdHMgZmluYWwgdmFsdWUgYmVjb21lc1xuICAgICAgICAgIC8vIHRoZSAudmFsdWUgb2YgdGhlIFByb21pc2U8e3ZhbHVlLGRvbmV9PiByZXN1bHQgZm9yIHRoZVxuICAgICAgICAgIC8vIGN1cnJlbnQgaXRlcmF0aW9uLlxuICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IHVud3JhcHBlZDtcbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0sIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgLy8gSWYgYSByZWplY3RlZCBQcm9taXNlIHdhcyB5aWVsZGVkLCB0aHJvdyB0aGUgcmVqZWN0aW9uIGJhY2tcbiAgICAgICAgICAvLyBpbnRvIHRoZSBhc3luYyBnZW5lcmF0b3IgZnVuY3Rpb24gc28gaXQgY2FuIGJlIGhhbmRsZWQgdGhlcmUuXG4gICAgICAgICAgcmV0dXJuIGludm9rZShcInRocm93XCIsIGVycm9yLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcHJldmlvdXNQcm9taXNlO1xuXG4gICAgZnVuY3Rpb24gZW5xdWV1ZShtZXRob2QsIGFyZykge1xuICAgICAgZnVuY3Rpb24gY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZUltcGwoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByZXZpb3VzUHJvbWlzZSA9XG4gICAgICAgIC8vIElmIGVucXVldWUgaGFzIGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiB3ZSB3YW50IHRvIHdhaXQgdW50aWxcbiAgICAgICAgLy8gYWxsIHByZXZpb3VzIFByb21pc2VzIGhhdmUgYmVlbiByZXNvbHZlZCBiZWZvcmUgY2FsbGluZyBpbnZva2UsXG4gICAgICAgIC8vIHNvIHRoYXQgcmVzdWx0cyBhcmUgYWx3YXlzIGRlbGl2ZXJlZCBpbiB0aGUgY29ycmVjdCBvcmRlci4gSWZcbiAgICAgICAgLy8gZW5xdWV1ZSBoYXMgbm90IGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiBpdCBpcyBpbXBvcnRhbnQgdG9cbiAgICAgICAgLy8gY2FsbCBpbnZva2UgaW1tZWRpYXRlbHksIHdpdGhvdXQgd2FpdGluZyBvbiBhIGNhbGxiYWNrIHRvIGZpcmUsXG4gICAgICAgIC8vIHNvIHRoYXQgdGhlIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBoYXMgdGhlIG9wcG9ydHVuaXR5IHRvIGRvXG4gICAgICAgIC8vIGFueSBuZWNlc3Nhcnkgc2V0dXAgaW4gYSBwcmVkaWN0YWJsZSB3YXkuIFRoaXMgcHJlZGljdGFiaWxpdHlcbiAgICAgICAgLy8gaXMgd2h5IHRoZSBQcm9taXNlIGNvbnN0cnVjdG9yIHN5bmNocm9ub3VzbHkgaW52b2tlcyBpdHNcbiAgICAgICAgLy8gZXhlY3V0b3IgY2FsbGJhY2ssIGFuZCB3aHkgYXN5bmMgZnVuY3Rpb25zIHN5bmNocm9ub3VzbHlcbiAgICAgICAgLy8gZXhlY3V0ZSBjb2RlIGJlZm9yZSB0aGUgZmlyc3QgYXdhaXQuIFNpbmNlIHdlIGltcGxlbWVudCBzaW1wbGVcbiAgICAgICAgLy8gYXN5bmMgZnVuY3Rpb25zIGluIHRlcm1zIG9mIGFzeW5jIGdlbmVyYXRvcnMsIGl0IGlzIGVzcGVjaWFsbHlcbiAgICAgICAgLy8gaW1wb3J0YW50IHRvIGdldCB0aGlzIHJpZ2h0LCBldmVuIHRob3VnaCBpdCByZXF1aXJlcyBjYXJlLlxuICAgICAgICBwcmV2aW91c1Byb21pc2UgPyBwcmV2aW91c1Byb21pc2UudGhlbihcbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZyxcbiAgICAgICAgICAvLyBBdm9pZCBwcm9wYWdhdGluZyBmYWlsdXJlcyB0byBQcm9taXNlcyByZXR1cm5lZCBieSBsYXRlclxuICAgICAgICAgIC8vIGludm9jYXRpb25zIG9mIHRoZSBpdGVyYXRvci5cbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZ1xuICAgICAgICApIDogY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKTtcbiAgICB9XG5cbiAgICAvLyBEZWZpbmUgdGhlIHVuaWZpZWQgaGVscGVyIG1ldGhvZCB0aGF0IGlzIHVzZWQgdG8gaW1wbGVtZW50IC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gKHNlZSBkZWZpbmVJdGVyYXRvck1ldGhvZHMpLlxuICAgIHRoaXMuX2ludm9rZSA9IGVucXVldWU7XG4gIH1cblxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUpO1xuICBBc3luY0l0ZXJhdG9yLnByb3RvdHlwZVthc3luY0l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgZXhwb3J0cy5Bc3luY0l0ZXJhdG9yID0gQXN5bmNJdGVyYXRvcjtcblxuICAvLyBOb3RlIHRoYXQgc2ltcGxlIGFzeW5jIGZ1bmN0aW9ucyBhcmUgaW1wbGVtZW50ZWQgb24gdG9wIG9mXG4gIC8vIEFzeW5jSXRlcmF0b3Igb2JqZWN0czsgdGhleSBqdXN0IHJldHVybiBhIFByb21pc2UgZm9yIHRoZSB2YWx1ZSBvZlxuICAvLyB0aGUgZmluYWwgcmVzdWx0IHByb2R1Y2VkIGJ5IHRoZSBpdGVyYXRvci5cbiAgZXhwb3J0cy5hc3luYyA9IGZ1bmN0aW9uKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0LCBQcm9taXNlSW1wbCkge1xuICAgIGlmIChQcm9taXNlSW1wbCA9PT0gdm9pZCAwKSBQcm9taXNlSW1wbCA9IFByb21pc2U7XG5cbiAgICB2YXIgaXRlciA9IG5ldyBBc3luY0l0ZXJhdG9yKFxuICAgICAgd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCksXG4gICAgICBQcm9taXNlSW1wbFxuICAgICk7XG5cbiAgICByZXR1cm4gZXhwb3J0cy5pc0dlbmVyYXRvckZ1bmN0aW9uKG91dGVyRm4pXG4gICAgICA/IGl0ZXIgLy8gSWYgb3V0ZXJGbiBpcyBhIGdlbmVyYXRvciwgcmV0dXJuIHRoZSBmdWxsIGl0ZXJhdG9yLlxuICAgICAgOiBpdGVyLm5leHQoKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQuZG9uZSA/IHJlc3VsdC52YWx1ZSA6IGl0ZXIubmV4dCgpO1xuICAgICAgICB9KTtcbiAgfTtcblxuICBmdW5jdGlvbiBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpIHtcbiAgICB2YXIgc3RhdGUgPSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZykge1xuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUV4ZWN1dGluZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBydW5uaW5nXCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlQ29tcGxldGVkKSB7XG4gICAgICAgIGlmIChtZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHRocm93IGFyZztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJlIGZvcmdpdmluZywgcGVyIDI1LjMuMy4zLjMgb2YgdGhlIHNwZWM6XG4gICAgICAgIC8vIGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1nZW5lcmF0b3JyZXN1bWVcbiAgICAgICAgcmV0dXJuIGRvbmVSZXN1bHQoKTtcbiAgICAgIH1cblxuICAgICAgY29udGV4dC5tZXRob2QgPSBtZXRob2Q7XG4gICAgICBjb250ZXh0LmFyZyA9IGFyZztcblxuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdmFyIGRlbGVnYXRlID0gY29udGV4dC5kZWxlZ2F0ZTtcbiAgICAgICAgaWYgKGRlbGVnYXRlKSB7XG4gICAgICAgICAgdmFyIGRlbGVnYXRlUmVzdWx0ID0gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG4gICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0KSB7XG4gICAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQgPT09IENvbnRpbnVlU2VudGluZWwpIGNvbnRpbnVlO1xuICAgICAgICAgICAgcmV0dXJuIGRlbGVnYXRlUmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgICAvLyBTZXR0aW5nIGNvbnRleHQuX3NlbnQgZm9yIGxlZ2FjeSBzdXBwb3J0IG9mIEJhYmVsJ3NcbiAgICAgICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgICAgIGNvbnRleHQuc2VudCA9IGNvbnRleHQuX3NlbnQgPSBjb250ZXh0LmFyZztcblxuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQpIHtcbiAgICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgICB0aHJvdyBjb250ZXh0LmFyZztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKTtcblxuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInJldHVyblwiKSB7XG4gICAgICAgICAgY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgY29udGV4dC5hcmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUV4ZWN1dGluZztcblxuICAgICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG4gICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIikge1xuICAgICAgICAgIC8vIElmIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24gZnJvbSBpbm5lckZuLCB3ZSBsZWF2ZSBzdGF0ZSA9PT1cbiAgICAgICAgICAvLyBHZW5TdGF0ZUV4ZWN1dGluZyBhbmQgbG9vcCBiYWNrIGZvciBhbm90aGVyIGludm9jYXRpb24uXG4gICAgICAgICAgc3RhdGUgPSBjb250ZXh0LmRvbmVcbiAgICAgICAgICAgID8gR2VuU3RhdGVDb21wbGV0ZWRcbiAgICAgICAgICAgIDogR2VuU3RhdGVTdXNwZW5kZWRZaWVsZDtcblxuICAgICAgICAgIGlmIChyZWNvcmQuYXJnID09PSBDb250aW51ZVNlbnRpbmVsKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWU6IHJlY29yZC5hcmcsXG4gICAgICAgICAgICBkb25lOiBjb250ZXh0LmRvbmVcbiAgICAgICAgICB9O1xuXG4gICAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgLy8gRGlzcGF0Y2ggdGhlIGV4Y2VwdGlvbiBieSBsb29waW5nIGJhY2sgYXJvdW5kIHRvIHRoZVxuICAgICAgICAgIC8vIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpIGNhbGwgYWJvdmUuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8vIENhbGwgZGVsZWdhdGUuaXRlcmF0b3JbY29udGV4dC5tZXRob2RdKGNvbnRleHQuYXJnKSBhbmQgaGFuZGxlIHRoZVxuICAvLyByZXN1bHQsIGVpdGhlciBieSByZXR1cm5pbmcgYSB7IHZhbHVlLCBkb25lIH0gcmVzdWx0IGZyb20gdGhlXG4gIC8vIGRlbGVnYXRlIGl0ZXJhdG9yLCBvciBieSBtb2RpZnlpbmcgY29udGV4dC5tZXRob2QgYW5kIGNvbnRleHQuYXJnLFxuICAvLyBzZXR0aW5nIGNvbnRleHQuZGVsZWdhdGUgdG8gbnVsbCwgYW5kIHJldHVybmluZyB0aGUgQ29udGludWVTZW50aW5lbC5cbiAgZnVuY3Rpb24gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCkge1xuICAgIHZhciBtZXRob2QgPSBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF07XG4gICAgaWYgKG1ldGhvZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBBIC50aHJvdyBvciAucmV0dXJuIHdoZW4gdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBubyAudGhyb3dcbiAgICAgIC8vIG1ldGhvZCBhbHdheXMgdGVybWluYXRlcyB0aGUgeWllbGQqIGxvb3AuXG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgLy8gTm90ZTogW1wicmV0dXJuXCJdIG11c3QgYmUgdXNlZCBmb3IgRVMzIHBhcnNpbmcgY29tcGF0aWJpbGl0eS5cbiAgICAgICAgaWYgKGRlbGVnYXRlLml0ZXJhdG9yW1wicmV0dXJuXCJdKSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBhIHJldHVybiBtZXRob2QsIGdpdmUgaXQgYVxuICAgICAgICAgIC8vIGNoYW5jZSB0byBjbGVhbiB1cC5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwicmV0dXJuXCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG5cbiAgICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgLy8gSWYgbWF5YmVJbnZva2VEZWxlZ2F0ZShjb250ZXh0KSBjaGFuZ2VkIGNvbnRleHQubWV0aG9kIGZyb21cbiAgICAgICAgICAgIC8vIFwicmV0dXJuXCIgdG8gXCJ0aHJvd1wiLCBsZXQgdGhhdCBvdmVycmlkZSB0aGUgVHlwZUVycm9yIGJlbG93LlxuICAgICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICBcIlRoZSBpdGVyYXRvciBkb2VzIG5vdCBwcm92aWRlIGEgJ3Rocm93JyBtZXRob2RcIik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChtZXRob2QsIGRlbGVnYXRlLml0ZXJhdG9yLCBjb250ZXh0LmFyZyk7XG5cbiAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciBpbmZvID0gcmVjb3JkLmFyZztcblxuICAgIGlmICghIGluZm8pIHtcbiAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFwiaXRlcmF0b3IgcmVzdWx0IGlzIG5vdCBhbiBvYmplY3RcIik7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIGlmIChpbmZvLmRvbmUpIHtcbiAgICAgIC8vIEFzc2lnbiB0aGUgcmVzdWx0IG9mIHRoZSBmaW5pc2hlZCBkZWxlZ2F0ZSB0byB0aGUgdGVtcG9yYXJ5XG4gICAgICAvLyB2YXJpYWJsZSBzcGVjaWZpZWQgYnkgZGVsZWdhdGUucmVzdWx0TmFtZSAoc2VlIGRlbGVnYXRlWWllbGQpLlxuICAgICAgY29udGV4dFtkZWxlZ2F0ZS5yZXN1bHROYW1lXSA9IGluZm8udmFsdWU7XG5cbiAgICAgIC8vIFJlc3VtZSBleGVjdXRpb24gYXQgdGhlIGRlc2lyZWQgbG9jYXRpb24gKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cbiAgICAgIGNvbnRleHQubmV4dCA9IGRlbGVnYXRlLm5leHRMb2M7XG5cbiAgICAgIC8vIElmIGNvbnRleHQubWV0aG9kIHdhcyBcInRocm93XCIgYnV0IHRoZSBkZWxlZ2F0ZSBoYW5kbGVkIHRoZVxuICAgICAgLy8gZXhjZXB0aW9uLCBsZXQgdGhlIG91dGVyIGdlbmVyYXRvciBwcm9jZWVkIG5vcm1hbGx5LiBJZlxuICAgICAgLy8gY29udGV4dC5tZXRob2Qgd2FzIFwibmV4dFwiLCBmb3JnZXQgY29udGV4dC5hcmcgc2luY2UgaXQgaGFzIGJlZW5cbiAgICAgIC8vIFwiY29uc3VtZWRcIiBieSB0aGUgZGVsZWdhdGUgaXRlcmF0b3IuIElmIGNvbnRleHQubWV0aG9kIHdhc1xuICAgICAgLy8gXCJyZXR1cm5cIiwgYWxsb3cgdGhlIG9yaWdpbmFsIC5yZXR1cm4gY2FsbCB0byBjb250aW51ZSBpbiB0aGVcbiAgICAgIC8vIG91dGVyIGdlbmVyYXRvci5cbiAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCAhPT0gXCJyZXR1cm5cIikge1xuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZS15aWVsZCB0aGUgcmVzdWx0IHJldHVybmVkIGJ5IHRoZSBkZWxlZ2F0ZSBtZXRob2QuXG4gICAgICByZXR1cm4gaW5mbztcbiAgICB9XG5cbiAgICAvLyBUaGUgZGVsZWdhdGUgaXRlcmF0b3IgaXMgZmluaXNoZWQsIHNvIGZvcmdldCBpdCBhbmQgY29udGludWUgd2l0aFxuICAgIC8vIHRoZSBvdXRlciBnZW5lcmF0b3IuXG4gICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gIH1cblxuICAvLyBEZWZpbmUgR2VuZXJhdG9yLnByb3RvdHlwZS57bmV4dCx0aHJvdyxyZXR1cm59IGluIHRlcm1zIG9mIHRoZVxuICAvLyB1bmlmaWVkIC5faW52b2tlIGhlbHBlciBtZXRob2QuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhHcCk7XG5cbiAgR3BbdG9TdHJpbmdUYWdTeW1ib2xdID0gXCJHZW5lcmF0b3JcIjtcblxuICAvLyBBIEdlbmVyYXRvciBzaG91bGQgYWx3YXlzIHJldHVybiBpdHNlbGYgYXMgdGhlIGl0ZXJhdG9yIG9iamVjdCB3aGVuIHRoZVxuICAvLyBAQGl0ZXJhdG9yIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbiBpdC4gU29tZSBicm93c2VycycgaW1wbGVtZW50YXRpb25zIG9mIHRoZVxuICAvLyBpdGVyYXRvciBwcm90b3R5cGUgY2hhaW4gaW5jb3JyZWN0bHkgaW1wbGVtZW50IHRoaXMsIGNhdXNpbmcgdGhlIEdlbmVyYXRvclxuICAvLyBvYmplY3QgdG8gbm90IGJlIHJldHVybmVkIGZyb20gdGhpcyBjYWxsLiBUaGlzIGVuc3VyZXMgdGhhdCBkb2Vzbid0IGhhcHBlbi5cbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWdlbmVyYXRvci9pc3N1ZXMvMjc0IGZvciBtb3JlIGRldGFpbHMuXG4gIEdwW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEdwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFwiW29iamVjdCBHZW5lcmF0b3JdXCI7XG4gIH07XG5cbiAgZnVuY3Rpb24gcHVzaFRyeUVudHJ5KGxvY3MpIHtcbiAgICB2YXIgZW50cnkgPSB7IHRyeUxvYzogbG9jc1swXSB9O1xuXG4gICAgaWYgKDEgaW4gbG9jcykge1xuICAgICAgZW50cnkuY2F0Y2hMb2MgPSBsb2NzWzFdO1xuICAgIH1cblxuICAgIGlmICgyIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmZpbmFsbHlMb2MgPSBsb2NzWzJdO1xuICAgICAgZW50cnkuYWZ0ZXJMb2MgPSBsb2NzWzNdO1xuICAgIH1cblxuICAgIHRoaXMudHJ5RW50cmllcy5wdXNoKGVudHJ5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0VHJ5RW50cnkoZW50cnkpIHtcbiAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbiB8fCB7fTtcbiAgICByZWNvcmQudHlwZSA9IFwibm9ybWFsXCI7XG4gICAgZGVsZXRlIHJlY29yZC5hcmc7XG4gICAgZW50cnkuY29tcGxldGlvbiA9IHJlY29yZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIENvbnRleHQodHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBUaGUgcm9vdCBlbnRyeSBvYmplY3QgKGVmZmVjdGl2ZWx5IGEgdHJ5IHN0YXRlbWVudCB3aXRob3V0IGEgY2F0Y2hcbiAgICAvLyBvciBhIGZpbmFsbHkgYmxvY2spIGdpdmVzIHVzIGEgcGxhY2UgdG8gc3RvcmUgdmFsdWVzIHRocm93biBmcm9tXG4gICAgLy8gbG9jYXRpb25zIHdoZXJlIHRoZXJlIGlzIG5vIGVuY2xvc2luZyB0cnkgc3RhdGVtZW50LlxuICAgIHRoaXMudHJ5RW50cmllcyA9IFt7IHRyeUxvYzogXCJyb290XCIgfV07XG4gICAgdHJ5TG9jc0xpc3QuZm9yRWFjaChwdXNoVHJ5RW50cnksIHRoaXMpO1xuICAgIHRoaXMucmVzZXQodHJ1ZSk7XG4gIH1cblxuICBleHBvcnRzLmtleXMgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgIGtleXMucHVzaChrZXkpO1xuICAgIH1cbiAgICBrZXlzLnJldmVyc2UoKTtcblxuICAgIC8vIFJhdGhlciB0aGFuIHJldHVybmluZyBhbiBvYmplY3Qgd2l0aCBhIG5leHQgbWV0aG9kLCB3ZSBrZWVwXG4gICAgLy8gdGhpbmdzIHNpbXBsZSBhbmQgcmV0dXJuIHRoZSBuZXh0IGZ1bmN0aW9uIGl0c2VsZi5cbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgIHdoaWxlIChrZXlzLmxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0ga2V5cy5wb3AoKTtcbiAgICAgICAgaWYgKGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgICBuZXh0LnZhbHVlID0ga2V5O1xuICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRvIGF2b2lkIGNyZWF0aW5nIGFuIGFkZGl0aW9uYWwgb2JqZWN0LCB3ZSBqdXN0IGhhbmcgdGhlIC52YWx1ZVxuICAgICAgLy8gYW5kIC5kb25lIHByb3BlcnRpZXMgb2ZmIHRoZSBuZXh0IGZ1bmN0aW9uIG9iamVjdCBpdHNlbGYuIFRoaXNcbiAgICAgIC8vIGFsc28gZW5zdXJlcyB0aGF0IHRoZSBtaW5pZmllciB3aWxsIG5vdCBhbm9ueW1pemUgdGhlIGZ1bmN0aW9uLlxuICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcbiAgICAgIHJldHVybiBuZXh0O1xuICAgIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gdmFsdWVzKGl0ZXJhYmxlKSB7XG4gICAgaWYgKGl0ZXJhYmxlKSB7XG4gICAgICB2YXIgaXRlcmF0b3JNZXRob2QgPSBpdGVyYWJsZVtpdGVyYXRvclN5bWJvbF07XG4gICAgICBpZiAoaXRlcmF0b3JNZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yTWV0aG9kLmNhbGwoaXRlcmFibGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhYmxlLm5leHQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gaXRlcmFibGU7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNOYU4oaXRlcmFibGUubGVuZ3RoKSkge1xuICAgICAgICB2YXIgaSA9IC0xLCBuZXh0ID0gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgICB3aGlsZSAoKytpIDwgaXRlcmFibGUubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duLmNhbGwoaXRlcmFibGUsIGkpKSB7XG4gICAgICAgICAgICAgIG5leHQudmFsdWUgPSBpdGVyYWJsZVtpXTtcbiAgICAgICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIG5leHQudmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcblxuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBuZXh0Lm5leHQgPSBuZXh0O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJldHVybiBhbiBpdGVyYXRvciB3aXRoIG5vIHZhbHVlcy5cbiAgICByZXR1cm4geyBuZXh0OiBkb25lUmVzdWx0IH07XG4gIH1cbiAgZXhwb3J0cy52YWx1ZXMgPSB2YWx1ZXM7XG5cbiAgZnVuY3Rpb24gZG9uZVJlc3VsdCgpIHtcbiAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gIH1cblxuICBDb250ZXh0LnByb3RvdHlwZSA9IHtcbiAgICBjb25zdHJ1Y3RvcjogQ29udGV4dCxcblxuICAgIHJlc2V0OiBmdW5jdGlvbihza2lwVGVtcFJlc2V0KSB7XG4gICAgICB0aGlzLnByZXYgPSAwO1xuICAgICAgdGhpcy5uZXh0ID0gMDtcbiAgICAgIC8vIFJlc2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgdGhpcy5zZW50ID0gdGhpcy5fc2VudCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgIHRoaXMubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZDtcblxuICAgICAgdGhpcy50cnlFbnRyaWVzLmZvckVhY2gocmVzZXRUcnlFbnRyeSk7XG5cbiAgICAgIGlmICghc2tpcFRlbXBSZXNldCkge1xuICAgICAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMpIHtcbiAgICAgICAgICAvLyBOb3Qgc3VyZSBhYm91dCB0aGUgb3B0aW1hbCBvcmRlciBvZiB0aGVzZSBjb25kaXRpb25zOlxuICAgICAgICAgIGlmIChuYW1lLmNoYXJBdCgwKSA9PT0gXCJ0XCIgJiZcbiAgICAgICAgICAgICAgaGFzT3duLmNhbGwodGhpcywgbmFtZSkgJiZcbiAgICAgICAgICAgICAgIWlzTmFOKCtuYW1lLnNsaWNlKDEpKSkge1xuICAgICAgICAgICAgdGhpc1tuYW1lXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc3RvcDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuXG4gICAgICB2YXIgcm9vdEVudHJ5ID0gdGhpcy50cnlFbnRyaWVzWzBdO1xuICAgICAgdmFyIHJvb3RSZWNvcmQgPSByb290RW50cnkuY29tcGxldGlvbjtcbiAgICAgIGlmIChyb290UmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByb290UmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucnZhbDtcbiAgICB9LFxuXG4gICAgZGlzcGF0Y2hFeGNlcHRpb246IGZ1bmN0aW9uKGV4Y2VwdGlvbikge1xuICAgICAgaWYgKHRoaXMuZG9uZSkge1xuICAgICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgICB9XG5cbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcztcbiAgICAgIGZ1bmN0aW9uIGhhbmRsZShsb2MsIGNhdWdodCkge1xuICAgICAgICByZWNvcmQudHlwZSA9IFwidGhyb3dcIjtcbiAgICAgICAgcmVjb3JkLmFyZyA9IGV4Y2VwdGlvbjtcbiAgICAgICAgY29udGV4dC5uZXh0ID0gbG9jO1xuXG4gICAgICAgIGlmIChjYXVnaHQpIHtcbiAgICAgICAgICAvLyBJZiB0aGUgZGlzcGF0Y2hlZCBleGNlcHRpb24gd2FzIGNhdWdodCBieSBhIGNhdGNoIGJsb2NrLFxuICAgICAgICAgIC8vIHRoZW4gbGV0IHRoYXQgY2F0Y2ggYmxvY2sgaGFuZGxlIHRoZSBleGNlcHRpb24gbm9ybWFsbHkuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAhISBjYXVnaHQ7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSBcInJvb3RcIikge1xuICAgICAgICAgIC8vIEV4Y2VwdGlvbiB0aHJvd24gb3V0c2lkZSBvZiBhbnkgdHJ5IGJsb2NrIHRoYXQgY291bGQgaGFuZGxlXG4gICAgICAgICAgLy8gaXQsIHNvIHNldCB0aGUgY29tcGxldGlvbiB2YWx1ZSBvZiB0aGUgZW50aXJlIGZ1bmN0aW9uIHRvXG4gICAgICAgICAgLy8gdGhyb3cgdGhlIGV4Y2VwdGlvbi5cbiAgICAgICAgICByZXR1cm4gaGFuZGxlKFwiZW5kXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYpIHtcbiAgICAgICAgICB2YXIgaGFzQ2F0Y2ggPSBoYXNPd24uY2FsbChlbnRyeSwgXCJjYXRjaExvY1wiKTtcbiAgICAgICAgICB2YXIgaGFzRmluYWxseSA9IGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIik7XG5cbiAgICAgICAgICBpZiAoaGFzQ2F0Y2ggJiYgaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0NhdGNoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHJ5IHN0YXRlbWVudCB3aXRob3V0IGNhdGNoIG9yIGZpbmFsbHlcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGFicnVwdDogZnVuY3Rpb24odHlwZSwgYXJnKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYgJiZcbiAgICAgICAgICAgIGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIikgJiZcbiAgICAgICAgICAgIHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB2YXIgZmluYWxseUVudHJ5ID0gZW50cnk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSAmJlxuICAgICAgICAgICh0eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICAgdHlwZSA9PT0gXCJjb250aW51ZVwiKSAmJlxuICAgICAgICAgIGZpbmFsbHlFbnRyeS50cnlMb2MgPD0gYXJnICYmXG4gICAgICAgICAgYXJnIDw9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgIC8vIElnbm9yZSB0aGUgZmluYWxseSBlbnRyeSBpZiBjb250cm9sIGlzIG5vdCBqdW1waW5nIHRvIGFcbiAgICAgICAgLy8gbG9jYXRpb24gb3V0c2lkZSB0aGUgdHJ5L2NhdGNoIGJsb2NrLlxuICAgICAgICBmaW5hbGx5RW50cnkgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVjb3JkID0gZmluYWxseUVudHJ5ID8gZmluYWxseUVudHJ5LmNvbXBsZXRpb24gOiB7fTtcbiAgICAgIHJlY29yZC50eXBlID0gdHlwZTtcbiAgICAgIHJlY29yZC5hcmcgPSBhcmc7XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkpIHtcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgdGhpcy5uZXh0ID0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2M7XG4gICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5jb21wbGV0ZShyZWNvcmQpO1xuICAgIH0sXG5cbiAgICBjb21wbGV0ZTogZnVuY3Rpb24ocmVjb3JkLCBhZnRlckxvYykge1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICByZWNvcmQudHlwZSA9PT0gXCJjb250aW51ZVwiKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IHJlY29yZC5hcmc7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInJldHVyblwiKSB7XG4gICAgICAgIHRoaXMucnZhbCA9IHRoaXMuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcInJldHVyblwiO1xuICAgICAgICB0aGlzLm5leHQgPSBcImVuZFwiO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIiAmJiBhZnRlckxvYykge1xuICAgICAgICB0aGlzLm5leHQgPSBhZnRlckxvYztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfSxcblxuICAgIGZpbmlzaDogZnVuY3Rpb24oZmluYWxseUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS5maW5hbGx5TG9jID09PSBmaW5hbGx5TG9jKSB7XG4gICAgICAgICAgdGhpcy5jb21wbGV0ZShlbnRyeS5jb21wbGV0aW9uLCBlbnRyeS5hZnRlckxvYyk7XG4gICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgXCJjYXRjaFwiOiBmdW5jdGlvbih0cnlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSB0cnlMb2MpIHtcbiAgICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcbiAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgdmFyIHRocm93biA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRocm93bjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUaGUgY29udGV4dC5jYXRjaCBtZXRob2QgbXVzdCBvbmx5IGJlIGNhbGxlZCB3aXRoIGEgbG9jYXRpb25cbiAgICAgIC8vIGFyZ3VtZW50IHRoYXQgY29ycmVzcG9uZHMgdG8gYSBrbm93biBjYXRjaCBibG9jay5cbiAgICAgIHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgY2F0Y2ggYXR0ZW1wdFwiKTtcbiAgICB9LFxuXG4gICAgZGVsZWdhdGVZaWVsZDogZnVuY3Rpb24oaXRlcmFibGUsIHJlc3VsdE5hbWUsIG5leHRMb2MpIHtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSB7XG4gICAgICAgIGl0ZXJhdG9yOiB2YWx1ZXMoaXRlcmFibGUpLFxuICAgICAgICByZXN1bHROYW1lOiByZXN1bHROYW1lLFxuICAgICAgICBuZXh0TG9jOiBuZXh0TG9jXG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5tZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgIC8vIERlbGliZXJhdGVseSBmb3JnZXQgdGhlIGxhc3Qgc2VudCB2YWx1ZSBzbyB0aGF0IHdlIGRvbid0XG4gICAgICAgIC8vIGFjY2lkZW50YWxseSBwYXNzIGl0IG9uIHRvIHRoZSBkZWxlZ2F0ZS5cbiAgICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cbiAgfTtcblxuICAvLyBSZWdhcmRsZXNzIG9mIHdoZXRoZXIgdGhpcyBzY3JpcHQgaXMgZXhlY3V0aW5nIGFzIGEgQ29tbW9uSlMgbW9kdWxlXG4gIC8vIG9yIG5vdCwgcmV0dXJuIHRoZSBydW50aW1lIG9iamVjdCBzbyB0aGF0IHdlIGNhbiBkZWNsYXJlIHRoZSB2YXJpYWJsZVxuICAvLyByZWdlbmVyYXRvclJ1bnRpbWUgaW4gdGhlIG91dGVyIHNjb3BlLCB3aGljaCBhbGxvd3MgdGhpcyBtb2R1bGUgdG8gYmVcbiAgLy8gaW5qZWN0ZWQgZWFzaWx5IGJ5IGBiaW4vcmVnZW5lcmF0b3IgLS1pbmNsdWRlLXJ1bnRpbWUgc2NyaXB0LmpzYC5cbiAgcmV0dXJuIGV4cG9ydHM7XG5cbn0oXG4gIC8vIElmIHRoaXMgc2NyaXB0IGlzIGV4ZWN1dGluZyBhcyBhIENvbW1vbkpTIG1vZHVsZSwgdXNlIG1vZHVsZS5leHBvcnRzXG4gIC8vIGFzIHRoZSByZWdlbmVyYXRvclJ1bnRpbWUgbmFtZXNwYWNlLiBPdGhlcndpc2UgY3JlYXRlIGEgbmV3IGVtcHR5XG4gIC8vIG9iamVjdC4gRWl0aGVyIHdheSwgdGhlIHJlc3VsdGluZyBvYmplY3Qgd2lsbCBiZSB1c2VkIHRvIGluaXRpYWxpemVcbiAgLy8gdGhlIHJlZ2VuZXJhdG9yUnVudGltZSB2YXJpYWJsZSBhdCB0aGUgdG9wIG9mIHRoaXMgZmlsZS5cbiAgdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiA/IG1vZHVsZS5leHBvcnRzIDoge31cbikpO1xuXG50cnkge1xuICByZWdlbmVyYXRvclJ1bnRpbWUgPSBydW50aW1lO1xufSBjYXRjaCAoYWNjaWRlbnRhbFN0cmljdE1vZGUpIHtcbiAgLy8gVGhpcyBtb2R1bGUgc2hvdWxkIG5vdCBiZSBydW5uaW5nIGluIHN0cmljdCBtb2RlLCBzbyB0aGUgYWJvdmVcbiAgLy8gYXNzaWdubWVudCBzaG91bGQgYWx3YXlzIHdvcmsgdW5sZXNzIHNvbWV0aGluZyBpcyBtaXNjb25maWd1cmVkLiBKdXN0XG4gIC8vIGluIGNhc2UgcnVudGltZS5qcyBhY2NpZGVudGFsbHkgcnVucyBpbiBzdHJpY3QgbW9kZSwgd2UgY2FuIGVzY2FwZVxuICAvLyBzdHJpY3QgbW9kZSB1c2luZyBhIGdsb2JhbCBGdW5jdGlvbiBjYWxsLiBUaGlzIGNvdWxkIGNvbmNlaXZhYmx5IGZhaWxcbiAgLy8gaWYgYSBDb250ZW50IFNlY3VyaXR5IFBvbGljeSBmb3JiaWRzIHVzaW5nIEZ1bmN0aW9uLCBidXQgaW4gdGhhdCBjYXNlXG4gIC8vIHRoZSBwcm9wZXIgc29sdXRpb24gaXMgdG8gZml4IHRoZSBhY2NpZGVudGFsIHN0cmljdCBtb2RlIHByb2JsZW0uIElmXG4gIC8vIHlvdSd2ZSBtaXNjb25maWd1cmVkIHlvdXIgYnVuZGxlciB0byBmb3JjZSBzdHJpY3QgbW9kZSBhbmQgYXBwbGllZCBhXG4gIC8vIENTUCB0byBmb3JiaWQgRnVuY3Rpb24sIGFuZCB5b3UncmUgbm90IHdpbGxpbmcgdG8gZml4IGVpdGhlciBvZiB0aG9zZVxuICAvLyBwcm9ibGVtcywgcGxlYXNlIGRldGFpbCB5b3VyIHVuaXF1ZSBwcmVkaWNhbWVudCBpbiBhIEdpdEh1YiBpc3N1ZS5cbiAgRnVuY3Rpb24oXCJyXCIsIFwicmVnZW5lcmF0b3JSdW50aW1lID0gclwiKShydW50aW1lKTtcbn1cbiIsInZhciBiYXNlUGlja0J5ID0gcmVxdWlyZSgnLi9fYmFzZVBpY2tCeScpLFxuICAgIGhhc0luID0gcmVxdWlyZSgnLi9oYXNJbicpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnBpY2tgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaW5kaXZpZHVhbFxuICogcHJvcGVydHkgaWRlbnRpZmllcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBwYXRocyBUaGUgcHJvcGVydHkgcGF0aHMgdG8gcGljay5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGJhc2VQaWNrKG9iamVjdCwgcGF0aHMpIHtcbiAgcmV0dXJuIGJhc2VQaWNrQnkob2JqZWN0LCBwYXRocywgZnVuY3Rpb24odmFsdWUsIHBhdGgpIHtcbiAgICByZXR1cm4gaGFzSW4ob2JqZWN0LCBwYXRoKTtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVBpY2s7XG4iLCJ2YXIgYmFzZUdldCA9IHJlcXVpcmUoJy4vX2Jhc2VHZXQnKSxcbiAgICBiYXNlU2V0ID0gcmVxdWlyZSgnLi9fYmFzZVNldCcpLFxuICAgIGNhc3RQYXRoID0gcmVxdWlyZSgnLi9fY2FzdFBhdGgnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiAgYF8ucGlja0J5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBwYXRocyBUaGUgcHJvcGVydHkgcGF0aHMgdG8gcGljay5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgcHJvcGVydHkuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBiYXNlUGlja0J5KG9iamVjdCwgcGF0aHMsIHByZWRpY2F0ZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHBhdGhzLmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IHt9O1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHBhdGggPSBwYXRoc1tpbmRleF0sXG4gICAgICAgIHZhbHVlID0gYmFzZUdldChvYmplY3QsIHBhdGgpO1xuXG4gICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgcGF0aCkpIHtcbiAgICAgIGJhc2VTZXQocmVzdWx0LCBjYXN0UGF0aChwYXRoLCBvYmplY3QpLCB2YWx1ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVBpY2tCeTtcbiIsInZhciBjYXN0UGF0aCA9IHJlcXVpcmUoJy4vX2Nhc3RQYXRoJyksXG4gICAgdG9LZXkgPSByZXF1aXJlKCcuL190b0tleScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmdldGAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWZhdWx0IHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldChvYmplY3QsIHBhdGgpIHtcbiAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG5cbiAgdmFyIGluZGV4ID0gMCxcbiAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoO1xuXG4gIHdoaWxlIChvYmplY3QgIT0gbnVsbCAmJiBpbmRleCA8IGxlbmd0aCkge1xuICAgIG9iamVjdCA9IG9iamVjdFt0b0tleShwYXRoW2luZGV4KytdKV07XG4gIH1cbiAgcmV0dXJuIChpbmRleCAmJiBpbmRleCA9PSBsZW5ndGgpID8gb2JqZWN0IDogdW5kZWZpbmVkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VHZXQ7XG4iLCJ2YXIgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzU3ltYm9sID0gcmVxdWlyZSgnLi9pc1N5bWJvbCcpO1xuXG4vKiogVXNlZCB0byBtYXRjaCBwcm9wZXJ0eSBuYW1lcyB3aXRoaW4gcHJvcGVydHkgcGF0aHMuICovXG52YXIgcmVJc0RlZXBQcm9wID0gL1xcLnxcXFsoPzpbXltcXF1dKnwoW1wiJ10pKD86KD8hXFwxKVteXFxcXF18XFxcXC4pKj9cXDEpXFxdLyxcbiAgICByZUlzUGxhaW5Qcm9wID0gL15cXHcqJC87XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBwcm9wZXJ0eSBuYW1lIGFuZCBub3QgYSBwcm9wZXJ0eSBwYXRoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5IGtleXMgb24uXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3BlcnR5IG5hbWUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNLZXkodmFsdWUsIG9iamVjdCkge1xuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIGlmICh0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicgfHxcbiAgICAgIHZhbHVlID09IG51bGwgfHwgaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIHJlSXNQbGFpblByb3AudGVzdCh2YWx1ZSkgfHwgIXJlSXNEZWVwUHJvcC50ZXN0KHZhbHVlKSB8fFxuICAgIChvYmplY3QgIT0gbnVsbCAmJiB2YWx1ZSBpbiBPYmplY3Qob2JqZWN0KSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNLZXk7XG4iLCJ2YXIgbWVtb2l6ZUNhcHBlZCA9IHJlcXVpcmUoJy4vX21lbW9pemVDYXBwZWQnKTtcblxuLyoqIFVzZWQgdG8gbWF0Y2ggcHJvcGVydHkgbmFtZXMgd2l0aGluIHByb3BlcnR5IHBhdGhzLiAqL1xudmFyIHJlUHJvcE5hbWUgPSAvW14uW1xcXV0rfFxcWyg/OigtP1xcZCsoPzpcXC5cXGQrKT8pfChbXCInXSkoKD86KD8hXFwyKVteXFxcXF18XFxcXC4pKj8pXFwyKVxcXXwoPz0oPzpcXC58XFxbXFxdKSg/OlxcLnxcXFtcXF18JCkpL2c7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIGJhY2tzbGFzaGVzIGluIHByb3BlcnR5IHBhdGhzLiAqL1xudmFyIHJlRXNjYXBlQ2hhciA9IC9cXFxcKFxcXFwpPy9nO1xuXG4vKipcbiAqIENvbnZlcnRzIGBzdHJpbmdgIHRvIGEgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHByb3BlcnR5IHBhdGggYXJyYXkuXG4gKi9cbnZhciBzdHJpbmdUb1BhdGggPSBtZW1vaXplQ2FwcGVkKGZ1bmN0aW9uKHN0cmluZykge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGlmIChzdHJpbmcuY2hhckNvZGVBdCgwKSA9PT0gNDYgLyogLiAqLykge1xuICAgIHJlc3VsdC5wdXNoKCcnKTtcbiAgfVxuICBzdHJpbmcucmVwbGFjZShyZVByb3BOYW1lLCBmdW5jdGlvbihtYXRjaCwgbnVtYmVyLCBxdW90ZSwgc3ViU3RyaW5nKSB7XG4gICAgcmVzdWx0LnB1c2gocXVvdGUgPyBzdWJTdHJpbmcucmVwbGFjZShyZUVzY2FwZUNoYXIsICckMScpIDogKG51bWJlciB8fCBtYXRjaCkpO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHN0cmluZ1RvUGF0aDtcbiIsInZhciBtZW1vaXplID0gcmVxdWlyZSgnLi9tZW1vaXplJyk7XG5cbi8qKiBVc2VkIGFzIHRoZSBtYXhpbXVtIG1lbW9pemUgY2FjaGUgc2l6ZS4gKi9cbnZhciBNQVhfTUVNT0laRV9TSVpFID0gNTAwO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5tZW1vaXplYCB3aGljaCBjbGVhcnMgdGhlIG1lbW9pemVkIGZ1bmN0aW9uJ3NcbiAqIGNhY2hlIHdoZW4gaXQgZXhjZWVkcyBgTUFYX01FTU9JWkVfU0laRWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGhhdmUgaXRzIG91dHB1dCBtZW1vaXplZC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1lbW9pemVkIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBtZW1vaXplQ2FwcGVkKGZ1bmMpIHtcbiAgdmFyIHJlc3VsdCA9IG1lbW9pemUoZnVuYywgZnVuY3Rpb24oa2V5KSB7XG4gICAgaWYgKGNhY2hlLnNpemUgPT09IE1BWF9NRU1PSVpFX1NJWkUpIHtcbiAgICAgIGNhY2hlLmNsZWFyKCk7XG4gICAgfVxuICAgIHJldHVybiBrZXk7XG4gIH0pO1xuXG4gIHZhciBjYWNoZSA9IHJlc3VsdC5jYWNoZTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtZW1vaXplQ2FwcGVkO1xuIiwidmFyIE1hcENhY2hlID0gcmVxdWlyZSgnLi9fTWFwQ2FjaGUnKTtcblxuLyoqIEVycm9yIG1lc3NhZ2UgY29uc3RhbnRzLiAqL1xudmFyIEZVTkNfRVJST1JfVEVYVCA9ICdFeHBlY3RlZCBhIGZ1bmN0aW9uJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBtZW1vaXplcyB0aGUgcmVzdWx0IG9mIGBmdW5jYC4gSWYgYHJlc29sdmVyYCBpc1xuICogcHJvdmlkZWQsIGl0IGRldGVybWluZXMgdGhlIGNhY2hlIGtleSBmb3Igc3RvcmluZyB0aGUgcmVzdWx0IGJhc2VkIG9uIHRoZVxuICogYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbi4gQnkgZGVmYXVsdCwgdGhlIGZpcnN0IGFyZ3VtZW50XG4gKiBwcm92aWRlZCB0byB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24gaXMgdXNlZCBhcyB0aGUgbWFwIGNhY2hlIGtleS4gVGhlIGBmdW5jYFxuICogaXMgaW52b2tlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gKlxuICogKipOb3RlOioqIFRoZSBjYWNoZSBpcyBleHBvc2VkIGFzIHRoZSBgY2FjaGVgIHByb3BlcnR5IG9uIHRoZSBtZW1vaXplZFxuICogZnVuY3Rpb24uIEl0cyBjcmVhdGlvbiBtYXkgYmUgY3VzdG9taXplZCBieSByZXBsYWNpbmcgdGhlIGBfLm1lbW9pemUuQ2FjaGVgXG4gKiBjb25zdHJ1Y3RvciB3aXRoIG9uZSB3aG9zZSBpbnN0YW5jZXMgaW1wbGVtZW50IHRoZVxuICogW2BNYXBgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wcm9wZXJ0aWVzLW9mLXRoZS1tYXAtcHJvdG90eXBlLW9iamVjdClcbiAqIG1ldGhvZCBpbnRlcmZhY2Ugb2YgYGNsZWFyYCwgYGRlbGV0ZWAsIGBnZXRgLCBgaGFzYCwgYW5kIGBzZXRgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaGF2ZSBpdHMgb3V0cHV0IG1lbW9pemVkLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jlc29sdmVyXSBUaGUgZnVuY3Rpb24gdG8gcmVzb2x2ZSB0aGUgY2FjaGUga2V5LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAyIH07XG4gKiB2YXIgb3RoZXIgPSB7ICdjJzogMywgJ2QnOiA0IH07XG4gKlxuICogdmFyIHZhbHVlcyA9IF8ubWVtb2l6ZShfLnZhbHVlcyk7XG4gKiB2YWx1ZXMob2JqZWN0KTtcbiAqIC8vID0+IFsxLCAyXVxuICpcbiAqIHZhbHVlcyhvdGhlcik7XG4gKiAvLyA9PiBbMywgNF1cbiAqXG4gKiBvYmplY3QuYSA9IDI7XG4gKiB2YWx1ZXMob2JqZWN0KTtcbiAqIC8vID0+IFsxLCAyXVxuICpcbiAqIC8vIE1vZGlmeSB0aGUgcmVzdWx0IGNhY2hlLlxuICogdmFsdWVzLmNhY2hlLnNldChvYmplY3QsIFsnYScsICdiJ10pO1xuICogdmFsdWVzKG9iamVjdCk7XG4gKiAvLyA9PiBbJ2EnLCAnYiddXG4gKlxuICogLy8gUmVwbGFjZSBgXy5tZW1vaXplLkNhY2hlYC5cbiAqIF8ubWVtb2l6ZS5DYWNoZSA9IFdlYWtNYXA7XG4gKi9cbmZ1bmN0aW9uIG1lbW9pemUoZnVuYywgcmVzb2x2ZXIpIHtcbiAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicgfHwgKHJlc29sdmVyICE9IG51bGwgJiYgdHlwZW9mIHJlc29sdmVyICE9ICdmdW5jdGlvbicpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICB9XG4gIHZhciBtZW1vaXplZCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICBrZXkgPSByZXNvbHZlciA/IHJlc29sdmVyLmFwcGx5KHRoaXMsIGFyZ3MpIDogYXJnc1swXSxcbiAgICAgICAgY2FjaGUgPSBtZW1vaXplZC5jYWNoZTtcblxuICAgIGlmIChjYWNoZS5oYXMoa2V5KSkge1xuICAgICAgcmV0dXJuIGNhY2hlLmdldChrZXkpO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICBtZW1vaXplZC5jYWNoZSA9IGNhY2hlLnNldChrZXksIHJlc3VsdCkgfHwgY2FjaGU7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgbWVtb2l6ZWQuY2FjaGUgPSBuZXcgKG1lbW9pemUuQ2FjaGUgfHwgTWFwQ2FjaGUpO1xuICByZXR1cm4gbWVtb2l6ZWQ7XG59XG5cbi8vIEV4cG9zZSBgTWFwQ2FjaGVgLlxubWVtb2l6ZS5DYWNoZSA9IE1hcENhY2hlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG1lbW9pemU7XG4iLCJ2YXIgYmFzZVRvU3RyaW5nID0gcmVxdWlyZSgnLi9fYmFzZVRvU3RyaW5nJyk7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZy4gQW4gZW1wdHkgc3RyaW5nIGlzIHJldHVybmVkIGZvciBgbnVsbGBcbiAqIGFuZCBgdW5kZWZpbmVkYCB2YWx1ZXMuIFRoZSBzaWduIG9mIGAtMGAgaXMgcHJlc2VydmVkLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b1N0cmluZyhudWxsKTtcbiAqIC8vID0+ICcnXG4gKlxuICogXy50b1N0cmluZygtMCk7XG4gKiAvLyA9PiAnLTAnXG4gKlxuICogXy50b1N0cmluZyhbMSwgMiwgM10pO1xuICogLy8gPT4gJzEsMiwzJ1xuICovXG5mdW5jdGlvbiB0b1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/ICcnIDogYmFzZVRvU3RyaW5nKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b1N0cmluZztcbiIsInZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19TeW1ib2wnKSxcbiAgICBhcnJheU1hcCA9IHJlcXVpcmUoJy4vX2FycmF5TWFwJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzU3ltYm9sID0gcmVxdWlyZSgnLi9pc1N5bWJvbCcpO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBJTkZJTklUWSA9IDEgLyAwO1xuXG4vKiogVXNlZCB0byBjb252ZXJ0IHN5bWJvbHMgdG8gcHJpbWl0aXZlcyBhbmQgc3RyaW5ncy4gKi9cbnZhciBzeW1ib2xQcm90byA9IFN5bWJvbCA/IFN5bWJvbC5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG4gICAgc3ltYm9sVG9TdHJpbmcgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnRvU3RyaW5nIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRvU3RyaW5nYCB3aGljaCBkb2Vzbid0IGNvbnZlcnQgbnVsbGlzaFxuICogdmFsdWVzIHRvIGVtcHR5IHN0cmluZ3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGJhc2VUb1N0cmluZyh2YWx1ZSkge1xuICAvLyBFeGl0IGVhcmx5IGZvciBzdHJpbmdzIHRvIGF2b2lkIGEgcGVyZm9ybWFuY2UgaGl0IGluIHNvbWUgZW52aXJvbm1lbnRzLlxuICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbnZlcnQgdmFsdWVzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgcmV0dXJuIGFycmF5TWFwKHZhbHVlLCBiYXNlVG9TdHJpbmcpICsgJyc7XG4gIH1cbiAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiBzeW1ib2xUb1N0cmluZyA/IHN5bWJvbFRvU3RyaW5nLmNhbGwodmFsdWUpIDogJyc7XG4gIH1cbiAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VUb1N0cmluZztcbiIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLm1hcGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlXG4gKiBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBhcnJheU1hcChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlNYXA7XG4iLCJ2YXIgYXNzaWduVmFsdWUgPSByZXF1aXJlKCcuL19hc3NpZ25WYWx1ZScpLFxuICAgIGNhc3RQYXRoID0gcmVxdWlyZSgnLi9fY2FzdFBhdGgnKSxcbiAgICBpc0luZGV4ID0gcmVxdWlyZSgnLi9faXNJbmRleCcpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpLFxuICAgIHRvS2V5ID0gcmVxdWlyZSgnLi9fdG9LZXknKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zZXRgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIHBhdGggY3JlYXRpb24uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBiYXNlU2V0KG9iamVjdCwgcGF0aCwgdmFsdWUsIGN1c3RvbWl6ZXIpIHtcbiAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfVxuICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcblxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoLFxuICAgICAgbGFzdEluZGV4ID0gbGVuZ3RoIC0gMSxcbiAgICAgIG5lc3RlZCA9IG9iamVjdDtcblxuICB3aGlsZSAobmVzdGVkICE9IG51bGwgJiYgKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBrZXkgPSB0b0tleShwYXRoW2luZGV4XSksXG4gICAgICAgIG5ld1ZhbHVlID0gdmFsdWU7XG5cbiAgICBpZiAoa2V5ID09PSAnX19wcm90b19fJyB8fCBrZXkgPT09ICdjb25zdHJ1Y3RvcicgfHwga2V5ID09PSAncHJvdG90eXBlJykge1xuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG5cbiAgICBpZiAoaW5kZXggIT0gbGFzdEluZGV4KSB7XG4gICAgICB2YXIgb2JqVmFsdWUgPSBuZXN0ZWRba2V5XTtcbiAgICAgIG5ld1ZhbHVlID0gY3VzdG9taXplciA/IGN1c3RvbWl6ZXIob2JqVmFsdWUsIGtleSwgbmVzdGVkKSA6IHVuZGVmaW5lZDtcbiAgICAgIGlmIChuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG5ld1ZhbHVlID0gaXNPYmplY3Qob2JqVmFsdWUpXG4gICAgICAgICAgPyBvYmpWYWx1ZVxuICAgICAgICAgIDogKGlzSW5kZXgocGF0aFtpbmRleCArIDFdKSA/IFtdIDoge30pO1xuICAgICAgfVxuICAgIH1cbiAgICBhc3NpZ25WYWx1ZShuZXN0ZWQsIGtleSwgbmV3VmFsdWUpO1xuICAgIG5lc3RlZCA9IG5lc3RlZFtrZXldO1xuICB9XG4gIHJldHVybiBvYmplY3Q7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVNldDtcbiIsInZhciBiYXNlSGFzSW4gPSByZXF1aXJlKCcuL19iYXNlSGFzSW4nKSxcbiAgICBoYXNQYXRoID0gcmVxdWlyZSgnLi9faGFzUGF0aCcpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgcGF0aGAgaXMgYSBkaXJlY3Qgb3IgaW5oZXJpdGVkIHByb3BlcnR5IG9mIGBvYmplY3RgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBwYXRoYCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IF8uY3JlYXRlKHsgJ2EnOiBfLmNyZWF0ZSh7ICdiJzogMiB9KSB9KTtcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgJ2EnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgJ2EuYicpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaGFzSW4ob2JqZWN0LCBbJ2EnLCAnYiddKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgJ2InKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGhhc0luKG9iamVjdCwgcGF0aCkge1xuICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYgaGFzUGF0aChvYmplY3QsIHBhdGgsIGJhc2VIYXNJbik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzSW47XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmhhc0luYCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IGtleSBUaGUga2V5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSGFzSW4ob2JqZWN0LCBrZXkpIHtcbiAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGtleSBpbiBPYmplY3Qob2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSGFzSW47XG4iLCJ2YXIgY2FzdFBhdGggPSByZXF1aXJlKCcuL19jYXN0UGF0aCcpLFxuICAgIGlzQXJndW1lbnRzID0gcmVxdWlyZSgnLi9pc0FyZ3VtZW50cycpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc0luZGV4ID0gcmVxdWlyZSgnLi9faXNJbmRleCcpLFxuICAgIGlzTGVuZ3RoID0gcmVxdWlyZSgnLi9pc0xlbmd0aCcpLFxuICAgIHRvS2V5ID0gcmVxdWlyZSgnLi9fdG9LZXknKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHBhdGhgIGV4aXN0cyBvbiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggdG8gY2hlY2suXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYXNGdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjayBwcm9wZXJ0aWVzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBwYXRoYCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzUGF0aChvYmplY3QsIHBhdGgsIGhhc0Z1bmMpIHtcbiAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG5cbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGtleSA9IHRvS2V5KHBhdGhbaW5kZXhdKTtcbiAgICBpZiAoIShyZXN1bHQgPSBvYmplY3QgIT0gbnVsbCAmJiBoYXNGdW5jKG9iamVjdCwga2V5KSkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBvYmplY3QgPSBvYmplY3Rba2V5XTtcbiAgfVxuICBpZiAocmVzdWx0IHx8ICsraW5kZXggIT0gbGVuZ3RoKSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBsZW5ndGggPSBvYmplY3QgPT0gbnVsbCA/IDAgOiBvYmplY3QubGVuZ3RoO1xuICByZXR1cm4gISFsZW5ndGggJiYgaXNMZW5ndGgobGVuZ3RoKSAmJiBpc0luZGV4KGtleSwgbGVuZ3RoKSAmJlxuICAgIChpc0FycmF5KG9iamVjdCkgfHwgaXNBcmd1bWVudHMob2JqZWN0KSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzUGF0aDtcbiIsInZhciBmbGF0dGVuID0gcmVxdWlyZSgnLi9mbGF0dGVuJyksXG4gICAgb3ZlclJlc3QgPSByZXF1aXJlKCcuL19vdmVyUmVzdCcpLFxuICAgIHNldFRvU3RyaW5nID0gcmVxdWlyZSgnLi9fc2V0VG9TdHJpbmcnKTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VSZXN0YCB3aGljaCBmbGF0dGVucyB0aGUgcmVzdCBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBmbGF0UmVzdChmdW5jKSB7XG4gIHJldHVybiBzZXRUb1N0cmluZyhvdmVyUmVzdChmdW5jLCB1bmRlZmluZWQsIGZsYXR0ZW4pLCBmdW5jICsgJycpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZsYXRSZXN0O1xuIiwidmFyIGJhc2VGbGF0dGVuID0gcmVxdWlyZSgnLi9fYmFzZUZsYXR0ZW4nKTtcblxuLyoqXG4gKiBGbGF0dGVucyBgYXJyYXlgIGEgc2luZ2xlIGxldmVsIGRlZXAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEFycmF5XG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmxhdHRlbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZsYXR0ZW5lZCBhcnJheS5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5mbGF0dGVuKFsxLCBbMiwgWzMsIFs0XV0sIDVdXSk7XG4gKiAvLyA9PiBbMSwgMiwgWzMsIFs0XV0sIDVdXG4gKi9cbmZ1bmN0aW9uIGZsYXR0ZW4oYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICByZXR1cm4gbGVuZ3RoID8gYmFzZUZsYXR0ZW4oYXJyYXksIDEpIDogW107XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZmxhdHRlbjtcbiIsInZhciBhcnJheVB1c2ggPSByZXF1aXJlKCcuL19hcnJheVB1c2gnKSxcbiAgICBpc0ZsYXR0ZW5hYmxlID0gcmVxdWlyZSgnLi9faXNGbGF0dGVuYWJsZScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZsYXR0ZW5gIHdpdGggc3VwcG9ydCBmb3IgcmVzdHJpY3RpbmcgZmxhdHRlbmluZy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZsYXR0ZW4uXG4gKiBAcGFyYW0ge251bWJlcn0gZGVwdGggVGhlIG1heGltdW0gcmVjdXJzaW9uIGRlcHRoLlxuICogQHBhcmFtIHtib29sZWFufSBbcHJlZGljYXRlPWlzRmxhdHRlbmFibGVdIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc1N0cmljdF0gUmVzdHJpY3QgdG8gdmFsdWVzIHRoYXQgcGFzcyBgcHJlZGljYXRlYCBjaGVja3MuXG4gKiBAcGFyYW0ge0FycmF5fSBbcmVzdWx0PVtdXSBUaGUgaW5pdGlhbCByZXN1bHQgdmFsdWUuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGJhc2VGbGF0dGVuKGFycmF5LCBkZXB0aCwgcHJlZGljYXRlLCBpc1N0cmljdCwgcmVzdWx0KSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gIHByZWRpY2F0ZSB8fCAocHJlZGljYXRlID0gaXNGbGF0dGVuYWJsZSk7XG4gIHJlc3VsdCB8fCAocmVzdWx0ID0gW10pO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgIGlmIChkZXB0aCA+IDAgJiYgcHJlZGljYXRlKHZhbHVlKSkge1xuICAgICAgaWYgKGRlcHRoID4gMSkge1xuICAgICAgICAvLyBSZWN1cnNpdmVseSBmbGF0dGVuIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgICBiYXNlRmxhdHRlbih2YWx1ZSwgZGVwdGggLSAxLCBwcmVkaWNhdGUsIGlzU3RyaWN0LCByZXN1bHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXJyYXlQdXNoKHJlc3VsdCwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWlzU3RyaWN0KSB7XG4gICAgICByZXN1bHRbcmVzdWx0Lmxlbmd0aF0gPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlRmxhdHRlbjtcbiIsIi8qKlxuICogQXBwZW5kcyB0aGUgZWxlbWVudHMgb2YgYHZhbHVlc2AgdG8gYGFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIGFwcGVuZC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBhcnJheVB1c2goYXJyYXksIHZhbHVlcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHZhbHVlcy5sZW5ndGgsXG4gICAgICBvZmZzZXQgPSBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBhcnJheVtvZmZzZXQgKyBpbmRleF0gPSB2YWx1ZXNbaW5kZXhdO1xuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheVB1c2g7XG4iLCJ2YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fU3ltYm9sJyksXG4gICAgaXNBcmd1bWVudHMgPSByZXF1aXJlKCcuL2lzQXJndW1lbnRzJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzcHJlYWRhYmxlU3ltYm9sID0gU3ltYm9sID8gU3ltYm9sLmlzQ29uY2F0U3ByZWFkYWJsZSA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGZsYXR0ZW5hYmxlIGBhcmd1bWVudHNgIG9iamVjdCBvciBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBmbGF0dGVuYWJsZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0ZsYXR0ZW5hYmxlKHZhbHVlKSB7XG4gIHJldHVybiBpc0FycmF5KHZhbHVlKSB8fCBpc0FyZ3VtZW50cyh2YWx1ZSkgfHxcbiAgICAhIShzcHJlYWRhYmxlU3ltYm9sICYmIHZhbHVlICYmIHZhbHVlW3NwcmVhZGFibGVTeW1ib2xdKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0ZsYXR0ZW5hYmxlO1xuIiwiZnVuY3Rpb24gX2lzTmF0aXZlRnVuY3Rpb24oZm4pIHtcbiAgcmV0dXJuIEZ1bmN0aW9uLnRvU3RyaW5nLmNhbGwoZm4pLmluZGV4T2YoXCJbbmF0aXZlIGNvZGVdXCIpICE9PSAtMTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfaXNOYXRpdmVGdW5jdGlvbjtcbm1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsiLCJ2YXIgc2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKFwiLi9zZXRQcm90b3R5cGVPZi5qc1wiKTtcblxudmFyIGlzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IHJlcXVpcmUoXCIuL2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdC5qc1wiKTtcblxuZnVuY3Rpb24gX2NvbnN0cnVjdChQYXJlbnQsIGFyZ3MsIENsYXNzKSB7XG4gIGlmIChpc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSkge1xuICAgIG1vZHVsZS5leHBvcnRzID0gX2NvbnN0cnVjdCA9IFJlZmxlY3QuY29uc3RydWN0O1xuICAgIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IF9jb25zdHJ1Y3QgPSBmdW5jdGlvbiBfY29uc3RydWN0KFBhcmVudCwgYXJncywgQ2xhc3MpIHtcbiAgICAgIHZhciBhID0gW251bGxdO1xuICAgICAgYS5wdXNoLmFwcGx5KGEsIGFyZ3MpO1xuICAgICAgdmFyIENvbnN0cnVjdG9yID0gRnVuY3Rpb24uYmluZC5hcHBseShQYXJlbnQsIGEpO1xuICAgICAgdmFyIGluc3RhbmNlID0gbmV3IENvbnN0cnVjdG9yKCk7XG4gICAgICBpZiAoQ2xhc3MpIHNldFByb3RvdHlwZU9mKGluc3RhbmNlLCBDbGFzcy5wcm90b3R5cGUpO1xuICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG4gIH1cblxuICByZXR1cm4gX2NvbnN0cnVjdC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9jb25zdHJ1Y3Q7XG5tb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7IiwiZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHtcbiAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlO1xuICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlO1xuICBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlO1xuXG4gIHRyeSB7XG4gICAgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdDtcbm1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsiLCJtb2R1bGUuZXhwb3J0cyA9IGRldGVybWluYW50XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZGV0ZXJtaW5hbnQgb2YgYSBtYXQyXG4gKlxuICogQGFsaWFzIG1hdDIuZGV0ZXJtaW5hbnRcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge051bWJlcn0gZGV0ZXJtaW5hbnQgb2YgYVxuICovXG5mdW5jdGlvbiBkZXRlcm1pbmFudChhKSB7XG4gIHJldHVybiBhWzBdICogYVszXSAtIGFbMl0gKiBhWzFdXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHRyYW5zcG9zZVxuXG4vKipcbiAqIFRyYW5zcG9zZSB0aGUgdmFsdWVzIG9mIGEgbWF0MlxuICpcbiAqIEBhbGlhcyBtYXQyLnRyYW5zcG9zZVxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5mdW5jdGlvbiB0cmFuc3Bvc2Uob3V0LCBhKSB7XG4gIC8vIElmIHdlIGFyZSB0cmFuc3Bvc2luZyBvdXJzZWx2ZXMgd2UgY2FuIHNraXAgYSBmZXcgc3RlcHMgYnV0IGhhdmUgdG8gY2FjaGUgc29tZSB2YWx1ZXNcbiAgaWYgKG91dCA9PT0gYSkge1xuICAgIHZhciBhMSA9IGFbMV1cbiAgICBvdXRbMV0gPSBhWzJdXG4gICAgb3V0WzJdID0gYTFcbiAgfSBlbHNlIHtcbiAgICBvdXRbMF0gPSBhWzBdXG4gICAgb3V0WzFdID0gYVsyXVxuICAgIG91dFsyXSA9IGFbMV1cbiAgICBvdXRbM10gPSBhWzNdXG4gIH1cblxuICByZXR1cm4gb3V0XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IG11bHRpcGx5XG5cbi8qKlxuICogTXVsdGlwbGllcyB0d28gbWF0MidzXG4gKlxuICogQGFsaWFzIG1hdDIubXVsdGlwbHlcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7bWF0Mn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xuZnVuY3Rpb24gbXVsdGlwbHkob3V0LCBhLCBiKSB7XG4gIHZhciBhMCA9IGFbMF0sIGExID0gYVsxXSwgYTIgPSBhWzJdLCBhMyA9IGFbM11cbiAgdmFyIGIwID0gYlswXSwgYjEgPSBiWzFdLCBiMiA9IGJbMl0sIGIzID0gYlszXVxuICBvdXRbMF0gPSBhMCAqIGIwICsgYTIgKiBiMVxuICBvdXRbMV0gPSBhMSAqIGIwICsgYTMgKiBiMVxuICBvdXRbMl0gPSBhMCAqIGIyICsgYTIgKiBiM1xuICBvdXRbM10gPSBhMSAqIGIyICsgYTMgKiBiM1xuICByZXR1cm4gb3V0XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGlkZW50aXR5XG5cbi8qKlxuICogU2V0IGEgbWF0MiB0byB0aGUgaWRlbnRpdHkgbWF0cml4XG4gKlxuICogQGFsaWFzIG1hdDIuaWRlbnRpdHlcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKi9cbmZ1bmN0aW9uIGlkZW50aXR5KG91dCkge1xuICBvdXRbMF0gPSAxXG4gIG91dFsxXSA9IDBcbiAgb3V0WzJdID0gMFxuICBvdXRbM10gPSAxXG4gIHJldHVybiBvdXRcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gYWRqb2ludFxuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGFkanVnYXRlIG9mIGEgbWF0MlxuICpcbiAqIEBhbGlhcyBtYXQyLmFkam9pbnRcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xuZnVuY3Rpb24gYWRqb2ludChvdXQsIGEpIHtcbiAgLy8gQ2FjaGluZyB0aGlzIHZhbHVlIGlzIG5lc3NlY2FyeSBpZiBvdXQgPT0gYVxuICB2YXIgYTAgPSAgYVswXVxuICBvdXRbMF0gPSAgYVszXVxuICBvdXRbMV0gPSAtYVsxXVxuICBvdXRbMl0gPSAtYVsyXVxuICBvdXRbM10gPSAgYTBcblxuICByZXR1cm4gb3V0XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJvdGF0ZVxuXG4vKipcbiAqIFJvdGF0ZXMgYSBtYXQyIGJ5IHRoZSBnaXZlbiBhbmdsZVxuICpcbiAqIEBhbGlhcyBtYXQyLnJvdGF0ZVxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xuZnVuY3Rpb24gcm90YXRlKG91dCwgYSwgcmFkKSB7XG4gIHZhciBhMCA9IGFbMF0sIGExID0gYVsxXSwgYTIgPSBhWzJdLCBhMyA9IGFbM11cbiAgdmFyIHMgPSBNYXRoLnNpbihyYWQpXG4gIHZhciBjID0gTWF0aC5jb3MocmFkKVxuICBvdXRbMF0gPSBhMCAqICBjICsgYTIgKiBzXG4gIG91dFsxXSA9IGExICogIGMgKyBhMyAqIHNcbiAgb3V0WzJdID0gYTAgKiAtcyArIGEyICogY1xuICBvdXRbM10gPSBhMSAqIC1zICsgYTMgKiBjXG4gIHJldHVybiBvdXRcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gaW52ZXJ0XG5cbi8qKlxuICogSW52ZXJ0cyBhIG1hdDJcbiAqXG4gKiBAYWxpYXMgbWF0Mi5pbnZlcnRcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xuZnVuY3Rpb24gaW52ZXJ0KG91dCwgYSkge1xuICB2YXIgYTAgPSBhWzBdXG4gIHZhciBhMSA9IGFbMV1cbiAgdmFyIGEyID0gYVsyXVxuICB2YXIgYTMgPSBhWzNdXG4gIHZhciBkZXQgPSBhMCAqIGEzIC0gYTIgKiBhMVxuXG4gIGlmICghZGV0KSByZXR1cm4gbnVsbFxuICBkZXQgPSAxLjAgLyBkZXRcblxuICBvdXRbMF0gPSAgYTMgKiBkZXRcbiAgb3V0WzFdID0gLWExICogZGV0XG4gIG91dFsyXSA9IC1hMiAqIGRldFxuICBvdXRbM10gPSAgYTAgKiBkZXRcblxuICByZXR1cm4gb3V0XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgaWRlbnRpdHkgbWF0MlxuICpcbiAqIEBhbGlhcyBtYXQyLmNyZWF0ZVxuICogQHJldHVybnMge21hdDJ9IGEgbmV3IDJ4MiBtYXRyaXhcbiAqL1xuZnVuY3Rpb24gY3JlYXRlKCkge1xuICB2YXIgb3V0ID0gbmV3IEZsb2F0MzJBcnJheSg0KVxuICBvdXRbMF0gPSAxXG4gIG91dFsxXSA9IDBcbiAgb3V0WzJdID0gMFxuICBvdXRbM10gPSAxXG4gIHJldHVybiBvdXRcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gc2NhbGVcblxuLyoqXG4gKiBTY2FsZXMgdGhlIG1hdDIgYnkgdGhlIGRpbWVuc2lvbnMgaW4gdGhlIGdpdmVuIHZlYzJcbiAqXG4gKiBAYWxpYXMgbWF0Mi5zY2FsZVxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxuICogQHBhcmFtIHt2ZWMyfSB2IHRoZSB2ZWMyIHRvIHNjYWxlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqKi9cbmZ1bmN0aW9uIHNjYWxlKG91dCwgYSwgdikge1xuICB2YXIgYTAgPSBhWzBdLCBhMSA9IGFbMV0sIGEyID0gYVsyXSwgYTMgPSBhWzNdXG4gIHZhciB2MCA9IHZbMF0sIHYxID0gdlsxXVxuICBvdXRbMF0gPSBhMCAqIHYwXG4gIG91dFsxXSA9IGExICogdjBcbiAgb3V0WzJdID0gYTIgKiB2MVxuICBvdXRbM10gPSBhMyAqIHYxXG4gIHJldHVybiBvdXRcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gY29weVxuXG4vKipcbiAqIENvcHkgdGhlIHZhbHVlcyBmcm9tIG9uZSBtYXQyIHRvIGFub3RoZXJcbiAqXG4gKiBAYWxpYXMgbWF0Mi5jb3B5XG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKi9cbmZ1bmN0aW9uIGNvcHkob3V0LCBhKSB7XG4gIG91dFswXSA9IGFbMF1cbiAgb3V0WzFdID0gYVsxXVxuICBvdXRbMl0gPSBhWzJdXG4gIG91dFszXSA9IGFbM11cbiAgcmV0dXJuIG91dFxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBmcm9iXG5cbi8qKlxuICogUmV0dXJucyBGcm9iZW5pdXMgbm9ybSBvZiBhIG1hdDJcbiAqXG4gKiBAYWxpYXMgbWF0Mi5mcm9iXG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIG1hdHJpeCB0byBjYWxjdWxhdGUgRnJvYmVuaXVzIG5vcm0gb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IEZyb2Jlbml1cyBub3JtXG4gKi9cbmZ1bmN0aW9uIGZyb2IoYSkge1xuICByZXR1cm4gTWF0aC5zcXJ0KFxuICAgIE1hdGgucG93KGFbMF0sIDIpICtcbiAgICBNYXRoLnBvdyhhWzFdLCAyKSArXG4gICAgTWF0aC5wb3coYVsyXSwgMikgK1xuICAgIE1hdGgucG93KGFbM10sIDIpXG4gIClcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gbGR1XG5cbi8qKlxuICogUmV0dXJucyBMLCBEIGFuZCBVIG1hdHJpY2VzIChMb3dlciB0cmlhbmd1bGFyLCBEaWFnb25hbCBhbmQgVXBwZXIgdHJpYW5ndWxhcikgYnkgZmFjdG9yaXppbmcgdGhlIGlucHV0IG1hdHJpeFxuICpcbiAqIEBhbGlhcyBtYXQyLmxkdVxuICogQHBhcmFtIHttYXQyfSBMIHRoZSBsb3dlciB0cmlhbmd1bGFyIG1hdHJpeFxuICogQHBhcmFtIHttYXQyfSBEIHRoZSBkaWFnb25hbCBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0Mn0gVSB0aGUgdXBwZXIgdHJpYW5ndWxhciBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgaW5wdXQgbWF0cml4IHRvIGZhY3Rvcml6ZVxuICovXG5mdW5jdGlvbiBsZHUoTCwgRCwgVSwgYSkge1xuICBMWzJdID0gYVsyXS9hWzBdXG4gIFVbMF0gPSBhWzBdXG4gIFVbMV0gPSBhWzFdXG4gIFVbM10gPSBhWzNdIC0gTFsyXSAqIFVbMV1cbiAgcmV0dXJuIFtMLCBELCBVXVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwibmRhcnJheVwiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJuZGFycmF5LWxpbmVhci1pbnRlcnBvbGF0ZVwiKTsiLCJjb25zdCBCcmVzZW5oYW0gPSB7fTtcclxuXHJcbmNvbnN0IFNsb3BlID0ge1xyXG4gICAgRElSOiB7XHJcbiAgICAgICAgVVA6IDEsXHJcbiAgICAgICAgRE9XTjogLTEsXHJcbiAgICB9LFxyXG59O1xyXG4vKipcclxuICogU2NhbnMgYSBsaW5lIG9mIHRoZSBnaXZlbiBpbWFnZSBmcm9tIHBvaW50IHAxIHRvIHAyIGFuZCByZXR1cm5zIGEgcmVzdWx0IG9iamVjdCBjb250YWluaW5nXHJcbiAqIGdyYXktc2NhbGUgdmFsdWVzICgwLTI1NSkgb2YgdGhlIHVuZGVybHlpbmcgcGl4ZWxzIGluIGFkZGl0aW9uIHRvIHRoZSBtaW5cclxuICogYW5kIG1heCB2YWx1ZXMuXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBpbWFnZVdyYXBwZXJcclxuICogQHBhcmFtIHtPYmplY3R9IHAxIFRoZSBzdGFydCBwb2ludCB7eCx5fVxyXG4gKiBAcGFyYW0ge09iamVjdH0gcDIgVGhlIGVuZCBwb2ludCB7eCx5fVxyXG4gKiBAcmV0dXJucyB7bGluZSwgbWluLCBtYXh9XHJcbiAqL1xyXG5CcmVzZW5oYW0uZ2V0QmFyY29kZUxpbmUgPSBmdW5jdGlvbiAoaW1hZ2VXcmFwcGVyLCBwMSwgcDIpIHtcclxuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWJpdHdpc2UgKi9cclxuICAgIGxldCB4MCA9IHAxLnggfCAwO1xyXG4gICAgbGV0IHkwID0gcDEueSB8IDA7XHJcbiAgICBsZXQgeDEgPSBwMi54IHwgMDtcclxuICAgIGxldCB5MSA9IHAyLnkgfCAwO1xyXG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tYml0d2lzZSAqL1xyXG4gICAgY29uc3Qgc3RlZXAgPSBNYXRoLmFicyh5MSAtIHkwKSA+IE1hdGguYWJzKHgxIC0geDApO1xyXG4gICAgbGV0IGVycm9yO1xyXG4gICAgbGV0IHk7XHJcbiAgICBsZXQgdG1wO1xyXG4gICAgbGV0IHg7XHJcbiAgICBjb25zdCBsaW5lID0gW107XHJcbiAgICBjb25zdCBpbWFnZURhdGEgPSBpbWFnZVdyYXBwZXIuZGF0YTtcclxuICAgIGNvbnN0IHdpZHRoID0gaW1hZ2VXcmFwcGVyLnNpemUueDtcclxuICAgIGxldCB2YWw7XHJcbiAgICBsZXQgbWluID0gMjU1O1xyXG4gICAgbGV0IG1heCA9IDA7XHJcblxyXG4gICAgZnVuY3Rpb24gcmVhZChhLCBiKSB7XHJcbiAgICAgICAgdmFsID0gaW1hZ2VEYXRhW2IgKiB3aWR0aCArIGFdO1xyXG4gICAgICAgIG1pbiA9IHZhbCA8IG1pbiA/IHZhbCA6IG1pbjtcclxuICAgICAgICBtYXggPSB2YWwgPiBtYXggPyB2YWwgOiBtYXg7XHJcbiAgICAgICAgbGluZS5wdXNoKHZhbCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHN0ZWVwKSB7XHJcbiAgICAgICAgdG1wID0geDA7XHJcbiAgICAgICAgeDAgPSB5MDtcclxuICAgICAgICB5MCA9IHRtcDtcclxuXHJcbiAgICAgICAgdG1wID0geDE7XHJcbiAgICAgICAgeDEgPSB5MTtcclxuICAgICAgICB5MSA9IHRtcDtcclxuICAgIH1cclxuICAgIGlmICh4MCA+IHgxKSB7XHJcbiAgICAgICAgdG1wID0geDA7XHJcbiAgICAgICAgeDAgPSB4MTtcclxuICAgICAgICB4MSA9IHRtcDtcclxuXHJcbiAgICAgICAgdG1wID0geTA7XHJcbiAgICAgICAgeTAgPSB5MTtcclxuICAgICAgICB5MSA9IHRtcDtcclxuICAgIH1cclxuICAgIGNvbnN0IGRlbHRhWCA9IHgxIC0geDA7XHJcbiAgICBjb25zdCBkZWx0YVkgPSBNYXRoLmFicyh5MSAtIHkwKTtcclxuICAgIGVycm9yID0gKGRlbHRhWCAvIDIpIHwgMDtcclxuICAgIHkgPSB5MDtcclxuICAgIGNvbnN0IHlTdGVwID0geTAgPCB5MSA/IDEgOiAtMTtcclxuICAgIGZvciAoeCA9IHgwOyB4IDwgeDE7IHgrKykge1xyXG4gICAgICAgIGlmIChzdGVlcCkge1xyXG4gICAgICAgICAgICByZWFkKHksIHgpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJlYWQoeCwgeSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVycm9yIC09IGRlbHRhWTtcclxuICAgICAgICBpZiAoZXJyb3IgPCAwKSB7XHJcbiAgICAgICAgICAgIHkgKz0geVN0ZXA7XHJcbiAgICAgICAgICAgIGVycm9yICs9IGRlbHRhWDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBsaW5lLFxyXG4gICAgICAgIG1pbixcclxuICAgICAgICBtYXgsXHJcbiAgICB9O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENvbnZlcnRzIHRoZSByZXN1bHQgZnJvbSBnZXRCYXJjb2RlTGluZSBpbnRvIGEgYmluYXJ5IHJlcHJlc2VudGF0aW9uXHJcbiAqIGFsc28gY29uc2lkZXJpbmcgdGhlIGZyZXF1ZW5jeSBhbmQgc2xvcGUgb2YgdGhlIHNpZ25hbCBmb3IgbW9yZSByb2J1c3QgcmVzdWx0c1xyXG4gKiBAcGFyYW0ge09iamVjdH0gcmVzdWx0IHtsaW5lLCBtaW4sIG1heH1cclxuICovXHJcbkJyZXNlbmhhbS50b0JpbmFyeUxpbmUgPSBmdW5jdGlvbiAocmVzdWx0KSB7XHJcbiAgICBjb25zdCB7IG1pbiB9ID0gcmVzdWx0O1xyXG4gICAgY29uc3QgeyBtYXggfSA9IHJlc3VsdDtcclxuICAgIGNvbnN0IHsgbGluZSB9ID0gcmVzdWx0O1xyXG4gICAgbGV0IHNsb3BlO1xyXG4gICAgbGV0IHNsb3BlMjtcclxuICAgIGNvbnN0IGNlbnRlciA9IG1pbiArIChtYXggLSBtaW4pIC8gMjtcclxuICAgIGNvbnN0IGV4dHJlbWEgPSBbXTtcclxuICAgIGxldCBjdXJyZW50RGlyO1xyXG4gICAgbGV0IGRpcjtcclxuICAgIGxldCB0aHJlc2hvbGQgPSAobWF4IC0gbWluKSAvIDEyO1xyXG4gICAgY29uc3QgclRocmVzaG9sZCA9IC10aHJlc2hvbGQ7XHJcbiAgICBsZXQgaTtcclxuICAgIGxldCBqO1xyXG5cclxuICAgIC8vIDEuIGZpbmQgZXh0cmVtYVxyXG4gICAgY3VycmVudERpciA9IGxpbmVbMF0gPiBjZW50ZXIgPyBTbG9wZS5ESVIuVVAgOiBTbG9wZS5ESVIuRE9XTjtcclxuICAgIGV4dHJlbWEucHVzaCh7XHJcbiAgICAgICAgcG9zOiAwLFxyXG4gICAgICAgIHZhbDogbGluZVswXSxcclxuICAgIH0pO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IGxpbmUubGVuZ3RoIC0gMjsgaSsrKSB7XHJcbiAgICAgICAgc2xvcGUgPSAobGluZVtpICsgMV0gLSBsaW5lW2ldKTtcclxuICAgICAgICBzbG9wZTIgPSAobGluZVtpICsgMl0gLSBsaW5lW2kgKyAxXSk7XHJcbiAgICAgICAgaWYgKChzbG9wZSArIHNsb3BlMikgPCByVGhyZXNob2xkICYmIGxpbmVbaSArIDFdIDwgKGNlbnRlciAqIDEuNSkpIHtcclxuICAgICAgICAgICAgZGlyID0gU2xvcGUuRElSLkRPV047XHJcbiAgICAgICAgfSBlbHNlIGlmICgoc2xvcGUgKyBzbG9wZTIpID4gdGhyZXNob2xkICYmIGxpbmVbaSArIDFdID4gKGNlbnRlciAqIDAuNSkpIHtcclxuICAgICAgICAgICAgZGlyID0gU2xvcGUuRElSLlVQO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGRpciA9IGN1cnJlbnREaXI7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoY3VycmVudERpciAhPT0gZGlyKSB7XHJcbiAgICAgICAgICAgIGV4dHJlbWEucHVzaCh7XHJcbiAgICAgICAgICAgICAgICBwb3M6IGksXHJcbiAgICAgICAgICAgICAgICB2YWw6IGxpbmVbaV0sXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBjdXJyZW50RGlyID0gZGlyO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGV4dHJlbWEucHVzaCh7XHJcbiAgICAgICAgcG9zOiBsaW5lLmxlbmd0aCxcclxuICAgICAgICB2YWw6IGxpbmVbbGluZS5sZW5ndGggLSAxXSxcclxuICAgIH0pO1xyXG5cclxuICAgIGZvciAoaiA9IGV4dHJlbWFbMF0ucG9zOyBqIDwgZXh0cmVtYVsxXS5wb3M7IGorKykge1xyXG4gICAgICAgIGxpbmVbal0gPSBsaW5lW2pdID4gY2VudGVyID8gMCA6IDE7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gaXRlcmF0ZSBvdmVyIGV4dHJlbWEgYW5kIGNvbnZlcnQgdG8gYmluYXJ5IGJhc2VkIG9uIGF2ZyBiZXR3ZWVuIG1pbm1heFxyXG4gICAgZm9yIChpID0gMTsgaSA8IGV4dHJlbWEubGVuZ3RoIC0gMTsgaSsrKSB7XHJcbiAgICAgICAgaWYgKGV4dHJlbWFbaSArIDFdLnZhbCA+IGV4dHJlbWFbaV0udmFsKSB7XHJcbiAgICAgICAgICAgIHRocmVzaG9sZCA9IChleHRyZW1hW2ldLnZhbCArICgoZXh0cmVtYVtpICsgMV0udmFsIC0gZXh0cmVtYVtpXS52YWwpIC8gMykgKiAyKSB8IDA7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhyZXNob2xkID0gKGV4dHJlbWFbaSArIDFdLnZhbCArICgoZXh0cmVtYVtpXS52YWwgLSBleHRyZW1hW2kgKyAxXS52YWwpIC8gMykpIHwgMDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvciAoaiA9IGV4dHJlbWFbaV0ucG9zOyBqIDwgZXh0cmVtYVtpICsgMV0ucG9zOyBqKyspIHtcclxuICAgICAgICAgICAgbGluZVtqXSA9IGxpbmVbal0gPiB0aHJlc2hvbGQgPyAwIDogMTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBsaW5lLFxyXG4gICAgICAgIHRocmVzaG9sZCxcclxuICAgIH07XHJcbn07XHJcblxyXG4vKipcclxuICogVXNlZCBmb3IgZGV2ZWxvcG1lbnQgb25seVxyXG4gKi9cclxuQnJlc2VuaGFtLmRlYnVnID0ge1xyXG4gICAgcHJpbnRGcmVxdWVuY3kobGluZSwgY2FudmFzKSB7XHJcbiAgICAgICAgbGV0IGk7XHJcbiAgICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XHJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXHJcbiAgICAgICAgY2FudmFzLndpZHRoID0gbGluZS5sZW5ndGg7XHJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXHJcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IDI1NjtcclxuXHJcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9ICdibHVlJztcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGluZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjdHgubW92ZVRvKGksIDI1NSk7XHJcbiAgICAgICAgICAgIGN0eC5saW5lVG8oaSwgMjU1IC0gbGluZVtpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGN0eC5zdHJva2UoKTtcclxuICAgICAgICBjdHguY2xvc2VQYXRoKCk7XHJcbiAgICB9LFxyXG5cclxuICAgIHByaW50UGF0dGVybihsaW5lLCBjYW52YXMpIHtcclxuICAgICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTsgbGV0XHJcbiAgICAgICAgICAgIGk7XHJcblxyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxyXG4gICAgICAgIGNhbnZhcy53aWR0aCA9IGxpbmUubGVuZ3RoO1xyXG4gICAgICAgIGN0eC5maWxsQ29sb3IgPSAnYmxhY2snO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsaW5lLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChsaW5lW2ldID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICBjdHguZmlsbFJlY3QoaSwgMCwgMSwgMTAwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBCcmVzZW5oYW07XHJcbiIsImltcG9ydCBBcnJheUhlbHBlciBmcm9tICcuLi9jb21tb24vYXJyYXlfaGVscGVyJztcclxuXHJcbmV4cG9ydCBlbnVtIEJhcmNvZGVEaXJlY3Rpb24ge1xyXG4gICAgRm9yd2FyZCA9IDEsXHJcbiAgICBSZXZlcnNlID0gLTEsXHJcbn07XHJcblxyXG5leHBvcnQgdHlwZSBCYXJjb2RlUmVhZGVyVHlwZSA9IHN0cmluZztcclxuZXhwb3J0IHR5cGUgQmFyY29kZUZvcm1hdCA9IHN0cmluZztcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgQmFyY29kZVJlYWRlckNvbmZpZyB7XHJcbiAgICBub3JtYWxpemVCYXJTcGFjZVdpZHRoPzogYm9vbGVhbixcclxuICAgIHN1cHBsZW1lbnRzPzogQXJyYXk8QmFyY29kZVJlYWRlclR5cGU+LFxyXG59O1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBCYXJjb2RlQ29ycmVjdGlvbiB7XHJcbiAgICBiYXI6IG51bWJlcixcclxuICAgIHNwYWNlOiBudW1iZXIsXHJcbn07XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEJhcmNvZGVQb3NpdGlvbiB7XHJcbiAgICBzdGFydDogbnVtYmVyLFxyXG4gICAgc3RhcnRDb3VudGVyPzogbnVtYmVyLFxyXG4gICAgZW5kOiBudW1iZXIsXHJcbiAgICBlbmRDb3VudGVyPzogbnVtYmVyLFxyXG4gICAgZXJyb3I/OiBudW1iZXIsXHJcbn07XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEJhcmNvZGVJbmZvIGV4dGVuZHMgQmFyY29kZVBvc2l0aW9uIHtcclxuICAgIGNvZGU6IG51bWJlcixcclxuICAgIGNvcnJlY3Rpb24/OiBCYXJjb2RlQ29ycmVjdGlvbixcclxufTtcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgQmFyY29kZSB7XHJcbiAgICBjb2RlOiBzdHJpbmcsXHJcbiAgICBjb2Rlc2V0PzogbnVtYmVyLFxyXG4gICAgY29ycmVjdGlvbj86IEJhcmNvZGVDb3JyZWN0aW9uLFxyXG4gICAgZGVjb2RlZENvZGVzPzogQXJyYXk8c3RyaW5nIHwgQmFyY29kZUluZm8gfCBCYXJjb2RlUG9zaXRpb24+LFxyXG4gICAgZGlyZWN0aW9uPzogQmFyY29kZURpcmVjdGlvbixcclxuICAgIGVuZDogbnVtYmVyLFxyXG4gICAgZW5kSW5mbz86IEJhcmNvZGVQb3NpdGlvbixcclxuICAgIGZvcm1hdDogQmFyY29kZUZvcm1hdCxcclxuICAgIHN0YXJ0OiBudW1iZXIsXHJcbiAgICBzdGFydEluZm86IEJhcmNvZGVQb3NpdGlvbixcclxuICAgIHN1cHBsZW1lbnQ/OiBCYXJjb2RlLFxyXG59O1xyXG5cclxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEJhcmNvZGVSZWFkZXIge1xyXG4gICAgX3JvdzogQXJyYXk8bnVtYmVyPiA9IFtdO1xyXG4gICAgY29uZmlnOiBCYXJjb2RlUmVhZGVyQ29uZmlnID0ge307XHJcbiAgICBzdXBwbGVtZW50czogQXJyYXk8QmFyY29kZVJlYWRlcj4gPSBbXTtcclxuICAgIFNJTkdMRV9DT0RFX0VSUk9SID0gMDtcclxuICAgIEZPUk1BVDogQmFyY29kZUZvcm1hdCA9ICd1bmtub3duJztcclxuICAgIENPTkZJR19LRVlTOiBCYXJjb2RlUmVhZGVyQ29uZmlnID0ge307XHJcbiAgICAvLyBUT0RPOiBzaG91bGQgYWRkIEFMUEhBQkVUSF9TVFJJTkcsIEFMUEhBQkVULCBDSEFSQUNURVJfRU5DT0RJTkdTIHRvIGJhc2UgY2xhc3MsIGlmIHRoZXlcclxuICAgIC8vIGFyZSB1c2VmdWwgaW4gbW9zdCByZWFkZXJzLlxyXG5cclxuICAgIHB1YmxpYyBhYnN0cmFjdCBkZWNvZGUocm93PzogQXJyYXk8bnVtYmVyPiwgc3RhcnQ/OiBCYXJjb2RlUG9zaXRpb24gfCBudW1iZXIpOiBCYXJjb2RlIHwgbnVsbDtcclxuXHJcbiAgICBzdGF0aWMgZ2V0IEV4Y2VwdGlvbigpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBTdGFydE5vdEZvdW5kRXhjZXB0aW9uOiAnU3RhcnQtSW5mbyB3YXMgbm90IGZvdW5kIScsXHJcbiAgICAgICAgICAgIENvZGVOb3RGb3VuZEV4Y2VwdGlvbjogJ0NvZGUgY291bGQgbm90IGJlIGZvdW5kIScsXHJcbiAgICAgICAgICAgIFBhdHRlcm5Ob3RGb3VuZEV4Y2VwdGlvbjogJ1BhdHRlcm4gY291bGQgbm90IGJlIGZvdW5kISdcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZzogQmFyY29kZVJlYWRlckNvbmZpZywgc3VwcGxlbWVudHM/OiBBcnJheTxCYXJjb2RlUmVhZGVyPikge1xyXG5cclxuICAgICAgICB0aGlzLl9yb3cgPSBbXTtcclxuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcclxuICAgICAgICBpZiAoc3VwcGxlbWVudHMpIHtcclxuICAgICAgICAgICAgdGhpcy5zdXBwbGVtZW50cyA9IHN1cHBsZW1lbnRzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgX25leHRVbnNldChsaW5lOiBSZWFkb25seUFycmF5PG51bWJlcj4sIHN0YXJ0OiBudW1iZXIgPSAwKTogbnVtYmVyIHtcclxuICAgICAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBsaW5lLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmICghbGluZVtpXSkgcmV0dXJuIGk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBsaW5lLmxlbmd0aDtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgX21hdGNoUGF0dGVybihjb3VudGVyOiBSZWFkb25seUFycmF5PG51bWJlcj4sIGNvZGU6IFJlYWRvbmx5QXJyYXk8bnVtYmVyPiwgbWF4U2luZ2xlRXJyb3I/OiBudW1iZXIpOiBudW1iZXIge1xyXG4gICAgICAgIGxldCBlcnJvciA9IDA7XHJcbiAgICAgICAgbGV0IHNpbmdsZUVycm9yID0gMDtcclxuICAgICAgICBsZXQgc3VtID0gMDtcclxuICAgICAgICBsZXQgbW9kdWxvID0gMDtcclxuICAgICAgICBsZXQgYmFyV2lkdGggPSAwO1xyXG4gICAgICAgIGxldCBjb3VudCA9IDA7XHJcbiAgICAgICAgbGV0IHNjYWxlZCA9IDA7XHJcblxyXG4gICAgICAgIG1heFNpbmdsZUVycm9yID0gbWF4U2luZ2xlRXJyb3IgfHwgdGhpcy5TSU5HTEVfQ09ERV9FUlJPUiB8fCAxO1xyXG5cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50ZXIubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgc3VtICs9IGNvdW50ZXJbaV07XHJcbiAgICAgICAgICAgIG1vZHVsbyArPSBjb2RlW2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc3VtIDwgbW9kdWxvKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBOdW1iZXIuTUFYX1ZBTFVFO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgYmFyV2lkdGggPSBzdW0gLyBtb2R1bG87XHJcbiAgICAgICAgbWF4U2luZ2xlRXJyb3IgKj0gYmFyV2lkdGg7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudGVyLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvdW50ID0gY291bnRlcltpXTtcclxuICAgICAgICAgICAgc2NhbGVkID0gY29kZVtpXSAqIGJhcldpZHRoO1xyXG4gICAgICAgICAgICBzaW5nbGVFcnJvciA9IE1hdGguYWJzKGNvdW50IC0gc2NhbGVkKSAvIHNjYWxlZDtcclxuICAgICAgICAgICAgaWYgKHNpbmdsZUVycm9yID4gbWF4U2luZ2xlRXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBOdW1iZXIuTUFYX1ZBTFVFO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVycm9yICs9IHNpbmdsZUVycm9yO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZXJyb3IgLyBtb2R1bG87XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIF9uZXh0U2V0KGxpbmU6IFJlYWRvbmx5QXJyYXk8bnVtYmVyPiwgb2Zmc2V0OiBudW1iZXIgPSAwKSB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IG9mZnNldDsgaSA8IGxpbmUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGxpbmVbaV0pIHJldHVybiBpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbGluZS5sZW5ndGg7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIF9jb3JyZWN0QmFycyhjb3VudGVyOiBBcnJheTxudW1iZXI+LCBjb3JyZWN0aW9uOiBudW1iZXIsIGluZGljZXM6IEFycmF5PG51bWJlcj4pIHtcclxuICAgICAgICBsZXQgbGVuZ3RoID0gaW5kaWNlcy5sZW5ndGg7XHJcbiAgICAgICAgbGV0IHRtcCA9IDA7XHJcbiAgICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XHJcbiAgICAgICAgICAgIHRtcCA9IGNvdW50ZXJbaW5kaWNlc1tsZW5ndGhdXSAqICgxIC0gKCgxIC0gY29ycmVjdGlvbikgLyAyKSk7XHJcbiAgICAgICAgICAgIGlmICh0bXAgPiAxKSB7XHJcbiAgICAgICAgICAgICAgICBjb3VudGVyW2luZGljZXNbbGVuZ3RoXV0gPSB0bXA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGRlY29kZVBhdHRlcm4ocGF0dGVybjogQXJyYXk8bnVtYmVyPikge1xyXG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiBkZWNvZGVQYXR0ZXJuJywgcGF0dGVybik7XHJcbiAgICAgICAgdGhpcy5fcm93ID0gcGF0dGVybjtcclxuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogZGVjb2RlUGF0dGVybiBjYWxsaW5nIGRlY29kZScsIHR5cGVvZiB0aGlzLCB0aGlzLmNvbnN0cnVjdG9yLCB0aGlzLkZPUk1BVCwgSlNPTi5zdHJpbmdpZnkodGhpcykpO1xyXG4gICAgICAgIGxldCByZXN1bHQgPSB0aGlzLmRlY29kZSgpO1xyXG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiBmaXJzdCByZXN1bHQ9JywgcmVzdWx0KTtcclxuICAgICAgICBpZiAocmVzdWx0ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3Jvdy5yZXZlcnNlKCk7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuZGVjb2RlKCk7XHJcbiAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybignKiByZXZlcnNlZCByZXN1bHQ9JywgcmVzdWx0KTtcclxuICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LmRpcmVjdGlvbiA9IEJhcmNvZGVEaXJlY3Rpb24uUmV2ZXJzZTtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5zdGFydCA9IHRoaXMuX3Jvdy5sZW5ndGggLSByZXN1bHQuc3RhcnQ7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQuZW5kID0gdGhpcy5fcm93Lmxlbmd0aCAtIHJlc3VsdC5lbmQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXN1bHQuZGlyZWN0aW9uID0gQmFyY29kZURpcmVjdGlvbi5Gb3J3YXJkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocmVzdWx0KSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5mb3JtYXQgPSB0aGlzLkZPUk1BVDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIHJldHVybmluZycsIHJlc3VsdCk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgX21hdGNoUmFuZ2Uoc3RhcnQ6IG51bWJlciwgZW5kOiBudW1iZXIsIHZhbHVlOiBudW1iZXIpIHtcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICBzdGFydCA9IHN0YXJ0IDwgMCA/IDAgOiBzdGFydDtcclxuICAgICAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9yb3dbaV0gIT09IHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIF9maWxsQ291bnRlcnMob2Zmc2V0OiBudW1iZXIgPSB0aGlzLl9uZXh0VW5zZXQodGhpcy5fcm93KSwgZW5kOiBudW1iZXIgPSB0aGlzLl9yb3cubGVuZ3RoLCBpc1doaXRlOiBib29sZWFuID0gdHJ1ZSkge1xyXG4gICAgICAgIGNvbnN0IGNvdW50ZXJzOiBBcnJheTxudW1iZXI+ID0gW107XHJcbiAgICAgICAgbGV0IGNvdW50ZXJQb3MgPSAwO1xyXG4gICAgICAgIGNvdW50ZXJzW2NvdW50ZXJQb3NdID0gMDtcclxuICAgICAgICBmb3IgKGxldCBpID0gb2Zmc2V0OyBpIDwgZW5kOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX3Jvd1tpXSBeIChpc1doaXRlID8gMSA6IDApKSB7XHJcbiAgICAgICAgICAgICAgICBjb3VudGVyc1tjb3VudGVyUG9zXSsrO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY291bnRlclBvcysrO1xyXG4gICAgICAgICAgICAgICAgY291bnRlcnNbY291bnRlclBvc10gPSAxO1xyXG4gICAgICAgICAgICAgICAgaXNXaGl0ZSA9ICFpc1doaXRlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjb3VudGVycztcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgX3RvQ291bnRlcnMoc3RhcnQ6IG51bWJlciwgY291bnRlcnM6IFVpbnQxNkFycmF5IHwgQXJyYXk8bnVtYmVyPikge1xyXG4gICAgICAgIGNvbnN0IG51bUNvdW50ZXJzID0gY291bnRlcnMubGVuZ3RoO1xyXG4gICAgICAgIGNvbnN0IGVuZCA9IHRoaXMuX3Jvdy5sZW5ndGg7XHJcbiAgICAgICAgbGV0IGlzV2hpdGUgPSAhdGhpcy5fcm93W3N0YXJ0XTtcclxuICAgICAgICBsZXQgY291bnRlclBvcyA9IDA7XHJcblxyXG4gICAgICAgIEFycmF5SGVscGVyLmluaXQoY291bnRlcnMsIDApO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9yb3dbaV0gXiAoaXNXaGl0ZSA/IDEgOiAwKSkge1xyXG4gICAgICAgICAgICAgICAgY291bnRlcnNbY291bnRlclBvc10rKztcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvdW50ZXJQb3MrKztcclxuICAgICAgICAgICAgICAgIGlmIChjb3VudGVyUG9zID09PSBudW1Db3VudGVycykge1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjb3VudGVyc1tjb3VudGVyUG9zXSA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgaXNXaGl0ZSA9ICFpc1doaXRlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjb3VudGVycztcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgQmFyY29kZVJlYWRlcjtcclxuIiwiaW1wb3J0IEJhcmNvZGVSZWFkZXIsIHsgQmFyY29kZUNvcnJlY3Rpb24sIEJhcmNvZGVQb3NpdGlvbiwgQmFyY29kZSwgQmFyY29kZUluZm8gfSBmcm9tICcuL2JhcmNvZGVfcmVhZGVyJztcclxuXHJcbmNsYXNzIENvZGUxMjhSZWFkZXIgZXh0ZW5kcyBCYXJjb2RlUmVhZGVyIHtcclxuICAgIENPREVfU0hJRlQgPSA5ODtcclxuICAgIENPREVfQyA9IDk5O1xyXG4gICAgQ09ERV9CID0gMTAwO1xyXG4gICAgQ09ERV9BID0gMTAxO1xyXG4gICAgU1RBUlRfQ09ERV9BID0gMTAzO1xyXG4gICAgU1RBUlRfQ09ERV9CID0gMTA0O1xyXG4gICAgU1RBUlRfQ09ERV9DID0gMTA1O1xyXG4gICAgU1RPUF9DT0RFID0gMTA2O1xyXG4gICAgQ09ERV9QQVRURVJOID0gW1xyXG4gICAgICAgICAgICBbMiwgMSwgMiwgMiwgMiwgMl0sXHJcbiAgICAgICAgICAgIFsyLCAyLCAyLCAxLCAyLCAyXSxcclxuICAgICAgICAgICAgWzIsIDIsIDIsIDIsIDIsIDFdLFxyXG4gICAgICAgICAgICBbMSwgMiwgMSwgMiwgMiwgM10sXHJcbiAgICAgICAgICAgIFsxLCAyLCAxLCAzLCAyLCAyXSxcclxuICAgICAgICAgICAgWzEsIDMsIDEsIDIsIDIsIDJdLFxyXG4gICAgICAgICAgICBbMSwgMiwgMiwgMiwgMSwgM10sXHJcbiAgICAgICAgICAgIFsxLCAyLCAyLCAzLCAxLCAyXSxcclxuICAgICAgICAgICAgWzEsIDMsIDIsIDIsIDEsIDJdLFxyXG4gICAgICAgICAgICBbMiwgMiwgMSwgMiwgMSwgM10sXHJcbiAgICAgICAgICAgIFsyLCAyLCAxLCAzLCAxLCAyXSxcclxuICAgICAgICAgICAgWzIsIDMsIDEsIDIsIDEsIDJdLFxyXG4gICAgICAgICAgICBbMSwgMSwgMiwgMiwgMywgMl0sXHJcbiAgICAgICAgICAgIFsxLCAyLCAyLCAxLCAzLCAyXSxcclxuICAgICAgICAgICAgWzEsIDIsIDIsIDIsIDMsIDFdLFxyXG4gICAgICAgICAgICBbMSwgMSwgMywgMiwgMiwgMl0sXHJcbiAgICAgICAgICAgIFsxLCAyLCAzLCAxLCAyLCAyXSxcclxuICAgICAgICAgICAgWzEsIDIsIDMsIDIsIDIsIDFdLFxyXG4gICAgICAgICAgICBbMiwgMiwgMywgMiwgMSwgMV0sXHJcbiAgICAgICAgICAgIFsyLCAyLCAxLCAxLCAzLCAyXSxcclxuICAgICAgICAgICAgWzIsIDIsIDEsIDIsIDMsIDFdLFxyXG4gICAgICAgICAgICBbMiwgMSwgMywgMiwgMSwgMl0sXHJcbiAgICAgICAgICAgIFsyLCAyLCAzLCAxLCAxLCAyXSxcclxuICAgICAgICAgICAgWzMsIDEsIDIsIDEsIDMsIDFdLFxyXG4gICAgICAgICAgICBbMywgMSwgMSwgMiwgMiwgMl0sXHJcbiAgICAgICAgICAgIFszLCAyLCAxLCAxLCAyLCAyXSxcclxuICAgICAgICAgICAgWzMsIDIsIDEsIDIsIDIsIDFdLFxyXG4gICAgICAgICAgICBbMywgMSwgMiwgMiwgMSwgMl0sXHJcbiAgICAgICAgICAgIFszLCAyLCAyLCAxLCAxLCAyXSxcclxuICAgICAgICAgICAgWzMsIDIsIDIsIDIsIDEsIDFdLFxyXG4gICAgICAgICAgICBbMiwgMSwgMiwgMSwgMiwgM10sXHJcbiAgICAgICAgICAgIFsyLCAxLCAyLCAzLCAyLCAxXSxcclxuICAgICAgICAgICAgWzIsIDMsIDIsIDEsIDIsIDFdLFxyXG4gICAgICAgICAgICBbMSwgMSwgMSwgMywgMiwgM10sXHJcbiAgICAgICAgICAgIFsxLCAzLCAxLCAxLCAyLCAzXSxcclxuICAgICAgICAgICAgWzEsIDMsIDEsIDMsIDIsIDFdLFxyXG4gICAgICAgICAgICBbMSwgMSwgMiwgMywgMSwgM10sXHJcbiAgICAgICAgICAgIFsxLCAzLCAyLCAxLCAxLCAzXSxcclxuICAgICAgICAgICAgWzEsIDMsIDIsIDMsIDEsIDFdLFxyXG4gICAgICAgICAgICBbMiwgMSwgMSwgMywgMSwgM10sXHJcbiAgICAgICAgICAgIFsyLCAzLCAxLCAxLCAxLCAzXSxcclxuICAgICAgICAgICAgWzIsIDMsIDEsIDMsIDEsIDFdLFxyXG4gICAgICAgICAgICBbMSwgMSwgMiwgMSwgMywgM10sXHJcbiAgICAgICAgICAgIFsxLCAxLCAyLCAzLCAzLCAxXSxcclxuICAgICAgICAgICAgWzEsIDMsIDIsIDEsIDMsIDFdLFxyXG4gICAgICAgICAgICBbMSwgMSwgMywgMSwgMiwgM10sXHJcbiAgICAgICAgICAgIFsxLCAxLCAzLCAzLCAyLCAxXSxcclxuICAgICAgICAgICAgWzEsIDMsIDMsIDEsIDIsIDFdLFxyXG4gICAgICAgICAgICBbMywgMSwgMywgMSwgMiwgMV0sXHJcbiAgICAgICAgICAgIFsyLCAxLCAxLCAzLCAzLCAxXSxcclxuICAgICAgICAgICAgWzIsIDMsIDEsIDEsIDMsIDFdLFxyXG4gICAgICAgICAgICBbMiwgMSwgMywgMSwgMSwgM10sXHJcbiAgICAgICAgICAgIFsyLCAxLCAzLCAzLCAxLCAxXSxcclxuICAgICAgICAgICAgWzIsIDEsIDMsIDEsIDMsIDFdLFxyXG4gICAgICAgICAgICBbMywgMSwgMSwgMSwgMiwgM10sXHJcbiAgICAgICAgICAgIFszLCAxLCAxLCAzLCAyLCAxXSxcclxuICAgICAgICAgICAgWzMsIDMsIDEsIDEsIDIsIDFdLFxyXG4gICAgICAgICAgICBbMywgMSwgMiwgMSwgMSwgM10sXHJcbiAgICAgICAgICAgIFszLCAxLCAyLCAzLCAxLCAxXSxcclxuICAgICAgICAgICAgWzMsIDMsIDIsIDEsIDEsIDFdLFxyXG4gICAgICAgICAgICBbMywgMSwgNCwgMSwgMSwgMV0sXHJcbiAgICAgICAgICAgIFsyLCAyLCAxLCA0LCAxLCAxXSxcclxuICAgICAgICAgICAgWzQsIDMsIDEsIDEsIDEsIDFdLFxyXG4gICAgICAgICAgICBbMSwgMSwgMSwgMiwgMiwgNF0sXHJcbiAgICAgICAgICAgIFsxLCAxLCAxLCA0LCAyLCAyXSxcclxuICAgICAgICAgICAgWzEsIDIsIDEsIDEsIDIsIDRdLFxyXG4gICAgICAgICAgICBbMSwgMiwgMSwgNCwgMiwgMV0sXHJcbiAgICAgICAgICAgIFsxLCA0LCAxLCAxLCAyLCAyXSxcclxuICAgICAgICAgICAgWzEsIDQsIDEsIDIsIDIsIDFdLFxyXG4gICAgICAgICAgICBbMSwgMSwgMiwgMiwgMSwgNF0sXHJcbiAgICAgICAgICAgIFsxLCAxLCAyLCA0LCAxLCAyXSxcclxuICAgICAgICAgICAgWzEsIDIsIDIsIDEsIDEsIDRdLFxyXG4gICAgICAgICAgICBbMSwgMiwgMiwgNCwgMSwgMV0sXHJcbiAgICAgICAgICAgIFsxLCA0LCAyLCAxLCAxLCAyXSxcclxuICAgICAgICAgICAgWzEsIDQsIDIsIDIsIDEsIDFdLFxyXG4gICAgICAgICAgICBbMiwgNCwgMSwgMiwgMSwgMV0sXHJcbiAgICAgICAgICAgIFsyLCAyLCAxLCAxLCAxLCA0XSxcclxuICAgICAgICAgICAgWzQsIDEsIDMsIDEsIDEsIDFdLFxyXG4gICAgICAgICAgICBbMiwgNCwgMSwgMSwgMSwgMl0sXHJcbiAgICAgICAgICAgIFsxLCAzLCA0LCAxLCAxLCAxXSxcclxuICAgICAgICAgICAgWzEsIDEsIDEsIDIsIDQsIDJdLFxyXG4gICAgICAgICAgICBbMSwgMiwgMSwgMSwgNCwgMl0sXHJcbiAgICAgICAgICAgIFsxLCAyLCAxLCAyLCA0LCAxXSxcclxuICAgICAgICAgICAgWzEsIDEsIDQsIDIsIDEsIDJdLFxyXG4gICAgICAgICAgICBbMSwgMiwgNCwgMSwgMSwgMl0sXHJcbiAgICAgICAgICAgIFsxLCAyLCA0LCAyLCAxLCAxXSxcclxuICAgICAgICAgICAgWzQsIDEsIDEsIDIsIDEsIDJdLFxyXG4gICAgICAgICAgICBbNCwgMiwgMSwgMSwgMSwgMl0sXHJcbiAgICAgICAgICAgIFs0LCAyLCAxLCAyLCAxLCAxXSxcclxuICAgICAgICAgICAgWzIsIDEsIDIsIDEsIDQsIDFdLFxyXG4gICAgICAgICAgICBbMiwgMSwgNCwgMSwgMiwgMV0sXHJcbiAgICAgICAgICAgIFs0LCAxLCAyLCAxLCAyLCAxXSxcclxuICAgICAgICAgICAgWzEsIDEsIDEsIDEsIDQsIDNdLFxyXG4gICAgICAgICAgICBbMSwgMSwgMSwgMywgNCwgMV0sXHJcbiAgICAgICAgICAgIFsxLCAzLCAxLCAxLCA0LCAxXSxcclxuICAgICAgICAgICAgWzEsIDEsIDQsIDEsIDEsIDNdLFxyXG4gICAgICAgICAgICBbMSwgMSwgNCwgMywgMSwgMV0sXHJcbiAgICAgICAgICAgIFs0LCAxLCAxLCAxLCAxLCAzXSxcclxuICAgICAgICAgICAgWzQsIDEsIDEsIDMsIDEsIDFdLFxyXG4gICAgICAgICAgICBbMSwgMSwgMywgMSwgNCwgMV0sXHJcbiAgICAgICAgICAgIFsxLCAxLCA0LCAxLCAzLCAxXSxcclxuICAgICAgICAgICAgWzMsIDEsIDEsIDEsIDQsIDFdLFxyXG4gICAgICAgICAgICBbNCwgMSwgMSwgMSwgMywgMV0sXHJcbiAgICAgICAgICAgIFsyLCAxLCAxLCA0LCAxLCAyXSxcclxuICAgICAgICAgICAgWzIsIDEsIDEsIDIsIDEsIDRdLFxyXG4gICAgICAgICAgICBbMiwgMSwgMSwgMiwgMywgMl0sXHJcbiAgICAgICAgICAgIFsyLCAzLCAzLCAxLCAxLCAxLCAyXSxcclxuICAgICAgICBdO1xyXG4gICAgU0lOR0xFX0NPREVfRVJST1IgPSAwLjY0O1xyXG4gICAgQVZHX0NPREVfRVJST1IgPSAwLjMwO1xyXG4gICAgRk9STUFUID0gJ2NvZGVfMTI4JztcclxuICAgIE1PRFVMRV9JTkRJQ0VTID0geyBiYXI6IFswLCAyLCA0XSwgc3BhY2U6IFsxLCAzLCA1XSB9O1xyXG5cclxuICAgIHByb3RlY3RlZCBfZGVjb2RlQ29kZShzdGFydDogbnVtYmVyLCBjb3JyZWN0aW9uPzogQmFyY29kZUNvcnJlY3Rpb24pOiBCYXJjb2RlSW5mbyB8IG51bGwge1xyXG4gICAgICAgIGNvbnN0IGJlc3RNYXRjaCA9IHtcclxuICAgICAgICAgICAgZXJyb3I6IE51bWJlci5NQVhfVkFMVUUsXHJcbiAgICAgICAgICAgIGNvZGU6IC0xLFxyXG4gICAgICAgICAgICBzdGFydDogc3RhcnQsXHJcbiAgICAgICAgICAgIGVuZDogc3RhcnQsXHJcbiAgICAgICAgICAgIGNvcnJlY3Rpb246IHtcclxuICAgICAgICAgICAgICAgIGJhcjogMSxcclxuICAgICAgICAgICAgICAgIHNwYWNlOiAxLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgbGV0IGNvdW50ZXIgPSBbMCwgMCwgMCwgMCwgMCwgMF07XHJcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gc3RhcnQ7XHJcbiAgICAgICAgbGV0IGlzV2hpdGUgPSAhdGhpcy5fcm93W29mZnNldF07XHJcbiAgICAgICAgbGV0IGNvdW50ZXJQb3MgPSAwO1xyXG5cclxuICAgICAgICBmb3IgKGxldCBpID0gb2Zmc2V0OyBpIDwgdGhpcy5fcm93Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9yb3dbaV0gXiAoaXNXaGl0ZSA/IDEgOiAwKSkge1xyXG4gICAgICAgICAgICAgICAgY291bnRlcltjb3VudGVyUG9zXSsrO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvdW50ZXJQb3MgPT09IGNvdW50ZXIubGVuZ3RoIC0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb3JyZWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvcnJlY3QoY291bnRlciwgY29ycmVjdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGNvZGUgPSAwOyBjb2RlIDwgdGhpcy5DT0RFX1BBVFRFUk4ubGVuZ3RoOyBjb2RlKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLl9tYXRjaFBhdHRlcm4oY291bnRlciwgdGhpcy5DT0RFX1BBVFRFUk5bY29kZV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IgPCBiZXN0TWF0Y2guZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5jb2RlID0gY29kZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5lcnJvciA9IGVycm9yO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5lbmQgPSBpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChiZXN0TWF0Y2guY29kZSA9PT0gLTEgfHwgYmVzdE1hdGNoLmVycm9yID4gdGhpcy5BVkdfQ09ERV9FUlJPUikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuQ09ERV9QQVRURVJOW2Jlc3RNYXRjaC5jb2RlXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guY29ycmVjdGlvbi5iYXIgPSB0aGlzLmNhbGN1bGF0ZUNvcnJlY3Rpb24oXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLkNPREVfUEFUVEVSTltiZXN0TWF0Y2guY29kZV0sIGNvdW50ZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLk1PRFVMRV9JTkRJQ0VTLmJhcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5jb3JyZWN0aW9uLnNwYWNlID0gdGhpcy5jYWxjdWxhdGVDb3JyZWN0aW9uKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5DT0RFX1BBVFRFUk5bYmVzdE1hdGNoLmNvZGVdLCBjb3VudGVyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5NT0RVTEVfSU5ESUNFUy5zcGFjZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBiZXN0TWF0Y2g7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJQb3MrKztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvdW50ZXJbY291bnRlclBvc10gPSAxO1xyXG4gICAgICAgICAgICAgICAgaXNXaGl0ZSA9ICFpc1doaXRlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfTtcclxuXHJcbiAgICBwcm90ZWN0ZWQgX2NvcnJlY3QoY291bnRlcjogQXJyYXk8bnVtYmVyPiwgY29ycmVjdGlvbjogQmFyY29kZUNvcnJlY3Rpb24pIHtcclxuICAgICAgICB0aGlzLl9jb3JyZWN0QmFycyhjb3VudGVyLCBjb3JyZWN0aW9uLmJhciwgdGhpcy5NT0RVTEVfSU5ESUNFUy5iYXIpO1xyXG4gICAgICAgIHRoaXMuX2NvcnJlY3RCYXJzKGNvdW50ZXIsIGNvcnJlY3Rpb24uc3BhY2UsIHRoaXMuTU9EVUxFX0lORElDRVMuc3BhY2UpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBUT0RPOiBfZmluZFN0YXJ0IGFuZCBkZWNvZGVDb2RlIHNoYXJlIHNpbWlsYXIgY29kZSwgY2FuIHdlIHJlLXVzZSBzb21lP1xyXG4gICAgcHJvdGVjdGVkIF9maW5kU3RhcnQoKTogQmFyY29kZUluZm8gfCBudWxsIHtcclxuICAgICAgICBjb25zdCBjb3VudGVyID0gWzAsIDAsIDAsIDAsIDAsIDBdO1xyXG4gICAgICAgIGNvbnN0IG9mZnNldCA9IHRoaXMuX25leHRTZXQodGhpcy5fcm93KTtcclxuICAgICAgICBjb25zdCBiZXN0TWF0Y2ggPSB7XHJcbiAgICAgICAgICAgIGVycm9yOiBOdW1iZXIuTUFYX1ZBTFVFLFxyXG4gICAgICAgICAgICBjb2RlOiAtMSxcclxuICAgICAgICAgICAgc3RhcnQ6IDAsXHJcbiAgICAgICAgICAgIGVuZDogMCxcclxuICAgICAgICAgICAgY29ycmVjdGlvbjoge1xyXG4gICAgICAgICAgICAgICAgYmFyOiAxLFxyXG4gICAgICAgICAgICAgICAgc3BhY2U6IDEsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfTtcclxuICAgICAgICBsZXQgaXNXaGl0ZSA9IGZhbHNlO1xyXG4gICAgICAgIGxldCBjb3VudGVyUG9zID0gMDtcclxuXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IG9mZnNldDsgaSA8IHRoaXMuX3Jvdy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fcm93W2ldIF4gKGlzV2hpdGUgPyAxIDogMCkpIHtcclxuICAgICAgICAgICAgICAgIGNvdW50ZXJbY291bnRlclBvc10rKztcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmIChjb3VudGVyUG9zID09PSBjb3VudGVyLmxlbmd0aCAtIDEpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdW0gPSBjb3VudGVyLnJlZHVjZSgocHJldiwgbmV4dCkgPT4gcHJldiArIG5leHQsIDApO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGNvZGUgPSB0aGlzLlNUQVJUX0NPREVfQTsgY29kZSA8PSB0aGlzLlNUQVJUX0NPREVfQzsgY29kZSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5fbWF0Y2hQYXR0ZXJuKGNvdW50ZXIsIHRoaXMuQ09ERV9QQVRURVJOW2NvZGVdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yIDwgYmVzdE1hdGNoLmVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guY29kZSA9IGNvZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guZXJyb3IgPSBlcnJvcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoYmVzdE1hdGNoLmVycm9yIDwgdGhpcy5BVkdfQ09ERV9FUlJPUikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guc3RhcnQgPSBpIC0gc3VtO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guZW5kID0gaTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLmNvcnJlY3Rpb24uYmFyID0gdGhpcy5jYWxjdWxhdGVDb3JyZWN0aW9uKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5DT0RFX1BBVFRFUk5bYmVzdE1hdGNoLmNvZGVdLCBjb3VudGVyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5NT0RVTEVfSU5ESUNFUy5iYXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guY29ycmVjdGlvbi5zcGFjZSA9IHRoaXMuY2FsY3VsYXRlQ29ycmVjdGlvbihcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuQ09ERV9QQVRURVJOW2Jlc3RNYXRjaC5jb2RlXSwgY291bnRlcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuTU9EVUxFX0lORElDRVMuc3BhY2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmVzdE1hdGNoO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCA0OyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlcltqXSA9IGNvdW50ZXJbaiArIDJdO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjb3VudGVyWzRdID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBjb3VudGVyWzVdID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBjb3VudGVyUG9zLS07XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJQb3MrKztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvdW50ZXJbY291bnRlclBvc10gPSAxO1xyXG4gICAgICAgICAgICAgICAgaXNXaGl0ZSA9ICFpc1doaXRlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgZGVjb2RlKHJvdz86IEFycmF5PG51bWJlcj4sIHN0YXJ0PzogQmFyY29kZVBvc2l0aW9uKTogQmFyY29kZSB8IG51bGwge1xyXG4gICAgICAgIGNvbnN0IHN0YXJ0SW5mbyA9IHRoaXMuX2ZpbmRTdGFydCgpO1xyXG4gICAgICAgIGlmIChzdGFydEluZm8gPT09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHZhciBzZWxmID0gdGhpcyxcclxuICAgICAgICAvLyAgICAgZG9uZSA9IGZhbHNlLFxyXG4gICAgICAgIC8vICAgICByZXN1bHQgPSBbXSxcclxuICAgICAgICAvLyAgICAgbXVsdGlwbGllciA9IDAsXHJcbiAgICAgICAgLy8gICAgIGNoZWNrc3VtID0gMCxcclxuICAgICAgICAvLyAgICAgY29kZXNldCxcclxuICAgICAgICAvLyAgICAgcmF3UmVzdWx0ID0gW10sXHJcbiAgICAgICAgLy8gICAgIGRlY29kZWRDb2RlcyA9IFtdLFxyXG4gICAgICAgIC8vICAgICBzaGlmdE5leHQgPSBmYWxzZSxcclxuICAgICAgICAvLyAgICAgdW5zaGlmdCxcclxuICAgICAgICAvLyAgICAgcmVtb3ZlTGFzdENoYXJhY3RlciA9IHRydWU7XHJcblxyXG4gICAgICAgIGxldCBjb2RlOiBCYXJjb2RlSW5mbyB8IG51bGwgPSB7XHJcbiAgICAgICAgICAgIGNvZGU6IHN0YXJ0SW5mby5jb2RlLFxyXG4gICAgICAgICAgICBzdGFydDogc3RhcnRJbmZvLnN0YXJ0LFxyXG4gICAgICAgICAgICBlbmQ6IHN0YXJ0SW5mby5lbmQsXHJcbiAgICAgICAgICAgIGNvcnJlY3Rpb246IHtcclxuICAgICAgICAgICAgICAgIGJhcjogc3RhcnRJbmZvLmNvcnJlY3Rpb24hLmJhcixcclxuICAgICAgICAgICAgICAgIHNwYWNlOiBzdGFydEluZm8uY29ycmVjdGlvbiEuc3BhY2UsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCBkZWNvZGVkQ29kZXMgPSBbXTtcclxuICAgICAgICBkZWNvZGVkQ29kZXMucHVzaChjb2RlKTtcclxuICAgICAgICBsZXQgY2hlY2tzdW0gPSBjb2RlLmNvZGU7XHJcbiAgICAgICAgbGV0IGNvZGVzZXQgPSAoKGM6IG51bWJlcikgPT4ge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKGMpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgdGhpcy5TVEFSVF9DT0RFX0E6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuQ09ERV9BO1xyXG4gICAgICAgICAgICAgICAgY2FzZSB0aGlzLlNUQVJUX0NPREVfQjpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5DT0RFX0I7XHJcbiAgICAgICAgICAgICAgICBjYXNlIHRoaXMuU1RBUlRfQ09ERV9DOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLkNPREVfQztcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KShjb2RlLmNvZGUpO1xyXG4gICAgICAgIGxldCBkb25lID0gZmFsc2U7XHJcbiAgICAgICAgbGV0IHNoaWZ0TmV4dCA9IGZhbHNlO1xyXG4gICAgICAgIGxldCB1bnNoaWZ0ID0gc2hpZnROZXh0O1xyXG4gICAgICAgIGxldCByZW1vdmVMYXN0Q2hhcmFjdGVyID0gdHJ1ZTtcclxuICAgICAgICBsZXQgbXVsdGlwbGllciA9IDA7XHJcbiAgICAgICAgbGV0IHJhd1Jlc3VsdDogQXJyYXk8bnVtYmVyPiA9IFtdO1xyXG4gICAgICAgIGxldCByZXN1bHQ6IEFycmF5PHN0cmluZyB8IG51bWJlcj4gPSBbXTsgLy8gVE9ETzogaSB0aGluayB0aGlzIHNob3VsZCBiZSBzdHJpbmcgb25seSwgYnV0IGl0IGNyZWF0ZXMgcHJvYmxlbXMgaWYgaXQgaXNcclxuXHJcbiAgICAgICAgd2hpbGUgKCFkb25lKSB7XHJcbiAgICAgICAgICAgIHVuc2hpZnQgPSBzaGlmdE5leHQ7XHJcbiAgICAgICAgICAgIHNoaWZ0TmV4dCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBjb2RlID0gdGhpcy5fZGVjb2RlQ29kZShjb2RlIS5lbmQsIGNvZGUhLmNvcnJlY3Rpb24pO1xyXG4gICAgICAgICAgICBpZiAoY29kZSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvZGUuY29kZSAhPT0gdGhpcy5TVE9QX0NPREUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZW1vdmVMYXN0Q2hhcmFjdGVyID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoY29kZS5jb2RlICE9PSB0aGlzLlNUT1BfQ09ERSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJhd1Jlc3VsdC5wdXNoKGNvZGUuY29kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgbXVsdGlwbGllcisrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNoZWNrc3VtICs9IG11bHRpcGxpZXIgKiBjb2RlLmNvZGU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBkZWNvZGVkQ29kZXMucHVzaChjb2RlKTtcclxuXHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGNvZGVzZXQpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgdGhpcy5DT0RFX0E6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGUuY29kZSA8IDY0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoMzIgKyBjb2RlLmNvZGUpKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvZGUuY29kZSA8IDk2KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZS5jb2RlIC0gNjQpKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29kZS5jb2RlICE9PSB0aGlzLlNUT1BfQ09ERSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlTGFzdENoYXJhY3RlciA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoY29kZS5jb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgdGhpcy5DT0RFX1NISUZUOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hpZnROZXh0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVzZXQgPSB0aGlzLkNPREVfQjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIHRoaXMuQ09ERV9COlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZXNldCA9IHRoaXMuQ09ERV9CO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgdGhpcy5DT0RFX0M6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2Rlc2V0ID0gdGhpcy5DT0RFX0M7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSB0aGlzLlNUT1BfQ09ERTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIHRoaXMuQ09ERV9COlxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2RlLmNvZGUgPCA5Nikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKDMyICsgY29kZS5jb2RlKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGUuY29kZSAhPT0gdGhpcy5TVE9QX0NPREUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUxhc3RDaGFyYWN0ZXIgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGNvZGUuY29kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSB0aGlzLkNPREVfU0hJRlQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hpZnROZXh0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2Rlc2V0ID0gdGhpcy5DT0RFX0E7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIHRoaXMuQ09ERV9BOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVzZXQgPSB0aGlzLkNPREVfQTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgdGhpcy5DT0RFX0M6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZXNldCA9IHRoaXMuQ09ERV9DO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSB0aGlzLlNUT1BfQ09ERTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgdGhpcy5DT0RFX0M6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGUuY29kZSA8IDEwMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChjb2RlLmNvZGUgPCAxMCA/ICcwJyArIGNvZGUuY29kZSA6IGNvZGUuY29kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGUuY29kZSAhPT0gdGhpcy5TVE9QX0NPREUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUxhc3RDaGFyYWN0ZXIgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGNvZGUuY29kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIHRoaXMuQ09ERV9BOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZXNldCA9IHRoaXMuQ09ERV9BO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgdGhpcy5DT0RFX0I6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2Rlc2V0ID0gdGhpcy5DT0RFX0I7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSB0aGlzLlNUT1BfQ09ERTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBkb25lID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodW5zaGlmdCkge1xyXG4gICAgICAgICAgICAgICAgY29kZXNldCA9IGNvZGVzZXQgPT09IHRoaXMuQ09ERV9BID8gdGhpcy5DT0RFX0IgOiB0aGlzLkNPREVfQTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGNvZGUgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb2RlLmVuZCA9IHRoaXMuX25leHRVbnNldCh0aGlzLl9yb3csIGNvZGUuZW5kKTtcclxuICAgICAgICBpZiAoIXRoaXMuX3ZlcmlmeVRyYWlsaW5nV2hpdGVzcGFjZShjb2RlKSl7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY2hlY2tzdW0gLT0gbXVsdGlwbGllciAqIHJhd1Jlc3VsdFtyYXdSZXN1bHQubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgaWYgKGNoZWNrc3VtICUgMTAzICE9PSByYXdSZXN1bHRbcmF3UmVzdWx0Lmxlbmd0aCAtIDFdKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFyZXN1bHQubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gcmVtb3ZlIGxhc3QgY29kZSBmcm9tIHJlc3VsdCAoY2hlY2tzdW0pXHJcbiAgICAgICAgaWYgKHJlbW92ZUxhc3RDaGFyYWN0ZXIpIHtcclxuICAgICAgICAgICAgcmVzdWx0LnNwbGljZShyZXN1bHQubGVuZ3RoIC0gMSwgMSk7XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgY29kZTogcmVzdWx0LmpvaW4oJycpLFxyXG4gICAgICAgICAgICBzdGFydDogc3RhcnRJbmZvLnN0YXJ0LFxyXG4gICAgICAgICAgICBlbmQ6IGNvZGUuZW5kLFxyXG4gICAgICAgICAgICBjb2Rlc2V0OiBjb2Rlc2V0IGFzIG51bWJlcixcclxuICAgICAgICAgICAgc3RhcnRJbmZvOiBzdGFydEluZm8sXHJcbiAgICAgICAgICAgIGRlY29kZWRDb2RlczogZGVjb2RlZENvZGVzLFxyXG4gICAgICAgICAgICBlbmRJbmZvOiBjb2RlLFxyXG4gICAgICAgICAgICBmb3JtYXQ6IHRoaXMuRk9STUFULFxyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG5cclxuICAgIHByb3RlY3RlZCBfdmVyaWZ5VHJhaWxpbmdXaGl0ZXNwYWNlKGVuZEluZm86IEJhcmNvZGVJbmZvKTogQmFyY29kZUluZm8gfCBudWxsIHtcclxuXHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzLFxyXG4gICAgICAgICAgICB0cmFpbGluZ1doaXRlc3BhY2VFbmQ7XHJcblxyXG4gICAgICAgIHRyYWlsaW5nV2hpdGVzcGFjZUVuZCA9IGVuZEluZm8uZW5kICsgKChlbmRJbmZvLmVuZCAtIGVuZEluZm8uc3RhcnQpIC8gMik7XHJcbiAgICAgICAgaWYgKHRyYWlsaW5nV2hpdGVzcGFjZUVuZCA8IHNlbGYuX3Jvdy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgaWYgKHNlbGYuX21hdGNoUmFuZ2UoZW5kSW5mby5lbmQsIHRyYWlsaW5nV2hpdGVzcGFjZUVuZCwgMCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBlbmRJbmZvO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgcHVibGljIGNhbGN1bGF0ZUNvcnJlY3Rpb24oZXhwZWN0ZWQ6IFJlYWRvbmx5QXJyYXk8bnVtYmVyPiwgbm9ybWFsaXplZDogUmVhZG9ubHlBcnJheTxudW1iZXI+LCBpbmRpY2VzOiBSZWFkb25seUFycmF5PG51bWJlcj4pOiBudW1iZXIge1xyXG4gICAgICAgIHZhciBsZW5ndGggPSBpbmRpY2VzLmxlbmd0aCxcclxuICAgICAgICAgICAgc3VtTm9ybWFsaXplZCA9IDAsXHJcbiAgICAgICAgICAgIHN1bUV4cGVjdGVkID0gMDtcclxuXHJcbiAgICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XHJcbiAgICAgICAgICAgIHN1bUV4cGVjdGVkICs9IGV4cGVjdGVkW2luZGljZXNbbGVuZ3RoXV07XHJcbiAgICAgICAgICAgIHN1bU5vcm1hbGl6ZWQgKz0gbm9ybWFsaXplZFtpbmRpY2VzW2xlbmd0aF1dO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc3VtRXhwZWN0ZWQgLyBzdW1Ob3JtYWxpemVkO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBDb2RlMTI4UmVhZGVyO1xyXG4iLCJpbXBvcnQgQmFyY29kZVJlYWRlciwgeyBCYXJjb2RlUmVhZGVyQ29uZmlnLCBCYXJjb2RlSW5mbywgQmFyY29kZVBvc2l0aW9uLCBCYXJjb2RlIH0gZnJvbSAnLi9iYXJjb2RlX3JlYWRlcic7XHJcbmltcG9ydCBtZXJnZSBmcm9tICdsb2Rhc2gvbWVyZ2UnO1xyXG5cclxuLy8gY29uc3QgQ09ERV9MX1NUQVJUID0gMDtcclxuY29uc3QgQ09ERV9HX1NUQVJUID0gMTA7XHJcbmV4cG9ydCB7IENPREVfR19TVEFSVCB9O1xyXG5jb25zdCBTVEFSVF9QQVRURVJOID0gWzEsIDEsIDFdO1xyXG5jb25zdCBNSURETEVfUEFUVEVSTiA9IFsxLCAxLCAxLCAxLCAxXTtcclxuZXhwb3J0IHsgTUlERExFX1BBVFRFUk4gfTtcclxuY29uc3QgRVhURU5TSU9OX1NUQVJUX1BBVFRFUk4gPSBbMSwgMSwgMl07XHJcbmNvbnN0IENPREVfUEFUVEVSTiA9IFtcclxuICAgIFszLCAyLCAxLCAxXSxcclxuICAgIFsyLCAyLCAyLCAxXSxcclxuICAgIFsyLCAxLCAyLCAyXSxcclxuICAgIFsxLCA0LCAxLCAxXSxcclxuICAgIFsxLCAxLCAzLCAyXSxcclxuICAgIFsxLCAyLCAzLCAxXSxcclxuICAgIFsxLCAxLCAxLCA0XSxcclxuICAgIFsxLCAzLCAxLCAyXSxcclxuICAgIFsxLCAyLCAxLCAzXSxcclxuICAgIFszLCAxLCAxLCAyXSxcclxuICAgIFsxLCAxLCAyLCAzXSxcclxuICAgIFsxLCAyLCAyLCAyXSxcclxuICAgIFsyLCAyLCAxLCAyXSxcclxuICAgIFsxLCAxLCA0LCAxXSxcclxuICAgIFsyLCAzLCAxLCAxXSxcclxuICAgIFsxLCAzLCAyLCAxXSxcclxuICAgIFs0LCAxLCAxLCAxXSxcclxuICAgIFsyLCAxLCAzLCAxXSxcclxuICAgIFszLCAxLCAyLCAxXSxcclxuICAgIFsyLCAxLCAxLCAzXSxcclxuXTtcclxuY29uc3QgQ09ERV9GUkVRVUVOQ1kgPSBbMCwgMTEsIDEzLCAxNCwgMTksIDI1LCAyOCwgMjEsIDIyLCAyNl07XHJcbi8vIGNvbnN0IFNJTkdMRV9DT0RFX0VSUk9SID0gMC43MDtcclxuY29uc3QgQVZHX0NPREVfRVJST1IgPSAwLjQ4O1xyXG5cclxuY2xhc3MgRUFOUmVhZGVyIGV4dGVuZHMgQmFyY29kZVJlYWRlciB7XHJcbiAgICBGT1JNQVQgPSAnZWFuXzEzJztcclxuICAgIFNJTkdMRV9DT0RFX0VSUk9SID0gMC43MDtcclxuICAgIFNUT1BfUEFUVEVSTiA9IFsxLCAxLCAxXTsgLy8gVE9ETzogZG9lcyB0aGlzIG5lZWQgdG8gYmUgaW4gdGhlIGNsYXNzP1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZz86IEJhcmNvZGVSZWFkZXJDb25maWcsIHN1cHBsZW1lbnRzPzogQXJyYXk8QmFyY29kZVJlYWRlcj4pIHtcclxuICAgICAgICBzdXBlcihtZXJnZSh7IHN1cHBsZW1lbnRzOiBbXSB9LCBjb25maWcpLCBzdXBwbGVtZW50cyk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIF9maW5kUGF0dGVybihwYXR0ZXJuOiBSZWFkb25seUFycmF5PG51bWJlcj4sIG9mZnNldDogbnVtYmVyLCBpc1doaXRlOiBib29sZWFuLCB0cnlIYXJkZXI6IGJvb2xlYW4pOiBCYXJjb2RlUG9zaXRpb24gfCBudWxsIHtcclxuICAgICAgICBjb25zdCBjb3VudGVyID0gbmV3IEFycmF5PG51bWJlcj4ocGF0dGVybi5sZW5ndGgpLmZpbGwoMCk7XHJcbiAgICAgICAgY29uc3QgYmVzdE1hdGNoOiBCYXJjb2RlUG9zaXRpb24gPSB7XHJcbiAgICAgICAgICAgIGVycm9yOiBOdW1iZXIuTUFYX1ZBTFVFLFxyXG4gICAgICAgICAgICBzdGFydDogMCxcclxuICAgICAgICAgICAgZW5kOiAwXHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCBlcHNpbG9uID0gQVZHX0NPREVfRVJST1I7XHJcbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIGZpbmRQYXR0ZXJuJywgcGF0dGVybiwgb2Zmc2V0LCBpc1doaXRlLCB0cnlIYXJkZXIsIGVwc2lsb24pO1xyXG4gICAgICAgIGxldCBjb3VudGVyUG9zID0gMDtcclxuICAgICAgICBpZiAoIW9mZnNldCkge1xyXG4gICAgICAgICAgICBvZmZzZXQgPSB0aGlzLl9uZXh0U2V0KHRoaXMuX3Jvdyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBmb3VuZCA9IGZhbHNlO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSBvZmZzZXQ7IGkgPCB0aGlzLl9yb3cubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKGAqIGxvb3AgaT0ke29mZnNldH0gbGVuPSR7dGhpcy5fcm93Lmxlbmd0aH0gaXNXaGl0ZT0ke2lzV2hpdGV9IGNvdW50ZXJQb3M9JHtjb3VudGVyUG9zfWApO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fcm93W2ldIF4gKGlzV2hpdGUgPyAxIDogMCkpIHtcclxuICAgICAgICAgICAgICAgIGNvdW50ZXJbY291bnRlclBvc10gKz0gMTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmIChjb3VudGVyUG9zID09PSBjb3VudGVyLmxlbmd0aCAtIDEpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IHRoaXMuX21hdGNoUGF0dGVybihjb3VudGVyLCBwYXR0ZXJuKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogbWF0Y2hQYXR0ZXJuJywgZXJyb3IsIGNvdW50ZXIsIHBhdHRlcm4pO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvciA8IGVwc2lsb24gJiYgYmVzdE1hdGNoLmVycm9yICYmIGVycm9yIDwgYmVzdE1hdGNoLmVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLmVycm9yID0gZXJyb3I7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5zdGFydCA9IGkgLSBjb3VudGVyLnJlZHVjZSgoc3VtLCB2YWx1ZSkgPT4gc3VtICsgdmFsdWUsIDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guZW5kID0gaTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIHJldHVybiBiZXN0TWF0Y2gnLCBKU09OLnN0cmluZ2lmeShiZXN0TWF0Y2gpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJlc3RNYXRjaDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRyeUhhcmRlcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNvdW50ZXIubGVuZ3RoIC0gMjsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyW2pdID0gY291bnRlcltqICsgMl07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlcltjb3VudGVyLmxlbmd0aCAtIDJdID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlcltjb3VudGVyLmxlbmd0aCAtIDFdID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlclBvcy0tO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY291bnRlclBvcysrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY291bnRlcltjb3VudGVyUG9zXSA9IDE7XHJcbiAgICAgICAgICAgICAgICBpc1doaXRlID0gIWlzV2hpdGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGZvdW5kKSB7XHJcbiAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybignKiByZXR1cm4gYmVzdE1hdGNoJywgSlNPTi5zdHJpbmdpZnkoYmVzdE1hdGNoKSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIHJldHVybiBudWxsJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmb3VuZCA/IGJlc3RNYXRjaCA6IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVE9ETzogZmluZFBhdHRlcm4gYW5kIGRlY29kZUNvZGUgYXBwZWFyIHRvIHNoYXJlIHF1aXRlIHNpbWlsYXIgY29kZSwgY2FuIGl0IGJlIHJlZHVjZWQ/XHJcbiAgICBwcm90ZWN0ZWQgX2RlY29kZUNvZGUoc3RhcnQ6IG51bWJlciwgY29kZXJhbmdlPzogbnVtYmVyKTogQmFyY29kZUluZm8gfCBudWxsIHtcclxuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogZGVjb2RlQ29kZScsIHN0YXJ0LCBjb2RlcmFuZ2UpO1xyXG4gICAgICAgIGNvbnN0IGNvdW50ZXIgPSBbMCwgMCwgMCwgMF07XHJcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gc3RhcnQ7XHJcbiAgICAgICAgY29uc3QgYmVzdE1hdGNoOiBCYXJjb2RlSW5mbyA9IHtcclxuICAgICAgICAgICAgZXJyb3I6IE51bWJlci5NQVhfVkFMVUUsXHJcbiAgICAgICAgICAgIGNvZGU6IC0xLFxyXG4gICAgICAgICAgICBzdGFydDogc3RhcnQsXHJcbiAgICAgICAgICAgIGVuZDogc3RhcnRcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNvbnN0IGVwc2lsb24gPSBBVkdfQ09ERV9FUlJPUjtcclxuICAgICAgICBsZXQgaXNXaGl0ZSA9ICF0aGlzLl9yb3dbb2Zmc2V0XTtcclxuICAgICAgICBsZXQgY291bnRlclBvcyA9IDA7XHJcblxyXG4gICAgICAgIGlmICghY29kZXJhbmdlKSB7XHJcbiAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybignKiBkZWNvZGVDb2RlIGJlZm9yZSBsZW5ndGgnKTtcclxuICAgICAgICAgICAgY29kZXJhbmdlID0gQ09ERV9QQVRURVJOLmxlbmd0aDtcclxuICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIGRlY29kZUNvZGUgYWZ0ZXIgbGVuZ3RoJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgZm91bmQgPSBmYWxzZTtcclxuICAgICAgICBmb3IgKGxldCBpID0gb2Zmc2V0OyBpIDwgdGhpcy5fcm93Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9yb3dbaV0gXiAoaXNXaGl0ZSA/IDEgOiAwKSkge1xyXG4gICAgICAgICAgICAgICAgY291bnRlcltjb3VudGVyUG9zXSsrO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvdW50ZXJQb3MgPT09IGNvdW50ZXIubGVuZ3RoIC0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGNvZGUgPSAwOyBjb2RlIDwgY29kZXJhbmdlOyBjb2RlKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLl9tYXRjaFBhdHRlcm4oY291bnRlciwgQ09ERV9QQVRURVJOW2NvZGVdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLmVuZCA9IGk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnJvciA8IGJlc3RNYXRjaC5lcnJvciEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5jb2RlID0gY29kZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5lcnJvciA9IGVycm9yO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChiZXN0TWF0Y2guZXJyb3IhID4gZXBzaWxvbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogcmV0dXJuIG51bGwnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybignKiByZXR1cm4gYmVzdE1hdGNoJywgSlNPTi5zdHJpbmdpZnkoYmVzdE1hdGNoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJlc3RNYXRjaDtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY291bnRlclBvcysrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY291bnRlcltjb3VudGVyUG9zXSA9IDE7XHJcbiAgICAgICAgICAgICAgICBpc1doaXRlID0gIWlzV2hpdGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZvdW5kID8gYmVzdE1hdGNoIDogbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgX2ZpbmRTdGFydCgpOiBCYXJjb2RlUG9zaXRpb24gfCBudWxsIHtcclxuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogZmluZFN0YXJ0Jyk7XHJcbiAgICAgICAgbGV0IG9mZnNldCA9IHRoaXMuX25leHRTZXQodGhpcy5fcm93KTtcclxuICAgICAgICBsZXQgc3RhcnRJbmZvOiBCYXJjb2RlUG9zaXRpb24gfCBudWxsID0gbnVsbDtcclxuXHJcbiAgICAgICAgd2hpbGUgKCFzdGFydEluZm8pIHtcclxuICAgICAgICAgICAgc3RhcnRJbmZvID0gdGhpcy5fZmluZFBhdHRlcm4oU1RBUlRfUEFUVEVSTiwgb2Zmc2V0LCBmYWxzZSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybignKiBzdGFydEluZm89JywgSlNPTi5zdHJpbmdpZnkoc3RhcnRJbmZvKSk7XHJcbiAgICAgICAgICAgIGlmICghc3RhcnRJbmZvKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgY29uc3QgbGVhZGluZ1doaXRlc3BhY2VTdGFydCA9IHN0YXJ0SW5mby5zdGFydCAtIChzdGFydEluZm8uZW5kIC0gc3RhcnRJbmZvLnN0YXJ0KTtcclxuXHJcbiAgICAgICAgICAgIGlmIChsZWFkaW5nV2hpdGVzcGFjZVN0YXJ0ID49IDApIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9tYXRjaFJhbmdlKGxlYWRpbmdXaGl0ZXNwYWNlU3RhcnQsIHN0YXJ0SW5mby5zdGFydCwgMCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogcmV0dXJuaW5nIHN0YXJ0SW5mbycpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdGFydEluZm87XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIG9mZnNldCA9IHN0YXJ0SW5mby5lbmQ7XHJcbiAgICAgICAgICAgIHN0YXJ0SW5mbyA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiByZXR1cm5pbmcgbnVsbCcpO1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgX2NhbGN1bGF0ZUZpcnN0RGlnaXQoY29kZUZyZXF1ZW5jeTogbnVtYmVyKTogbnVtYmVyIHwgbnVsbCB7XHJcbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIGNhbGN1bGF0ZUZpcnN0RGlnaXQnLCBjb2RlRnJlcXVlbmN5KTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IENPREVfRlJFUVVFTkNZLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChjb2RlRnJlcXVlbmN5ID09PSBDT0RFX0ZSRVFVRU5DWVtpXSkge1xyXG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIHJldHVybmluZycsIGkpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIHJldHVybiBudWxsJyk7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIF9kZWNvZGVQYXlsb2FkKGluQ29kZTogQmFyY29kZVBvc2l0aW9uLCByZXN1bHQ6IEFycmF5PG51bWJlcj4sIGRlY29kZWRDb2RlczogQXJyYXk8QmFyY29kZVBvc2l0aW9uPik6IEJhcmNvZGVJbmZvIHwgbnVsbCB7XHJcbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIGRlY29kZVBheWxvYWQnLCBpbkNvZGUsIHJlc3VsdCwgZGVjb2RlZENvZGVzKTtcclxuICAgICAgICBsZXQgb3V0Q29kZTogQmFyY29kZUluZm8gfCBCYXJjb2RlUG9zaXRpb24gfCBudWxsID0geyAuLi5pbkNvZGUgfTtcclxuICAgICAgICBsZXQgY29kZUZyZXF1ZW5jeSA9IDB4MDtcclxuXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA2OyBpKyspIHtcclxuICAgICAgICAgICAgb3V0Q29kZSA9IHRoaXMuX2RlY29kZUNvZGUob3V0Q29kZS5lbmQpO1xyXG4gICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogZGVjb2RlQ29kZT0nLCBvdXRDb2RlKTtcclxuICAgICAgICAgICAgaWYgKCFvdXRDb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogcmV0dXJuIG51bGwnKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICgob3V0Q29kZSBhcyBCYXJjb2RlSW5mbykuY29kZSA+PSBDT0RFX0dfU1RBUlQpIHtcclxuICAgICAgICAgICAgICAgIChvdXRDb2RlIGFzIEJhcmNvZGVJbmZvKS5jb2RlIC09IENPREVfR19TVEFSVDtcclxuICAgICAgICAgICAgICAgIGNvZGVGcmVxdWVuY3kgfD0gMSA8PCAoNSAtIGkpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29kZUZyZXF1ZW5jeSB8PSAwIDw8ICg1IC0gaSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmVzdWx0LnB1c2goKG91dENvZGUgYXMgQmFyY29kZUluZm8pLmNvZGUpO1xyXG4gICAgICAgICAgICBkZWNvZGVkQ29kZXMucHVzaChvdXRDb2RlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IGZpcnN0RGlnaXQgPSB0aGlzLl9jYWxjdWxhdGVGaXJzdERpZ2l0KGNvZGVGcmVxdWVuY3kpO1xyXG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiBmaXJzdERpZ2l0PScsIGZpcnN0RGlnaXQpO1xyXG4gICAgICAgIGlmIChmaXJzdERpZ2l0ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybignKiByZXR1cm4gbnVsbCcpO1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJlc3VsdC51bnNoaWZ0KGZpcnN0RGlnaXQpO1xyXG5cclxuICAgICAgICBsZXQgbWlkZGxlUGF0dGVybiA9IHRoaXMuX2ZpbmRQYXR0ZXJuKE1JRERMRV9QQVRURVJOLCBvdXRDb2RlLmVuZCwgdHJ1ZSwgZmFsc2UpO1xyXG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiBmaW5kUGF0dGVybj0nLCBKU09OLnN0cmluZ2lmeShtaWRkbGVQYXR0ZXJuKSk7XHJcblxyXG4gICAgICAgIGlmIChtaWRkbGVQYXR0ZXJuID09PSBudWxsIHx8ICFtaWRkbGVQYXR0ZXJuLmVuZCkge1xyXG4gICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogcmV0dXJuIG51bGwnKTtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBkZWNvZGVkQ29kZXMucHVzaChtaWRkbGVQYXR0ZXJuKTtcclxuXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA2OyBpKyspIHtcclxuICAgICAgICAgICAgbWlkZGxlUGF0dGVybiA9IHRoaXMuX2RlY29kZUNvZGUobWlkZGxlUGF0dGVybiEuZW5kLCBDT0RFX0dfU1RBUlQpO1xyXG4gICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogZGVjb2RlQ29kZT0nLCBKU09OLnN0cmluZ2lmeShtaWRkbGVQYXR0ZXJuKSk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIW1pZGRsZVBhdHRlcm4pIHtcclxuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybignKiByZXR1cm4gbnVsbCcpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGRlY29kZWRDb2Rlcy5wdXNoKG1pZGRsZVBhdHRlcm4pO1xyXG4gICAgICAgICAgICByZXN1bHQucHVzaCgobWlkZGxlUGF0dGVybiBhcyBCYXJjb2RlSW5mbykuY29kZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogZW5kIGNvZGU9JywgSlNPTi5zdHJpbmdpZnkobWlkZGxlUGF0dGVybikpO1xyXG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiBlbmQgcmVzdWx0PScsIEpTT04uc3RyaW5naWZ5KHJlc3VsdCkpO1xyXG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiBlbmQgZGVjb2RlZENvZGVzPScsIGRlY29kZWRDb2Rlcyk7XHJcbiAgICAgICAgcmV0dXJuIG1pZGRsZVBhdHRlcm4gYXMgQmFyY29kZUluZm87XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIF92ZXJpZnlUcmFpbGluZ1doaXRlc3BhY2UoZW5kSW5mbzogQmFyY29kZVBvc2l0aW9uKTogQmFyY29kZVBvc2l0aW9uIHwgbnVsbCB7XHJcbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIHZlcmlmeVRyYWlsaW5nV2hpdGVzcGFjZScsIEpTT04uc3RyaW5naWZ5KGVuZEluZm8pKTtcclxuICAgICAgICBjb25zdCB0cmFpbGluZ1doaXRlc3BhY2VFbmQgPSBlbmRJbmZvLmVuZCArIChlbmRJbmZvLmVuZCAtIGVuZEluZm8uc3RhcnQpO1xyXG5cclxuICAgICAgICBpZiAodHJhaWxpbmdXaGl0ZXNwYWNlRW5kIDwgdGhpcy5fcm93Lmxlbmd0aCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fbWF0Y2hSYW5nZShlbmRJbmZvLmVuZCwgdHJhaWxpbmdXaGl0ZXNwYWNlRW5kLCAwKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIHJldHVybmluZycsIEpTT04uc3RyaW5naWZ5KGVuZEluZm8pKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBlbmRJbmZvO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiByZXR1cm4gbnVsbCcpO1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBfZmluZEVuZChvZmZzZXQ6IG51bWJlciwgaXNXaGl0ZTogYm9vbGVhbik6IEJhcmNvZGVQb3NpdGlvbiB8IG51bGwge1xyXG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiBmaW5kRW5kJywgb2Zmc2V0LCBpc1doaXRlKTtcclxuICAgICAgICBjb25zdCBlbmRJbmZvID0gdGhpcy5fZmluZFBhdHRlcm4odGhpcy5TVE9QX1BBVFRFUk4sIG9mZnNldCwgaXNXaGl0ZSwgZmFsc2UpO1xyXG5cclxuICAgICAgICByZXR1cm4gZW5kSW5mbyAhPT0gbnVsbCA/IHRoaXMuX3ZlcmlmeVRyYWlsaW5nV2hpdGVzcGFjZShlbmRJbmZvKSA6IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIF9jaGVja3N1bShyZXN1bHQ6IEFycmF5PG51bWJlcj4pOiBib29sZWFuIHtcclxuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogX2NoZWNrc3VtJywgcmVzdWx0KTtcclxuICAgICAgICBsZXQgc3VtID0gMDtcclxuXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IHJlc3VsdC5sZW5ndGggLSAyOyBpID49IDA7IGkgLT0gMikge1xyXG4gICAgICAgICAgICBzdW0gKz0gcmVzdWx0W2ldO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc3VtICo9IDM7XHJcblxyXG4gICAgICAgIGZvciAobGV0IGkgPSByZXN1bHQubGVuZ3RoIC0gMTsgaSA+PSAwOyBpIC09IDIpIHtcclxuICAgICAgICAgICAgc3VtICs9IHJlc3VsdFtpXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiBlbmQgY2hlY2tzdW0nLCBzdW0gJSAxMCA9PT0gMCk7XHJcbiAgICAgICAgcmV0dXJuIHN1bSAlIDEwID09PSAwO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgX2RlY29kZUV4dGVuc2lvbnMob2Zmc2V0OiBudW1iZXIpOiBCYXJjb2RlIHwgbnVsbCB7XHJcbiAgICAgICAgY29uc3Qgc3RhcnQgPSB0aGlzLl9uZXh0U2V0KHRoaXMuX3Jvdywgb2Zmc2V0KTtcclxuICAgICAgICBjb25zdCBzdGFydEluZm8gPSB0aGlzLl9maW5kUGF0dGVybihFWFRFTlNJT05fU1RBUlRfUEFUVEVSTiwgc3RhcnQsIGZhbHNlLCBmYWxzZSk7XHJcblxyXG4gICAgICAgIGlmIChzdGFydEluZm8gPT09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogZGVjb2RlRXh0ZW5zaW9ucycsIHRoaXMuc3VwcGxlbWVudHMpO1xyXG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiB0aGVyZSBhcmUgJywgdGhpcy5zdXBwbGVtZW50cy5sZW5ndGgsICcgc3VwcGxlbWVudHMnKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc3VwcGxlbWVudHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIGV4dGVuc2lvbnMgbG9vcCcsIGksIHRoaXMuc3VwcGxlbWVudHNbaV0sIHRoaXMuc3VwcGxlbWVudHNbaV0uX2RlY29kZSk7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5zdXBwbGVtZW50c1tpXS5kZWNvZGUodGhpcy5fcm93LCBzdGFydEluZm8uZW5kKTtcclxuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybignKiBkZWNvZGUgcmVzdWx0PScsIHJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogcmVzdWx0LmNvZGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydEluZm8sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogcmVzdWx0LmVuZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVjb2RlZENvZGVzOiByZXN1bHQuZGVjb2RlZENvZGVzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3JtYXQ6IHRoaXMuc3VwcGxlbWVudHNbaV0uRk9STUFULFxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignKiBkZWNvZGVFeHRlbnNpb25zIGVycm9yIGluICcsIHRoaXMuc3VwcGxlbWVudHNbaV0sICc6ICcsIGVycik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiBlbmQgZGVjb2RlRXh0ZW5zaW9ucycpO1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBkZWNvZGUocm93PzogQXJyYXk8bnVtYmVyPiwgc3RhcnQ/OiBCYXJjb2RlUG9zaXRpb24gfCBudW1iZXIpOiBCYXJjb2RlIHwgbnVsbCB7XHJcbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIGRlY29kZScsIHJvdyk7XHJcbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIGRlY29kZScsIHN0YXJ0KTtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgQXJyYXk8bnVtYmVyPigpO1xyXG4gICAgICAgIGNvbnN0IGRlY29kZWRDb2RlcyA9IG5ldyBBcnJheTxCYXJjb2RlSW5mbyB8IEJhcmNvZGVQb3NpdGlvbj4oKTtcclxuICAgICAgICBsZXQgcmVzdWx0SW5mbzogQmFyY29kZSB8IHt9ID0ge307XHJcbiAgICAgICAgbGV0IHN0YXJ0SW5mbyA9IHRoaXMuX2ZpbmRTdGFydCgpO1xyXG5cclxuICAgICAgICBpZiAoIXN0YXJ0SW5mbykge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBjb2RlOiBCYXJjb2RlUG9zaXRpb24gfCBCYXJjb2RlSW5mbyB8IG51bGwgPSB7XHJcbiAgICAgICAgICAgIHN0YXJ0OiBzdGFydEluZm8uc3RhcnQsXHJcbiAgICAgICAgICAgIGVuZDogc3RhcnRJbmZvLmVuZFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgZGVjb2RlZENvZGVzLnB1c2goY29kZSk7XHJcblxyXG4gICAgICAgIGNvZGUgPSB0aGlzLl9kZWNvZGVQYXlsb2FkKGNvZGUsIHJlc3VsdCwgZGVjb2RlZENvZGVzKTtcclxuXHJcbiAgICAgICAgaWYgKCFjb2RlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29kZSA9IHRoaXMuX2ZpbmRFbmQoY29kZS5lbmQsIGZhbHNlKTtcclxuXHJcbiAgICAgICAgaWYgKCFjb2RlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZGVjb2RlZENvZGVzLnB1c2goY29kZSk7XHJcblxyXG4gICAgICAgIC8vIENoZWNrc3VtXHJcbiAgICAgICAgaWYgKCF0aGlzLl9jaGVja3N1bShyZXN1bHQpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIHRoaXMuc3VwcGxlbWVudHM9JywgdGhpcy5zdXBwbGVtZW50cyk7XHJcbiAgICAgICAgaWYgKHRoaXMuc3VwcGxlbWVudHMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBjb25zdCBzdXBwbGVtZW50ID0gdGhpcy5fZGVjb2RlRXh0ZW5zaW9ucyhjb2RlLmVuZCk7XHJcbiAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybignKiBkZWNvZGVFeHRlbnNpb25zIHJldHVybnMnLCBzdXBwbGVtZW50KTtcclxuICAgICAgICAgICAgaWYgKCFzdXBwbGVtZW50KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCFzdXBwbGVtZW50LmRlY29kZWRDb2Rlcykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGxhc3RDb2RlID0gc3VwcGxlbWVudC5kZWNvZGVkQ29kZXNbc3VwcGxlbWVudC5kZWNvZGVkQ29kZXMubGVuZ3RoIC0gMV0gYXMgQmFyY29kZUluZm87XHJcbiAgICAgICAgICAgIGNvbnN0IGVuZEluZm8gPSB7XHJcbiAgICAgICAgICAgICAgICBzdGFydDogbGFzdENvZGUuc3RhcnQgKyAoKChsYXN0Q29kZS5lbmQgLSBsYXN0Q29kZS5zdGFydCkgLyAyKSB8IDApLFxyXG4gICAgICAgICAgICAgICAgZW5kOiBsYXN0Q29kZS5lbmRcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fdmVyaWZ5VHJhaWxpbmdXaGl0ZXNwYWNlKGVuZEluZm8pKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmVzdWx0SW5mbyA9IHtcclxuICAgICAgICAgICAgICAgIHN1cHBsZW1lbnQsXHJcbiAgICAgICAgICAgICAgICBjb2RlOiByZXN1bHQuam9pbignJykgKyBzdXBwbGVtZW50LmNvZGVcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGNvZGU6IHJlc3VsdC5qb2luKCcnKSxcclxuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0SW5mby5zdGFydCxcclxuICAgICAgICAgICAgZW5kOiBjb2RlLmVuZCxcclxuICAgICAgICAgICAgc3RhcnRJbmZvLFxyXG4gICAgICAgICAgICBkZWNvZGVkQ29kZXMsXHJcbiAgICAgICAgICAgIC4uLnJlc3VsdEluZm8sXHJcbiAgICAgICAgICAgIGZvcm1hdDogdGhpcy5GT1JNQVQsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgRUFOUmVhZGVyO1xyXG4iLCJpbXBvcnQgQmFyY29kZVJlYWRlciwgeyBCYXJjb2RlUG9zaXRpb24sIEJhcmNvZGUgfSBmcm9tICcuL2JhcmNvZGVfcmVhZGVyJztcclxuaW1wb3J0IEFycmF5SGVscGVyIGZyb20gJy4uL2NvbW1vbi9hcnJheV9oZWxwZXInO1xyXG5cclxuY29uc3QgQUxQSEFCRVRIX1NUUklORyA9ICcwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVotLiAqJC8rJSc7XHJcbmNvbnN0IEFMUEhBQkVUID0gbmV3IFVpbnQxNkFycmF5KFsuLi5BTFBIQUJFVEhfU1RSSU5HXS5tYXAoY2hhciA9PiBjaGFyLmNoYXJDb2RlQXQoMCkpKTtcclxuY29uc3QgQ0hBUkFDVEVSX0VOQ09ESU5HUyA9IG5ldyBVaW50MTZBcnJheShbXHJcbiAgICAweDAzNCwgMHgxMjEsIDB4MDYxLCAweDE2MCwgMHgwMzEsIDB4MTMwLCAweDA3MCwgMHgwMjUsIDB4MTI0LCAweDA2NCwgMHgxMDksIDB4MDQ5LFxyXG4gICAgMHgxNDgsIDB4MDE5LCAweDExOCwgMHgwNTgsIDB4MDBELCAweDEwQywgMHgwNEMsIDB4MDFDLCAweDEwMywgMHgwNDMsIDB4MTQyLCAweDAxMywgMHgxMTIsIDB4MDUyLCAweDAwNywgMHgxMDYsXHJcbiAgICAweDA0NiwgMHgwMTYsIDB4MTgxLCAweDBDMSwgMHgxQzAsIDB4MDkxLCAweDE5MCwgMHgwRDAsIDB4MDg1LCAweDE4NCwgMHgwQzQsIDB4MDk0LCAweDBBOCwgMHgwQTIsIDB4MDhBLCAweDAyQSxcclxuXSk7XHJcbmNvbnN0IEFTVEVSSVNLID0gMHgwOTQ7XHJcblxyXG5jbGFzcyBDb2RlMzlSZWFkZXIgZXh0ZW5kcyBCYXJjb2RlUmVhZGVyIHtcclxuICAgIEZPUk1BVCA9ICdjb2RlXzM5JztcclxuXHJcbiAgICBwcm90ZWN0ZWQgX2ZpbmRTdGFydCgpOiBCYXJjb2RlUG9zaXRpb24gfCBudWxsIHtcclxuICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLl9uZXh0U2V0KHRoaXMuX3Jvdyk7XHJcbiAgICAgICAgbGV0IHBhdHRlcm5TdGFydCA9IG9mZnNldDtcclxuICAgICAgICBjb25zdCBjb3VudGVyID0gbmV3IFVpbnQxNkFycmF5KFswLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwXSk7XHJcbiAgICAgICAgbGV0IGNvdW50ZXJQb3MgPSAwO1xyXG4gICAgICAgIGxldCBpc1doaXRlID0gZmFsc2U7XHJcblxyXG4gICAgICAgIGZvciAobGV0IGkgPSBvZmZzZXQ7IGkgPCB0aGlzLl9yb3cubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX3Jvd1tpXSBeIChpc1doaXRlID8gMSA6IDApKSB7XHJcbiAgICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXJQb3NdKys7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY291bnRlclBvcyA9PT0gY291bnRlci5sZW5ndGggLSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZmluZCBzdGFydCBwYXR0ZXJuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3RvUGF0dGVybihjb3VudGVyKSA9PT0gQVNURVJJU0spIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgd2hpdGVTcGFjZU11c3RTdGFydCA9IE1hdGguZmxvb3IoTWF0aC5tYXgoMCwgcGF0dGVyblN0YXJ0IC0gKChpIC0gcGF0dGVyblN0YXJ0KSAvIDQpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9tYXRjaFJhbmdlKHdoaXRlU3BhY2VNdXN0U3RhcnQsIHBhdHRlcm5TdGFydCwgMCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHBhdHRlcm5TdGFydCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IGksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuU3RhcnQgKz0gY291bnRlclswXSArIGNvdW50ZXJbMV07XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCA3OyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlcltqXSA9IGNvdW50ZXJbaiArIDJdO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjb3VudGVyWzddID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBjb3VudGVyWzhdID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBjb3VudGVyUG9zLS07XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJQb3MrKztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvdW50ZXJbY291bnRlclBvc10gPSAxO1xyXG4gICAgICAgICAgICAgICAgaXNXaGl0ZSA9ICFpc1doaXRlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfTtcclxuXHJcbiAgICBwcm90ZWN0ZWQgX3RvUGF0dGVybihjb3VudGVyczogVWludDE2QXJyYXkpOiBudW1iZXIge1xyXG4gICAgICAgIGNvbnN0IG51bUNvdW50ZXJzID0gY291bnRlcnMubGVuZ3RoO1xyXG4gICAgICAgIGxldCBtYXhOYXJyb3dXaWR0aCA9IDA7XHJcbiAgICAgICAgbGV0IG51bVdpZGVCYXJzID0gbnVtQ291bnRlcnM7XHJcbiAgICAgICAgbGV0IHdpZGVCYXJXaWR0aCA9IDA7XHJcblxyXG4gICAgICAgIHdoaWxlIChudW1XaWRlQmFycyA+IDMpIHtcclxuICAgICAgICAgICAgbWF4TmFycm93V2lkdGggPSB0aGlzLl9maW5kTmV4dFdpZHRoKGNvdW50ZXJzLCBtYXhOYXJyb3dXaWR0aCk7XHJcbiAgICAgICAgICAgIG51bVdpZGVCYXJzID0gMDtcclxuICAgICAgICAgICAgbGV0IHBhdHRlcm4gPSAwO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUNvdW50ZXJzOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChjb3VudGVyc1tpXSA+IG1heE5hcnJvd1dpZHRoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGF0dGVybiB8PSAxIDw8IChudW1Db3VudGVycyAtIDEgLSBpKTtcclxuICAgICAgICAgICAgICAgICAgICBudW1XaWRlQmFycysrO1xyXG4gICAgICAgICAgICAgICAgICAgIHdpZGVCYXJXaWR0aCArPSBjb3VudGVyc1tpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKG51bVdpZGVCYXJzID09PSAzKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUNvdW50ZXJzICYmIG51bVdpZGVCYXJzID4gMDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvdW50ZXJzW2ldID4gbWF4TmFycm93V2lkdGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbnVtV2lkZUJhcnMtLTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChjb3VudGVyc1tpXSAqIDIpID49IHdpZGVCYXJXaWR0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhdHRlcm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgfTtcclxuXHJcbiAgICBwcm90ZWN0ZWQgX2ZpbmROZXh0V2lkdGgoY291bnRlcnM6IFVpbnQxNkFycmF5LCBjdXJyZW50OiBudW1iZXIpOiBudW1iZXIge1xyXG4gICAgICAgIGxldCBtaW5XaWR0aCA9IE51bWJlci5NQVhfVkFMVUU7XHJcblxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnRlcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGNvdW50ZXJzW2ldIDwgbWluV2lkdGggJiYgY291bnRlcnNbaV0gPiBjdXJyZW50KSB7XHJcbiAgICAgICAgICAgICAgICBtaW5XaWR0aCA9IGNvdW50ZXJzW2ldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbWluV2lkdGg7XHJcbiAgICB9O1xyXG5cclxuICAgIHByb3RlY3RlZCBfcGF0dGVyblRvQ2hhcihwYXR0ZXJuOiBudW1iZXIpOiBzdHJpbmcgfCBudWxsIHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IENIQVJBQ1RFUl9FTkNPRElOR1MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKENIQVJBQ1RFUl9FTkNPRElOR1NbaV0gPT09IHBhdHRlcm4pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKEFMUEhBQkVUW2ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH07XHJcblxyXG4gICAgcHJvdGVjdGVkIF92ZXJpZnlUcmFpbGluZ1doaXRlc3BhY2UobGFzdFN0YXJ0OiBudW1iZXIsIG5leHRTdGFydDogbnVtYmVyLCBjb3VudGVyczogVWludDE2QXJyYXkpOiBib29sZWFuIHtcclxuICAgICAgICBjb25zdCBwYXR0ZXJuU2l6ZSA9IEFycmF5SGVscGVyLnN1bShjb3VudGVycyk7XHJcblxyXG4gICAgICAgIGNvbnN0IHRyYWlsaW5nV2hpdGVzcGFjZUVuZCA9IG5leHRTdGFydCAtIGxhc3RTdGFydCAtIHBhdHRlcm5TaXplO1xyXG4gICAgICAgIGlmICgodHJhaWxpbmdXaGl0ZXNwYWNlRW5kICogMykgPj0gcGF0dGVyblNpemUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIGRlY29kZShyb3c/OiBBcnJheTxudW1iZXI+LCBzdGFydD86IEJhcmNvZGVQb3NpdGlvbiB8IG51bWJlciB8IG51bGwpOiBCYXJjb2RlIHwgbnVsbCB7XHJcbiAgICAgICAgbGV0IGNvdW50ZXJzID0gbmV3IFVpbnQxNkFycmF5KFswLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwXSk7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0OiBBcnJheTxzdHJpbmc+ID0gW107XHJcbiAgICAgICAgc3RhcnQgPSB0aGlzLl9maW5kU3RhcnQoKTtcclxuXHJcbiAgICAgICAgaWYgKCFzdGFydCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IG5leHRTdGFydCA9IHRoaXMuX25leHRTZXQodGhpcy5fcm93LCBzdGFydC5lbmQpO1xyXG5cclxuICAgICAgICBsZXQgZGVjb2RlZENoYXI7XHJcbiAgICAgICAgbGV0IGxhc3RTdGFydDogbnVtYmVyO1xyXG4gICAgICAgIGRvIHtcclxuICAgICAgICAgICAgY291bnRlcnMgPSB0aGlzLl90b0NvdW50ZXJzKG5leHRTdGFydCwgY291bnRlcnMpIGFzIFVpbnQxNkFycmF5O1xyXG4gICAgICAgICAgICBjb25zdCBwYXR0ZXJuID0gdGhpcy5fdG9QYXR0ZXJuKGNvdW50ZXJzKTtcclxuICAgICAgICAgICAgaWYgKHBhdHRlcm4gPCAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkZWNvZGVkQ2hhciA9IHRoaXMuX3BhdHRlcm5Ub0NoYXIocGF0dGVybik7XHJcbiAgICAgICAgICAgIGlmIChkZWNvZGVkQ2hhciA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmVzdWx0LnB1c2goZGVjb2RlZENoYXIpO1xyXG4gICAgICAgICAgICBsYXN0U3RhcnQgPSBuZXh0U3RhcnQ7XHJcbiAgICAgICAgICAgIG5leHRTdGFydCArPSBBcnJheUhlbHBlci5zdW0oY291bnRlcnMpO1xyXG4gICAgICAgICAgICBuZXh0U3RhcnQgPSB0aGlzLl9uZXh0U2V0KHRoaXMuX3JvdywgbmV4dFN0YXJ0KTtcclxuICAgICAgICB9IHdoaWxlIChkZWNvZGVkQ2hhciAhPT0gJyonKTtcclxuICAgICAgICByZXN1bHQucG9wKCk7XHJcblxyXG4gICAgICAgIGlmICghcmVzdWx0Lmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghdGhpcy5fdmVyaWZ5VHJhaWxpbmdXaGl0ZXNwYWNlKGxhc3RTdGFydCwgbmV4dFN0YXJ0LCBjb3VudGVycykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBjb2RlOiByZXN1bHQuam9pbignJyksXHJcbiAgICAgICAgICAgIHN0YXJ0OiBzdGFydC5zdGFydCxcclxuICAgICAgICAgICAgZW5kOiBuZXh0U3RhcnQsXHJcbiAgICAgICAgICAgIHN0YXJ0SW5mbzogc3RhcnQsXHJcbiAgICAgICAgICAgIGRlY29kZWRDb2RlczogcmVzdWx0LFxyXG4gICAgICAgICAgICBmb3JtYXQ6IHRoaXMuRk9STUFULFxyXG4gICAgICAgIH07XHJcblxyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBDb2RlMzlSZWFkZXI7XHJcbiIsImltcG9ydCBDb2RlMzlSZWFkZXIgZnJvbSAnLi9jb2RlXzM5X3JlYWRlcic7XHJcbmltcG9ydCB7IEJhcmNvZGVQb3NpdGlvbiwgQmFyY29kZSB9IGZyb20gJy4vYmFyY29kZV9yZWFkZXInO1xyXG5cclxuY29uc3QgcGF0dGVybnMgPSB7XHJcbiAgICBJT1E6IC9bSU9RXS9nLFxyXG4gICAgQVowOTogL1tBLVowLTldezE3fS8sXHJcbn07XHJcblxyXG5jbGFzcyBDb2RlMzlWSU5SZWFkZXIgZXh0ZW5kcyBDb2RlMzlSZWFkZXIge1xyXG4gICAgRk9STUFUID0gJ2NvZGVfMzlfdmluJztcclxuXHJcbiAgICAvLyBUT0RPICh0aGlzIHdhcyB0b2RvIGluIG9yaWdpbmFsIHJlcG8sIG5vIHRleHQgd2FzIHRoZXJlLiBzb3JyeS4pXHJcbiAgICBwcm90ZWN0ZWQgX2NoZWNrQ2hlY2tzdW0oY29kZTogc3RyaW5nKTogYm9vbGVhbiB7XHJcbiAgICAgICAgcmV0dXJuICEhY29kZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBDcmliYmVkIGZyb206XHJcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20venhpbmcvenhpbmcvYmxvYi9tYXN0ZXIvY29yZS9zcmMvbWFpbi9qYXZhL2NvbS9nb29nbGUvenhpbmcvY2xpZW50L3Jlc3VsdC9WSU5SZXN1bHRQYXJzZXIuamF2YVxyXG4gICAgcHVibGljIGRlY29kZShyb3c/OiBBcnJheTxudW1iZXI+LCBzdGFydD86IEJhcmNvZGVQb3NpdGlvbik6IEJhcmNvZGUgfCBudWxsIHtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSBzdXBlci5kZWNvZGUocm93LCBzdGFydCk7XHJcbiAgICAgICAgaWYgKCFyZXN1bHQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgY29kZSA9IHJlc3VsdC5jb2RlO1xyXG5cclxuICAgICAgICBpZiAoIWNvZGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb2RlID0gY29kZS5yZXBsYWNlKHBhdHRlcm5zLklPUSwgJycpO1xyXG5cclxuICAgICAgICBpZiAoIWNvZGUubWF0Y2gocGF0dGVybnMuQVowOSkpIHtcclxuICAgICAgICAgICAgaWYgKEVOVi5kZXZlbG9wbWVudCkge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0ZhaWxlZCBBWjA5IHBhdHRlcm4gY29kZTonLCBjb2RlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghdGhpcy5fY2hlY2tDaGVja3N1bShjb2RlKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJlc3VsdC5jb2RlID0gY29kZTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgQ29kZTM5VklOUmVhZGVyO1xyXG4iLCJpbXBvcnQgQmFyY29kZVJlYWRlciwgeyBCYXJjb2RlLCBCYXJjb2RlUG9zaXRpb24gfSBmcm9tICcuL2JhcmNvZGVfcmVhZGVyJztcclxuXHJcbi8vIGNvbnN0IEFMUEhBQkVUSF9TVFJJTkcgPSAnMDEyMzQ1Njc4OS0kOi8uK0FCQ0QnO1xyXG5jb25zdCBBTFBIQUJFVCA9IFs0OCwgNDksIDUwLCA1MSwgNTIsIDUzLCA1NCwgNTUsIDU2LCA1NywgNDUsIDM2LCA1OCwgNDcsIDQ2LCA0MywgNjUsIDY2LCA2NywgNjhdO1xyXG5jb25zdCBDSEFSQUNURVJfRU5DT0RJTkdTID1cclxuICAgIFsweDAwMywgMHgwMDYsIDB4MDA5LCAweDA2MCwgMHgwMTIsIDB4MDQyLCAweDAyMSwgMHgwMjQsIDB4MDMwLCAweDA0OCwgMHgwMGMsIDB4MDE4LFxyXG4gICAgICAgIDB4MDQ1LCAweDA1MSwgMHgwNTQsIDB4MDE1LCAweDAxQSwgMHgwMjksIDB4MDBCLCAweDAwRV07XHJcbmNvbnN0IFNUQVJUX0VORCA9IFsweDAxQSwgMHgwMjksIDB4MDBCLCAweDAwRV07XHJcbmNvbnN0IE1JTl9FTkNPREVEX0NIQVJTID0gNDtcclxuY29uc3QgTUFYX0FDQ0VQVEFCTEUgPSAyLjA7XHJcbmNvbnN0IFBBRERJTkcgPSAxLjU7XHJcblxyXG5pbnRlcmZhY2UgVGhyZXNob2xkU2l6ZSB7XHJcbiAgICBzaXplOiBudW1iZXIsXHJcbiAgICBjb3VudHM6IG51bWJlcixcclxuICAgIG1pbjogbnVtYmVyLFxyXG4gICAgbWF4OiBudW1iZXIsXHJcbn07XHJcblxyXG5pbnRlcmZhY2UgVGhyZXNob2xkIHtcclxuICAgIHNwYWNlOiB7XHJcbiAgICAgICAgbmFycm93OiBUaHJlc2hvbGRTaXplLFxyXG4gICAgICAgIHdpZGU6IFRocmVzaG9sZFNpemUsXHJcbiAgICB9LFxyXG4gICAgYmFyOiB7XHJcbiAgICAgICAgbmFycm93OiBUaHJlc2hvbGRTaXplLFxyXG4gICAgICAgIHdpZGU6IFRocmVzaG9sZFNpemUsXHJcbiAgICB9LFxyXG59O1xyXG5cclxuY2xhc3MgTmV3Q29kYWJhclJlYWRlciBleHRlbmRzIEJhcmNvZGVSZWFkZXIge1xyXG4gICAgX2NvdW50ZXJzOiBBcnJheTxudW1iZXI+ID0gW107XHJcbiAgICBGT1JNQVQgPSAnY29kYWJhcic7XHJcblxyXG4gICAgcHJvdGVjdGVkIF9jb21wdXRlQWx0ZXJuYXRpbmdUaHJlc2hvbGQob2Zmc2V0OiBudW1iZXIsIGVuZDogbnVtYmVyKSB7XHJcbiAgICAgICAgbGV0IG1pbiA9IE51bWJlci5NQVhfVkFMVUU7XHJcbiAgICAgICAgbGV0IG1heCA9IDA7XHJcbiAgICAgICAgbGV0IGNvdW50ZXIgPSAwO1xyXG5cclxuICAgICAgICBmb3IgKGxldCBpID0gb2Zmc2V0OyBpIDwgZW5kOyBpICs9IDIpIHtcclxuICAgICAgICAgICAgY291bnRlciA9IHRoaXMuX2NvdW50ZXJzW2ldO1xyXG4gICAgICAgICAgICBpZiAoY291bnRlciA+IG1heCkge1xyXG4gICAgICAgICAgICAgICAgbWF4ID0gY291bnRlcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoY291bnRlciA8IG1pbikge1xyXG4gICAgICAgICAgICAgICAgbWluID0gY291bnRlcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuICgobWluICsgbWF4KSAvIDIuMCkgfCAwO1xyXG4gICAgfTtcclxuXHJcbiAgICBwcm90ZWN0ZWQgX3RvUGF0dGVybihvZmZzZXQ6IG51bWJlcikge1xyXG4gICAgICAgIGNvbnN0IG51bUNvdW50ZXJzID0gNztcclxuICAgICAgICBjb25zdCBlbmQgPSBvZmZzZXQgKyBudW1Db3VudGVycztcclxuXHJcbiAgICAgICAgaWYgKGVuZCA+IHRoaXMuX2NvdW50ZXJzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBiYXJUaHJlc2hvbGQgPSB0aGlzLl9jb21wdXRlQWx0ZXJuYXRpbmdUaHJlc2hvbGQob2Zmc2V0LCBlbmQpO1xyXG4gICAgICAgIGNvbnN0IHNwYWNlVGhyZXNob2xkID0gdGhpcy5fY29tcHV0ZUFsdGVybmF0aW5nVGhyZXNob2xkKG9mZnNldCArIDEsIGVuZCk7XHJcblxyXG4gICAgICAgIGxldCBiaXRtYXNrID0gMSA8PCAobnVtQ291bnRlcnMgLSAxKTtcclxuICAgICAgICBsZXQgdGhyZXNob2xkID0gMDtcclxuICAgICAgICBsZXQgcGF0dGVybiA9IDA7XHJcblxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtQ291bnRlcnM7IGkrKykge1xyXG4gICAgICAgICAgICB0aHJlc2hvbGQgPSAoaSAmIDEpID09PSAwID8gYmFyVGhyZXNob2xkIDogc3BhY2VUaHJlc2hvbGQ7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9jb3VudGVyc1tvZmZzZXQgKyBpXSA+IHRocmVzaG9sZCkge1xyXG4gICAgICAgICAgICAgICAgcGF0dGVybiB8PSBiaXRtYXNrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJpdG1hc2sgPj49IDE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gcGF0dGVybjtcclxuICAgIH07XHJcblxyXG4gICAgcHJvdGVjdGVkIF9pc1N0YXJ0RW5kKHBhdHRlcm46IG51bWJlcikge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgU1RBUlRfRU5ELmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChTVEFSVF9FTkRbaV0gPT09IHBhdHRlcm4pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH07XHJcblxyXG4gICAgcHJvdGVjdGVkIF9zdW1Db3VudGVycyhzdGFydDogbnVtYmVyLCBlbmQ6IG51bWJlcikge1xyXG4gICAgICAgIGxldCBzdW0gPSAwO1xyXG5cclxuICAgICAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xyXG4gICAgICAgICAgICBzdW0gKz0gdGhpcy5fY291bnRlcnNbaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzdW07XHJcbiAgICB9O1xyXG5cclxuICAgIHByb3RlY3RlZCBfZmluZFN0YXJ0KCk6IEJhcmNvZGVQb3NpdGlvbiB8IG51bGwge1xyXG4gICAgICAgIGxldCBzdGFydCA9IHRoaXMuX25leHRVbnNldCh0aGlzLl9yb3cpO1xyXG4gICAgICAgIGxldCBlbmQgPSBzdGFydDtcclxuXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCB0aGlzLl9jb3VudGVycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBwYXR0ZXJuID0gdGhpcy5fdG9QYXR0ZXJuKGkpO1xyXG4gICAgICAgICAgICBpZiAocGF0dGVybiAhPT0gLTEgJiYgdGhpcy5faXNTdGFydEVuZChwYXR0ZXJuKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogTG9vayBmb3Igd2hpdGVzcGFjZSBhaGVhZFxyXG4gICAgICAgICAgICAgICAgc3RhcnQgKz0gdGhpcy5fc3VtQ291bnRlcnMoMCwgaSk7XHJcbiAgICAgICAgICAgICAgICBlbmQgPSBzdGFydCArIHRoaXMuX3N1bUNvdW50ZXJzKGksIGkgKyA4KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxyXG4gICAgICAgICAgICAgICAgICAgIGVuZDogZW5kLFxyXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0Q291bnRlcjogaSxcclxuICAgICAgICAgICAgICAgICAgICBlbmRDb3VudGVyOiBpICsgOCxcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIF9wYXR0ZXJuVG9DaGFyKHBhdHRlcm46IG51bWJlcikge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgQ0hBUkFDVEVSX0VOQ09ESU5HUy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoQ0hBUkFDVEVSX0VOQ09ESU5HU1tpXSA9PT0gcGF0dGVybikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoQUxQSEFCRVRbaV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfTtcclxuXHJcbiAgICBwcm90ZWN0ZWQgX2NhbGN1bGF0ZVBhdHRlcm5MZW5ndGgob2Zmc2V0OiBudW1iZXIpIHtcclxuICAgICAgICBsZXQgc3VtID0gMDtcclxuXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IG9mZnNldDsgaSA8IG9mZnNldCArIDc7IGkrKykge1xyXG4gICAgICAgICAgICBzdW0gKz0gdGhpcy5fY291bnRlcnNbaV07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gc3VtO1xyXG4gICAgfTtcclxuXHJcbiAgICBwcm90ZWN0ZWQgX3ZlcmlmeVdoaXRlc3BhY2Uoc3RhcnRDb3VudGVyOiBudW1iZXIsIGVuZENvdW50ZXI6IG51bWJlcikge1xyXG4gICAgICAgIGlmICgoc3RhcnRDb3VudGVyIC0gMSA8PSAwKVxyXG4gICAgICAgICAgICB8fCB0aGlzLl9jb3VudGVyc1tzdGFydENvdW50ZXIgLSAxXSA+PSAodGhpcy5fY2FsY3VsYXRlUGF0dGVybkxlbmd0aChzdGFydENvdW50ZXIpIC8gMi4wKSkge1xyXG4gICAgICAgICAgICBpZiAoKGVuZENvdW50ZXIgKyA4ID49IHRoaXMuX2NvdW50ZXJzLmxlbmd0aClcclxuICAgICAgICAgICAgICAgIHx8IHRoaXMuX2NvdW50ZXJzW2VuZENvdW50ZXIgKyA3XSA+PSAodGhpcy5fY2FsY3VsYXRlUGF0dGVybkxlbmd0aChlbmRDb3VudGVyKSAvIDIuMCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH07XHJcblxyXG4gICAgcHJvdGVjdGVkIF9jaGFyVG9QYXR0ZXJuKGNoYXI6IHN0cmluZykge1xyXG4gICAgICAgIGNvbnN0IGNoYXJDb2RlID0gY2hhci5jaGFyQ29kZUF0KDApO1xyXG5cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IEFMUEhBQkVULmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChBTFBIQUJFVFtpXSA9PT0gY2hhckNvZGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBDSEFSQUNURVJfRU5DT0RJTkdTW2ldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAweDA7XHJcbiAgICB9O1xyXG5cclxuICAgIHByb3RlY3RlZCBfdGhyZXNob2xkUmVzdWx0UGF0dGVybihyZXN1bHQ6IFJlYWRvbmx5QXJyYXk8c3RyaW5nPiwgc3RhcnRDb3VudGVyOiBudW1iZXIpIHtcclxuICAgICAgICBjb25zdCBjYXRlZ29yaXphdGlvbjogVGhyZXNob2xkID0ge1xyXG4gICAgICAgICAgICAgICAgc3BhY2U6IHtcclxuICAgICAgICAgICAgICAgICAgICBuYXJyb3c6IHsgc2l6ZTogMCwgY291bnRzOiAwLCBtaW46IDAsIG1heDogTnVtYmVyLk1BWF9WQUxVRSB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHdpZGU6IHsgc2l6ZTogMCwgY291bnRzOiAwLCBtaW46IDAsIG1heDogTnVtYmVyLk1BWF9WQUxVRSB9LFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGJhcjoge1xyXG4gICAgICAgICAgICAgICAgICAgIG5hcnJvdzogeyBzaXplOiAwLCBjb3VudHM6IDAsIG1pbjogMCwgbWF4OiBOdW1iZXIuTUFYX1ZBTFVFIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgd2lkZTogeyBzaXplOiAwLCBjb3VudHM6IDAsIG1pbjogMCwgbWF4OiBOdW1iZXIuTUFYX1ZBTFVFIH0sXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIGxldCBwb3MgPSBzdGFydENvdW50ZXI7XHJcbiAgICAgICAgbGV0IHBhdHRlcm46IG51bWJlcjtcclxuXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXN1bHQubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgcGF0dGVybiA9IHRoaXMuX2NoYXJUb1BhdHRlcm4ocmVzdWx0W2ldKTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDY7IGogPj0gMDsgai0tKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBraW5kID0gKGogJiAxKSA9PT0gMiA/IGNhdGVnb3JpemF0aW9uLmJhciA6IGNhdGVnb3JpemF0aW9uLnNwYWNlO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY2F0ID0gKHBhdHRlcm4gJiAxKSA9PT0gMSA/IGtpbmQud2lkZSA6IGtpbmQubmFycm93O1xyXG4gICAgICAgICAgICAgICAgY2F0LnNpemUgKz0gdGhpcy5fY291bnRlcnNbcG9zICsgal07XHJcbiAgICAgICAgICAgICAgICBjYXQuY291bnRzKys7XHJcbiAgICAgICAgICAgICAgICBwYXR0ZXJuID4+PSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHBvcyArPSA4O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgKFsnc3BhY2UnLCAnYmFyJ10gYXMgY29uc3QpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgICAgICBjb25zdCBuZXdraW5kID0gY2F0ZWdvcml6YXRpb25ba2V5XTtcclxuICAgICAgICAgICAgbmV3a2luZC53aWRlLm1pbiA9XHJcbiAgICAgICAgICAgICAgICBNYXRoLmZsb29yKChuZXdraW5kLm5hcnJvdy5zaXplIC8gbmV3a2luZC5uYXJyb3cuY291bnRzICsgbmV3a2luZC53aWRlLnNpemUgLyBuZXdraW5kLndpZGUuY291bnRzKSAvIDIpO1xyXG4gICAgICAgICAgICBuZXdraW5kLm5hcnJvdy5tYXggPSBNYXRoLmNlaWwobmV3a2luZC53aWRlLm1pbik7XHJcbiAgICAgICAgICAgIG5ld2tpbmQud2lkZS5tYXggPSBNYXRoLmNlaWwoKG5ld2tpbmQud2lkZS5zaXplICogTUFYX0FDQ0VQVEFCTEUgKyBQQURESU5HKSAvIG5ld2tpbmQud2lkZS5jb3VudHMpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZXR1cm4gY2F0ZWdvcml6YXRpb247XHJcbiAgICB9O1xyXG5cclxuICAgIHByb3RlY3RlZCBfdmFsaWRhdGVSZXN1bHQocmVzdWx0OiBSZWFkb25seUFycmF5PHN0cmluZz4sIHN0YXJ0Q291bnRlcjogbnVtYmVyKSB7XHJcbiAgICAgICAgY29uc3QgdGhyZXNob2xkcyA9IHRoaXMuX3RocmVzaG9sZFJlc3VsdFBhdHRlcm4ocmVzdWx0LCBzdGFydENvdW50ZXIpO1xyXG4gICAgICAgIGxldCBwb3MgPSBzdGFydENvdW50ZXI7XHJcbiAgICAgICAgbGV0IHBhdHRlcm46IG51bWJlcjtcclxuXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXN1bHQubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgcGF0dGVybiA9IHRoaXMuX2NoYXJUb1BhdHRlcm4ocmVzdWx0W2ldKTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDY7IGogPj0gMDsgai0tKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBraW5kID0gKGogJiAxKSA9PT0gMCA/IHRocmVzaG9sZHMuYmFyIDogdGhyZXNob2xkcy5zcGFjZTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNhdCA9IChwYXR0ZXJuICYgMSkgPT09IDEgPyBraW5kLndpZGUgOiBraW5kLm5hcnJvdztcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNpemUgPSB0aGlzLl9jb3VudGVyc1twb3MgKyBqXTtcclxuICAgICAgICAgICAgICAgIGlmIChzaXplIDwgY2F0Lm1pbiB8fCBzaXplID4gY2F0Lm1heCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHBhdHRlcm4gPj49IDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcG9zICs9IDg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgZGVjb2RlKHJvdz86IEFycmF5PG51bWJlcj4sIHN0YXJ0PzogQmFyY29kZVBvc2l0aW9uIHwgbnVtYmVyIHwgbnVsbCk6IEJhcmNvZGUgfCBudWxsIHtcclxuXHJcbiAgICAgICAgdGhpcy5fY291bnRlcnMgPSB0aGlzLl9maWxsQ291bnRlcnMoKTtcclxuICAgICAgICBzdGFydCA9IHRoaXMuX2ZpbmRTdGFydCgpO1xyXG4gICAgICAgIGlmICghc3RhcnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBuZXh0U3RhcnQgPSBzdGFydC5zdGFydENvdW50ZXIgYXMgbnVtYmVyO1xyXG5cclxuICAgICAgICBjb25zdCByZXN1bHQ6IEFycmF5PHN0cmluZz4gPSBbXTtcclxuICAgICAgICBsZXQgcGF0dGVybjogbnVtYmVyO1xyXG4gICAgICAgIGRvIHtcclxuICAgICAgICAgICAgcGF0dGVybiA9IHRoaXMuX3RvUGF0dGVybihuZXh0U3RhcnQpO1xyXG4gICAgICAgICAgICBpZiAocGF0dGVybiA8IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGRlY29kZWRDaGFyID0gdGhpcy5fcGF0dGVyblRvQ2hhcihwYXR0ZXJuKTtcclxuICAgICAgICAgICAgaWYgKGRlY29kZWRDaGFyID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXN1bHQucHVzaChkZWNvZGVkQ2hhcik7XHJcbiAgICAgICAgICAgIG5leHRTdGFydCArPSA4O1xyXG4gICAgICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCA+IDEgJiYgdGhpcy5faXNTdGFydEVuZChwYXR0ZXJuKSkge1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IHdoaWxlIChuZXh0U3RhcnQgPCB0aGlzLl9jb3VudGVycy5sZW5ndGgpO1xyXG5cclxuICAgICAgICAvLyB2ZXJpZnkgZW5kXHJcbiAgICAgICAgaWYgKChyZXN1bHQubGVuZ3RoIC0gMikgPCBNSU5fRU5DT0RFRF9DSEFSUyB8fCAhdGhpcy5faXNTdGFydEVuZChwYXR0ZXJuKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHZlcmlmeSBlbmQgd2hpdGUgc3BhY2VcclxuICAgICAgICBpZiAoIXRoaXMuX3ZlcmlmeVdoaXRlc3BhY2Uoc3RhcnQuc3RhcnRDb3VudGVyIGFzIG51bWJlciwgbmV4dFN0YXJ0IC0gOCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIXRoaXMuX3ZhbGlkYXRlUmVzdWx0KHJlc3VsdCwgc3RhcnQuc3RhcnRDb3VudGVyIGFzIG51bWJlcikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBuZXh0U3RhcnQgPSBuZXh0U3RhcnQgPiB0aGlzLl9jb3VudGVycy5sZW5ndGggPyB0aGlzLl9jb3VudGVycy5sZW5ndGggOiBuZXh0U3RhcnQ7XHJcbiAgICAgICAgY29uc3QgZW5kID0gc3RhcnQuc3RhcnQgKyB0aGlzLl9zdW1Db3VudGVycyhzdGFydC5zdGFydENvdW50ZXIgYXMgbnVtYmVyLCBuZXh0U3RhcnQgLSA4KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgY29kZTogcmVzdWx0LmpvaW4oJycpLFxyXG4gICAgICAgICAgICBzdGFydDogc3RhcnQuc3RhcnQsXHJcbiAgICAgICAgICAgIGVuZDogZW5kLFxyXG4gICAgICAgICAgICBzdGFydEluZm86IHN0YXJ0LFxyXG4gICAgICAgICAgICBkZWNvZGVkQ29kZXM6IHJlc3VsdCxcclxuICAgICAgICAgICAgZm9ybWF0OiB0aGlzLkZPUk1BVCwgLy8gVE9ETzogaSB0aGluayBpdCBzaG91bGQgbm90IGJlIHJlcXVpcmVkIHRvIHJldHVybiBmb3JtYXQgZnJvbSB0aGlzLCBhcyBiYXJjb2RlX3JlYWRlciBmb3JjZSBzZXRzIHRoZSBmb3JtYXQgYW55d2F5XHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IE5ld0NvZGFiYXJSZWFkZXI7XHJcbiIsImltcG9ydCBFQU5SZWFkZXIgZnJvbSAnLi9lYW5fcmVhZGVyJztcclxuaW1wb3J0IHsgQmFyY29kZVBvc2l0aW9uLCBCYXJjb2RlIH0gZnJvbSAnLi9iYXJjb2RlX3JlYWRlcic7XHJcblxyXG5jbGFzcyBVUENSZWFkZXIgZXh0ZW5kcyBFQU5SZWFkZXIge1xyXG4gICAgRk9STUFUID0gJ3VwY19hJztcclxuICAgIGRlY29kZShyb3c/OiBBcnJheTxudW1iZXI+LCBzdGFydD86IEJhcmNvZGVQb3NpdGlvbiB8IG51bWJlcik6IEJhcmNvZGUgfCBudWxsIHtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSBFQU5SZWFkZXIucHJvdG90eXBlLmRlY29kZS5jYWxsKHRoaXMpO1xyXG5cclxuICAgICAgICBpZiAocmVzdWx0ICYmIHJlc3VsdC5jb2RlICYmIHJlc3VsdC5jb2RlLmxlbmd0aCA9PT0gMTMgJiYgcmVzdWx0LmNvZGUuY2hhckF0KDApID09PSAnMCcpIHtcclxuICAgICAgICAgICAgcmVzdWx0LmNvZGUgPSByZXN1bHQuY29kZS5zdWJzdHJpbmcoMSk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBVUENSZWFkZXI7XHJcbiIsImltcG9ydCBFQU5SZWFkZXIsIHsgQ09ERV9HX1NUQVJULCBNSURETEVfUEFUVEVSTiB9IGZyb20gJy4vZWFuX3JlYWRlcic7XHJcbmltcG9ydCB7IEJhcmNvZGVQb3NpdGlvbiwgQmFyY29kZUluZm8gfSBmcm9tICcuL2JhcmNvZGVfcmVhZGVyJztcclxuXHJcbmNsYXNzIEVBTjhSZWFkZXIgZXh0ZW5kcyBFQU5SZWFkZXIge1xyXG4gICAgRk9STUFUID0gJ2Vhbl84JztcclxuICAgIHByb3RlY3RlZCBfZGVjb2RlUGF5bG9hZChpbkNvZGU6IEJhcmNvZGVQb3NpdGlvbiwgcmVzdWx0OiBBcnJheTxudW1iZXI+LCBkZWNvZGVkQ29kZXM6IEFycmF5PEJhcmNvZGVQb3NpdGlvbj4pOiBCYXJjb2RlSW5mbyB8IG51bGwge1xyXG4gICAgICAgIGxldCBjb2RlOiBCYXJjb2RlSW5mbyB8IEJhcmNvZGVQb3NpdGlvbiB8IG51bGwgPSBpbkNvZGU7XHJcblxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvZGUgPSB0aGlzLl9kZWNvZGVDb2RlKGNvZGUuZW5kLCBDT0RFX0dfU1RBUlQpO1xyXG4gICAgICAgICAgICBpZiAoIWNvZGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKChjb2RlIGFzIEJhcmNvZGVJbmZvKS5jb2RlKTtcclxuICAgICAgICAgICAgZGVjb2RlZENvZGVzLnB1c2goY29kZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb2RlID0gdGhpcy5fZmluZFBhdHRlcm4oTUlERExFX1BBVFRFUk4sIGNvZGUuZW5kLCB0cnVlLCBmYWxzZSk7XHJcbiAgICAgICAgaWYgKGNvZGUgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRlY29kZWRDb2Rlcy5wdXNoKGNvZGUpO1xyXG5cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKykge1xyXG4gICAgICAgICAgICBjb2RlID0gdGhpcy5fZGVjb2RlQ29kZShjb2RlLmVuZCwgQ09ERV9HX1NUQVJUKTtcclxuICAgICAgICAgICAgaWYgKCFjb2RlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkZWNvZGVkQ29kZXMucHVzaChjb2RlKTtcclxuICAgICAgICAgICAgcmVzdWx0LnB1c2goKGNvZGUgYXMgQmFyY29kZUluZm8pLmNvZGUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGNvZGUgYXMgQmFyY29kZUluZm87XHJcbiAgICB9O1xyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBFQU44UmVhZGVyO1xyXG4iLCJpbXBvcnQgRUFOUmVhZGVyLCB7IENPREVfR19TVEFSVCB9IGZyb20gJy4vZWFuX3JlYWRlcic7XHJcbmltcG9ydCB7IEJhcmNvZGVQb3NpdGlvbiwgQmFyY29kZSwgQmFyY29kZUluZm8gfSBmcm9tICcuL2JhcmNvZGVfcmVhZGVyJztcclxuXHJcblxyXG5jbGFzcyBFQU4yUmVhZGVyIGV4dGVuZHMgRUFOUmVhZGVyIHtcclxuICAgIEZPUk1BVCA9ICdlYW5fMic7XHJcbiAgICBwdWJsaWMgZGVjb2RlKHJvdz86IEFycmF5PG51bWJlcj4sIHN0YXJ0PzogbnVtYmVyKTogQmFyY29kZSB8IG51bGwge1xyXG4gICAgICAgIGlmIChyb3cpIHtcclxuICAgICAgICAgICAgdGhpcy5fcm93ID0gcm93O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IGNvZGVGcmVxdWVuY3kgPSAwO1xyXG4gICAgICAgIGxldCBvZmZzZXQgPSBzdGFydDtcclxuICAgICAgICBjb25zdCBlbmQgPSB0aGlzLl9yb3cubGVuZ3RoO1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xyXG4gICAgICAgIGNvbnN0IGRlY29kZWRDb2RlcyA9IFtdO1xyXG4gICAgICAgIGxldCBjb2RlOiBCYXJjb2RlSW5mbyB8IG51bGwgPSBudWxsO1xyXG5cclxuICAgICAgICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpe1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMiAmJiBvZmZzZXQgPCBlbmQ7IGkrKykge1xyXG4gICAgICAgICAgICBjb2RlID0gdGhpcy5fZGVjb2RlQ29kZShvZmZzZXQpO1xyXG4gICAgICAgICAgICBpZiAoIWNvZGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGRlY29kZWRDb2Rlcy5wdXNoKGNvZGUpO1xyXG4gICAgICAgICAgICByZXN1bHQucHVzaChjb2RlLmNvZGUgJSAxMCk7XHJcbiAgICAgICAgICAgIGlmIChjb2RlLmNvZGUgPj0gQ09ERV9HX1NUQVJUKSB7XHJcbiAgICAgICAgICAgICAgICBjb2RlRnJlcXVlbmN5IHw9IDEgPDwgKDEgLSBpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoaSAhPT0gMSkge1xyXG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gdGhpcy5fbmV4dFNldCh0aGlzLl9yb3csIGNvZGUuZW5kKTtcclxuICAgICAgICAgICAgICAgIG9mZnNldCA9IHRoaXMuX25leHRVbnNldCh0aGlzLl9yb3csIG9mZnNldCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChyZXN1bHQubGVuZ3RoICE9PSAyIHx8IChwYXJzZUludChyZXN1bHQuam9pbignJykpICUgNCkgIT09IGNvZGVGcmVxdWVuY3kpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBzdGFydEluZm8gPSB0aGlzLl9maW5kU3RhcnQoKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgY29kZTogcmVzdWx0LmpvaW4oJycpLFxyXG4gICAgICAgICAgICBkZWNvZGVkQ29kZXMsXHJcbiAgICAgICAgICAgIGVuZDogKGNvZGUgYXMgQmFyY29kZUluZm8pLmVuZCxcclxuICAgICAgICAgICAgZm9ybWF0OiB0aGlzLkZPUk1BVCxcclxuICAgICAgICAgICAgc3RhcnRJbmZvOiBzdGFydEluZm8gYXMgQmFyY29kZVBvc2l0aW9uLFxyXG4gICAgICAgICAgICBzdGFydDogKHN0YXJ0SW5mbyBhcyBCYXJjb2RlUG9zaXRpb24pLnN0YXJ0LFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBFQU4yUmVhZGVyO1xyXG4iLCJpbXBvcnQgRUFOUmVhZGVyLCB7IENPREVfR19TVEFSVCB9IGZyb20gJy4vZWFuX3JlYWRlcic7XHJcbmltcG9ydCB7IEJhcmNvZGUsIEJhcmNvZGVQb3NpdGlvbiwgQmFyY29kZUluZm8gfSBmcm9tICcuL2JhcmNvZGVfcmVhZGVyJztcclxuXHJcbmNvbnN0IENIRUNLX0RJR0lUX0VOQ09ESU5HUyA9IFsyNCwgMjAsIDE4LCAxNywgMTIsIDYsIDMsIDEwLCA5LCA1XTtcclxuXHJcbmZ1bmN0aW9uIGRldGVybWluZUNoZWNrRGlnaXQoY29kZUZyZXF1ZW5jeTogbnVtYmVyKSB7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEwOyBpKyspIHtcclxuICAgICAgICBpZiAoY29kZUZyZXF1ZW5jeSA9PT0gQ0hFQ0tfRElHSVRfRU5DT0RJTkdTW2ldKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG59XHJcblxyXG5mdW5jdGlvbiBleHRlbnNpb25DaGVja3N1bShyZXN1bHQ6IEFycmF5PG51bWJlcj4pIHtcclxuICAgIGNvbnN0IGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XHJcbiAgICBsZXQgc3VtID0gMDtcclxuXHJcbiAgICBmb3IgKGxldCBpID0gbGVuZ3RoIC0gMjsgaSA+PSAwOyBpIC09IDIpIHtcclxuICAgICAgICBzdW0gKz0gcmVzdWx0W2ldO1xyXG4gICAgfVxyXG4gICAgc3VtICo9IDM7XHJcbiAgICBmb3IgKGxldCBpID0gbGVuZ3RoIC0gMTsgaSA+PSAwOyBpIC09IDIpIHtcclxuICAgICAgICBzdW0gKz0gcmVzdWx0W2ldO1xyXG4gICAgfVxyXG4gICAgc3VtICo9IDM7XHJcbiAgICByZXR1cm4gc3VtICUgMTA7XHJcbn1cclxuXHJcbmNsYXNzIEVBTjVSZWFkZXIgZXh0ZW5kcyBFQU5SZWFkZXIge1xyXG4gICAgRk9STUFUID0gJ2Vhbl81JztcclxuICAgIHB1YmxpYyBkZWNvZGUocm93PzogQXJyYXk8bnVtYmVyPiwgc3RhcnQ/OiBudW1iZXIpOiBCYXJjb2RlIHwgbnVsbCB7XHJcbiAgICAgICAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAocm93KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3JvdyA9IHJvdztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBjb2RlRnJlcXVlbmN5ID0gMDtcclxuICAgICAgICBsZXQgb2Zmc2V0ID0gc3RhcnQ7XHJcbiAgICAgICAgY29uc3QgZW5kID0gdGhpcy5fcm93Lmxlbmd0aDtcclxuICAgICAgICBsZXQgY29kZTogQmFyY29kZUluZm8gfCBudWxsID0gbnVsbDtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcclxuICAgICAgICBjb25zdCBkZWNvZGVkQ29kZXMgPSBbXTtcclxuXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA1ICYmIG9mZnNldCA8IGVuZDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvZGUgPSB0aGlzLl9kZWNvZGVDb2RlKG9mZnNldCk7XHJcbiAgICAgICAgICAgIGlmICghY29kZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZGVjb2RlZENvZGVzLnB1c2goY29kZSk7XHJcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGNvZGUuY29kZSAlIDEwKTtcclxuICAgICAgICAgICAgaWYgKGNvZGUuY29kZSA+PSBDT0RFX0dfU1RBUlQpIHtcclxuICAgICAgICAgICAgICAgIGNvZGVGcmVxdWVuY3kgfD0gMSA8PCAoNCAtIGkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChpICE9PSA0KSB7XHJcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSB0aGlzLl9uZXh0U2V0KHRoaXMuX3JvdywgY29kZS5lbmQpO1xyXG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gdGhpcy5fbmV4dFVuc2V0KHRoaXMuX3Jvdywgb2Zmc2V0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggIT09IDUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoZXh0ZW5zaW9uQ2hlY2tzdW0ocmVzdWx0KSAhPT0gZGV0ZXJtaW5lQ2hlY2tEaWdpdChjb2RlRnJlcXVlbmN5KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHN0YXJ0SW5mbyA9IHRoaXMuX2ZpbmRTdGFydCgpO1xyXG5cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBjb2RlOiByZXN1bHQuam9pbignJyksXHJcbiAgICAgICAgICAgIGRlY29kZWRDb2RlcyxcclxuICAgICAgICAgICAgZW5kOiAoY29kZSBhcyBCYXJjb2RlSW5mbykuZW5kLFxyXG4gICAgICAgICAgICBmb3JtYXQ6IHRoaXMuRk9STUFULFxyXG4gICAgICAgICAgICBzdGFydEluZm86IHN0YXJ0SW5mbyBhcyBCYXJjb2RlUG9zaXRpb24sXHJcbiAgICAgICAgICAgIHN0YXJ0OiAoc3RhcnRJbmZvIGFzIEJhcmNvZGVQb3NpdGlvbikuc3RhcnQsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IEVBTjVSZWFkZXI7XHJcbiIsImltcG9ydCBFQU5SZWFkZXIsIHsgQ09ERV9HX1NUQVJUIH0gZnJvbSAnLi9lYW5fcmVhZGVyJztcclxuaW1wb3J0IHsgQmFyY29kZVBvc2l0aW9uLCBCYXJjb2RlSW5mbyB9IGZyb20gJy4vYmFyY29kZV9yZWFkZXInO1xyXG5cclxuY2xhc3MgVVBDRVJlYWRlciBleHRlbmRzIEVBTlJlYWRlciB7XHJcbiAgICBDT0RFX0ZSRVFVRU5DWSA9IFtcclxuICAgICAgICBbIDU2LCA1MiwgNTAsIDQ5LCA0NCwgMzgsIDM1LCA0MiwgNDEsIDM3IF0sXHJcbiAgICAgICAgWzcsIDExLCAxMywgMTQsIDE5LCAyNSwgMjgsIDIxLCAyMiwgMjZdXTtcclxuICAgIFNUT1BfUEFUVEVSTiA9IFsxIC8gNiAqIDcsIDEgLyA2ICogNywgMSAvIDYgKiA3LCAxIC8gNiAqIDcsIDEgLyA2ICogNywgMSAvIDYgKiA3XTtcclxuICAgIEZPUk1BVCA9ICd1cGNfZSc7XHJcbiAgICBwcm90ZWN0ZWQgX2RlY29kZVBheWxvYWQoaW5Db2RlOiBCYXJjb2RlUG9zaXRpb24sIHJlc3VsdDogQXJyYXk8bnVtYmVyPiwgZGVjb2RlZENvZGVzOiBBcnJheTxCYXJjb2RlUG9zaXRpb24+KTogQmFyY29kZUluZm8gfCBudWxsIHtcclxuICAgICAgICBsZXQgb3V0Q29kZTogQmFyY29kZUluZm8gfCBCYXJjb2RlUG9zaXRpb24gfCBudWxsID0geyAuLi5pbkNvZGUgfTtcclxuICAgICAgICBsZXQgY29kZUZyZXF1ZW5jeSA9IDB4MDtcclxuXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA2OyBpKyspIHtcclxuICAgICAgICAgICAgb3V0Q29kZSA9IHRoaXMuX2RlY29kZUNvZGUob3V0Q29kZS5lbmQpO1xyXG4gICAgICAgICAgICBpZiAoIW91dENvZGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICgob3V0Q29kZSBhcyBCYXJjb2RlSW5mbykuY29kZSA+PSBDT0RFX0dfU1RBUlQpIHtcclxuICAgICAgICAgICAgICAgIChvdXRDb2RlIGFzIEJhcmNvZGVJbmZvKS5jb2RlID0gKG91dENvZGUgYXMgQmFyY29kZUluZm8pLmNvZGUgLSBDT0RFX0dfU1RBUlQ7XHJcbiAgICAgICAgICAgICAgICBjb2RlRnJlcXVlbmN5IHw9ICgxIDw8ICg1IC0gaSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKChvdXRDb2RlIGFzIEJhcmNvZGVJbmZvKS5jb2RlKTtcclxuICAgICAgICAgICAgZGVjb2RlZENvZGVzLnB1c2gob3V0Q29kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdGhpcy5fZGV0ZXJtaW5lUGFyaXR5KGNvZGVGcmVxdWVuY3ksIHJlc3VsdCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBvdXRDb2RlIGFzIEJhcmNvZGVJbmZvO1xyXG4gICAgfTtcclxuXHJcbiAgICBwcm90ZWN0ZWQgX2RldGVybWluZVBhcml0eShjb2RlRnJlcXVlbmN5OiBudW1iZXIsIHJlc3VsdDogQXJyYXk8bnVtYmVyPikge1xyXG4gICAgICAgIGZvciAobGV0IG5yU3lzdGVtID0gMDsgbnJTeXN0ZW0gPCB0aGlzLkNPREVfRlJFUVVFTkNZLmxlbmd0aDsgbnJTeXN0ZW0rKyl7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5DT0RFX0ZSRVFVRU5DWVtuclN5c3RlbV0ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChjb2RlRnJlcXVlbmN5ID09PSB0aGlzLkNPREVfRlJFUVVFTkNZW25yU3lzdGVtXVtpXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC51bnNoaWZ0KG5yU3lzdGVtKTtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChpKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9O1xyXG5cclxuICAgIHByb3RlY3RlZCBfY29udmVydFRvVVBDQShyZXN1bHQ6IEFycmF5PG51bWJlcj4pIHtcclxuICAgICAgICBsZXQgdXBjYSA9IFtyZXN1bHRbMF1dO1xyXG4gICAgICAgIGNvbnN0IGxhc3REaWdpdCA9IHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMl07XHJcblxyXG4gICAgICAgIGlmIChsYXN0RGlnaXQgPD0gMikge1xyXG4gICAgICAgICAgICB1cGNhID0gdXBjYS5jb25jYXQocmVzdWx0LnNsaWNlKDEsIDMpKVxyXG4gICAgICAgICAgICAgICAgLmNvbmNhdChbbGFzdERpZ2l0LCAwLCAwLCAwLCAwXSlcclxuICAgICAgICAgICAgICAgIC5jb25jYXQocmVzdWx0LnNsaWNlKDMsIDYpKTtcclxuICAgICAgICB9IGVsc2UgaWYgKGxhc3REaWdpdCA9PT0gMykge1xyXG4gICAgICAgICAgICB1cGNhID0gdXBjYS5jb25jYXQocmVzdWx0LnNsaWNlKDEsIDQpKVxyXG4gICAgICAgICAgICAgICAgLmNvbmNhdChbMCwgMCwgMCwgMCwgMF0pXHJcbiAgICAgICAgICAgICAgICAuY29uY2F0KHJlc3VsdC5zbGljZSg0LCA2KSk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChsYXN0RGlnaXQgPT09IDQpIHtcclxuICAgICAgICAgICAgdXBjYSA9IHVwY2EuY29uY2F0KHJlc3VsdC5zbGljZSgxLCA1KSlcclxuICAgICAgICAgICAgICAgIC5jb25jYXQoWzAsIDAsIDAsIDAsIDAsIHJlc3VsdFs1XV0pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHVwY2EgPSB1cGNhLmNvbmNhdChyZXN1bHQuc2xpY2UoMSwgNikpXHJcbiAgICAgICAgICAgICAgICAuY29uY2F0KFswLCAwLCAwLCAwLCBsYXN0RGlnaXRdKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHVwY2EucHVzaChyZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdKTtcclxuICAgICAgICByZXR1cm4gdXBjYTtcclxuICAgIH07XHJcblxyXG4gICAgcHJvdGVjdGVkIF9jaGVja3N1bShyZXN1bHQ6IEFycmF5PG51bWJlcj4pOiBib29sZWFuIHtcclxuICAgICAgICByZXR1cm4gc3VwZXIuX2NoZWNrc3VtKHRoaXMuX2NvbnZlcnRUb1VQQ0EocmVzdWx0KSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIF9maW5kRW5kKG9mZnNldDogbnVtYmVyLCBpc1doaXRlOiBib29sZWFuKTogQmFyY29kZVBvc2l0aW9uIHwgbnVsbCB7XHJcbiAgICAgICAgcmV0dXJuIHN1cGVyLl9maW5kRW5kKG9mZnNldCwgdHJ1ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIF92ZXJpZnlUcmFpbGluZ1doaXRlc3BhY2UoZW5kSW5mbzogQmFyY29kZVBvc2l0aW9uKTogQmFyY29kZVBvc2l0aW9uIHwgbnVsbCB7XHJcbiAgICAgICAgY29uc3QgdHJhaWxpbmdXaGl0ZXNwYWNlRW5kID0gZW5kSW5mby5lbmQgKyAoKGVuZEluZm8uZW5kIC0gZW5kSW5mby5zdGFydCkgLyAyKTtcclxuICAgICAgICBpZiAodHJhaWxpbmdXaGl0ZXNwYWNlRW5kIDwgdGhpcy5fcm93Lmxlbmd0aCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fbWF0Y2hSYW5nZShlbmRJbmZvLmVuZCwgdHJhaWxpbmdXaGl0ZXNwYWNlRW5kLCAwKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVuZEluZm87XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9O1xyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBVUENFUmVhZGVyO1xyXG4iLCIvLyBUT0RPOiBpMm9mNV9yZWFkZXIgYW5kIDJvZjVfcmVhZGVyIHNoYXJlIHZlcnkgc2ltaWxhciBjb2RlLCBtYWtlIHVzZSBvZiB0aGF0XHJcblxyXG5pbXBvcnQgQmFyY29kZVJlYWRlciwgeyBCYXJjb2RlUmVhZGVyQ29uZmlnLCBCYXJjb2RlSW5mbywgQmFyY29kZVBvc2l0aW9uLCBCYXJjb2RlIH0gZnJvbSAnLi9iYXJjb2RlX3JlYWRlcic7XHJcbmltcG9ydCBtZXJnZSBmcm9tICdsb2Rhc2gvbWVyZ2UnO1xyXG5cclxuY29uc3QgTiA9IDE7XHJcbmNvbnN0IFcgPSAzO1xyXG5cclxuY2xhc3MgSTJvZjVSZWFkZXIgZXh0ZW5kcyBCYXJjb2RlUmVhZGVyIHtcclxuICAgIHByaXZhdGUgYmFyU3BhY2VSYXRpbyA9IFsxLCAxXTtcclxuICAgIFNJTkdMRV9DT0RFX0VSUk9SID0gMC43ODtcclxuICAgIEFWR19DT0RFX0VSUk9SID0gMC4zODtcclxuXHJcbiAgICBTVEFSVF9QQVRURVJOID0gW04sIE4sIE4sIE5dO1xyXG4gICAgU1RPUF9QQVRURVJOID0gW04sIE4sIFddO1xyXG4gICAgQ09ERV9QQVRURVJOID0gW1xyXG4gICAgICAgIFtOLCBOLCBXLCBXLCBOXSxcclxuICAgICAgICBbVywgTiwgTiwgTiwgV10sXHJcbiAgICAgICAgW04sIFcsIE4sIE4sIFddLFxyXG4gICAgICAgIFtXLCBXLCBOLCBOLCBOXSxcclxuICAgICAgICBbTiwgTiwgVywgTiwgV10sXHJcbiAgICAgICAgW1csIE4sIFcsIE4sIE5dLFxyXG4gICAgICAgIFtOLCBXLCBXLCBOLCBOXSxcclxuICAgICAgICBbTiwgTiwgTiwgVywgV10sXHJcbiAgICAgICAgW1csIE4sIE4sIFcsIE5dLFxyXG4gICAgICAgIFtOLCBXLCBOLCBXLCBOXSxcclxuICAgIF07XHJcbiAgICBNQVhfQ09SUkVDVElPTl9GQUNUT1IgPSA1O1xyXG4gICAgRk9STUFUID0gJ2kyb2Y1JztcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihvcHRzOiBCYXJjb2RlUmVhZGVyQ29uZmlnKSB7XHJcbiAgICAgICAgc3VwZXIobWVyZ2UoeyBub3JtYWxpemVCYXJTcGFjZVdpZHRoOiBmYWxzZSB9LCBvcHRzKSk7XHJcbiAgICAgICAgaWYgKG9wdHMubm9ybWFsaXplQmFyU3BhY2VXaWR0aCkge1xyXG4gICAgICAgICAgICB0aGlzLlNJTkdMRV9DT0RFX0VSUk9SID0gMC4zODtcclxuICAgICAgICAgICAgdGhpcy5BVkdfQ09ERV9FUlJPUiA9IDAuMDk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY29uZmlnID0gb3B0cztcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgX21hdGNoUGF0dGVybihjb3VudGVyOiBBcnJheTxudW1iZXI+LCBjb2RlOiBSZWFkb25seUFycmF5PG51bWJlcj4pOiBudW1iZXIge1xyXG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy5ub3JtYWxpemVCYXJTcGFjZVdpZHRoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvdW50ZXJTdW0gPSBbMCwgMF07XHJcbiAgICAgICAgICAgIGNvbnN0IGNvZGVTdW0gPSBbMCwgMF07XHJcbiAgICAgICAgICAgIGNvbnN0IGNvcnJlY3Rpb24gPSBbMCwgMF07XHJcbiAgICAgICAgICAgIGNvbnN0IGNvcnJlY3Rpb25SYXRpbyA9IHRoaXMuTUFYX0NPUlJFQ1RJT05fRkFDVE9SO1xyXG4gICAgICAgICAgICBjb25zdCBjb3JyZWN0aW9uUmF0aW9JbnZlcnNlID0gMSAvIGNvcnJlY3Rpb25SYXRpbztcclxuXHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnRlci5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgY291bnRlclN1bVtpICUgMl0gKz0gY291bnRlcltpXTtcclxuICAgICAgICAgICAgICAgIGNvZGVTdW1baSAlIDJdICs9IGNvZGVbaV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29ycmVjdGlvblswXSA9IGNvZGVTdW1bMF0gLyBjb3VudGVyU3VtWzBdO1xyXG4gICAgICAgICAgICBjb3JyZWN0aW9uWzFdID0gY29kZVN1bVsxXSAvIGNvdW50ZXJTdW1bMV07XHJcblxyXG4gICAgICAgICAgICBjb3JyZWN0aW9uWzBdID0gTWF0aC5tYXgoTWF0aC5taW4oY29ycmVjdGlvblswXSwgY29ycmVjdGlvblJhdGlvKSwgY29ycmVjdGlvblJhdGlvSW52ZXJzZSk7XHJcbiAgICAgICAgICAgIGNvcnJlY3Rpb25bMV0gPSBNYXRoLm1heChNYXRoLm1pbihjb3JyZWN0aW9uWzFdLCBjb3JyZWN0aW9uUmF0aW8pLCBjb3JyZWN0aW9uUmF0aW9JbnZlcnNlKTtcclxuICAgICAgICAgICAgdGhpcy5iYXJTcGFjZVJhdGlvID0gY29ycmVjdGlvbjtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudGVyLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBjb3VudGVyW2ldICo9IHRoaXMuYmFyU3BhY2VSYXRpb1tpICUgMl07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHN1cGVyLl9tYXRjaFBhdHRlcm4oY291bnRlciwgY29kZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHByb3RlY3RlZCBfZmluZFBhdHRlcm4ocGF0dGVybjogUmVhZG9ubHlBcnJheTxudW1iZXI+LCBvZmZzZXQ/OiBudW1iZXIsIGlzV2hpdGU6IGJvb2xlYW4gPSBmYWxzZSwgdHJ5SGFyZGVyOiBib29sZWFuID0gZmFsc2UpOiBCYXJjb2RlUG9zaXRpb24gfCBudWxsIHtcclxuICAgICAgICBjb25zdCBjb3VudGVyID0gbmV3IEFycmF5PG51bWJlcj4ocGF0dGVybi5sZW5ndGgpLmZpbGwoMCk7XHJcbiAgICAgICAgbGV0IGNvdW50ZXJQb3MgPSAwO1xyXG4gICAgICAgIGNvbnN0IGJlc3RNYXRjaDogQmFyY29kZVBvc2l0aW9uID0ge1xyXG4gICAgICAgICAgICBlcnJvcjogTnVtYmVyLk1BWF9WQUxVRSxcclxuICAgICAgICAgICAgc3RhcnQ6IDAsXHJcbiAgICAgICAgICAgIGVuZDogMCxcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBjb25zdCBlcHNpbG9uID0gdGhpcy5BVkdfQ09ERV9FUlJPUjtcclxuXHJcbiAgICAgICAgaXNXaGl0ZSA9IGlzV2hpdGUgfHwgZmFsc2U7XHJcbiAgICAgICAgdHJ5SGFyZGVyID0gdHJ5SGFyZGVyIHx8IGZhbHNlO1xyXG5cclxuICAgICAgICBpZiAoIW9mZnNldCkge1xyXG4gICAgICAgICAgICBvZmZzZXQgPSB0aGlzLl9uZXh0U2V0KHRoaXMuX3Jvdyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IgKGxldCBpID0gb2Zmc2V0OyBpIDwgdGhpcy5fcm93Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9yb3dbaV0gXiAoaXNXaGl0ZSA/IDEgOiAwKSkge1xyXG4gICAgICAgICAgICAgICAgY291bnRlcltjb3VudGVyUG9zXSsrO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvdW50ZXJQb3MgPT09IGNvdW50ZXIubGVuZ3RoIC0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN1bSA9IGNvdW50ZXIucmVkdWNlKChwcmV2LCBuZXh0KSA9PiBwcmV2ICsgbmV4dCwgMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLl9tYXRjaFBhdHRlcm4oY291bnRlciwgcGF0dGVybik7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yIDwgZXBzaWxvbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guZXJyb3IgPSBlcnJvcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLnN0YXJ0ID0gaSAtIHN1bTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLmVuZCA9IGk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBiZXN0TWF0Y2g7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0cnlIYXJkZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjb3VudGVyLmxlbmd0aCAtIDI7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlcltqXSA9IGNvdW50ZXJbaiArIDJdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJbY291bnRlci5sZW5ndGggLSAyXSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJbY291bnRlci5sZW5ndGggLSAxXSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJQb3MtLTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJQb3MrKztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvdW50ZXJbY291bnRlclBvc10gPSAxO1xyXG4gICAgICAgICAgICAgICAgaXNXaGl0ZSA9ICFpc1doaXRlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfTtcclxuXHJcbiAgICBwcm90ZWN0ZWQgX2ZpbmRTdGFydCgpOiBCYXJjb2RlUG9zaXRpb24gfCBudWxsIHtcclxuICAgICAgICBsZXQgbGVhZGluZ1doaXRlc3BhY2VTdGFydCA9IDA7XHJcbiAgICAgICAgbGV0IG9mZnNldCA9IHRoaXMuX25leHRTZXQodGhpcy5fcm93KTtcclxuICAgICAgICBsZXQgc3RhcnRJbmZvOiBCYXJjb2RlUG9zaXRpb24gfCBudWxsID0gbnVsbDtcclxuICAgICAgICBsZXQgbmFycm93QmFyV2lkdGggPSAxO1xyXG5cclxuICAgICAgICB3aGlsZSAoIXN0YXJ0SW5mbykge1xyXG4gICAgICAgICAgICBzdGFydEluZm8gPSB0aGlzLl9maW5kUGF0dGVybih0aGlzLlNUQVJUX1BBVFRFUk4sIG9mZnNldCwgZmFsc2UsIHRydWUpO1xyXG4gICAgICAgICAgICBpZiAoIXN0YXJ0SW5mbykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbmFycm93QmFyV2lkdGggPSBNYXRoLmZsb29yKChzdGFydEluZm8uZW5kIC0gc3RhcnRJbmZvLnN0YXJ0KSAvIDQpO1xyXG4gICAgICAgICAgICBsZWFkaW5nV2hpdGVzcGFjZVN0YXJ0ID0gc3RhcnRJbmZvLnN0YXJ0IC0gbmFycm93QmFyV2lkdGggKiAxMDtcclxuICAgICAgICAgICAgaWYgKGxlYWRpbmdXaGl0ZXNwYWNlU3RhcnQgPj0gMCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX21hdGNoUmFuZ2UobGVhZGluZ1doaXRlc3BhY2VTdGFydCwgc3RhcnRJbmZvLnN0YXJ0LCAwKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdGFydEluZm87XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb2Zmc2V0ID0gc3RhcnRJbmZvLmVuZDtcclxuICAgICAgICAgICAgc3RhcnRJbmZvID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9O1xyXG5cclxuICAgIHByb3RlY3RlZCBfdmVyaWZ5VHJhaWxpbmdXaGl0ZXNwYWNlKGVuZEluZm86IEJhcmNvZGVQb3NpdGlvbik6IEJhcmNvZGVQb3NpdGlvbiB8IG51bGwge1xyXG4gICAgICAgIGNvbnN0IHRyYWlsaW5nV2hpdGVzcGFjZUVuZCA9IGVuZEluZm8uZW5kICsgKChlbmRJbmZvLmVuZCAtIGVuZEluZm8uc3RhcnQpIC8gMik7XHJcbiAgICAgICAgaWYgKHRyYWlsaW5nV2hpdGVzcGFjZUVuZCA8IHRoaXMuX3Jvdy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX21hdGNoUmFuZ2UoZW5kSW5mby5lbmQsIHRyYWlsaW5nV2hpdGVzcGFjZUVuZCwgMCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBlbmRJbmZvO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfTtcclxuXHJcbiAgICBwcm90ZWN0ZWQgX2ZpbmRFbmQoKTogQmFyY29kZVBvc2l0aW9uIHwgbnVsbCB7XHJcbiAgICAgICAgdGhpcy5fcm93LnJldmVyc2UoKTtcclxuICAgICAgICBjb25zdCBlbmRJbmZvID0gdGhpcy5fZmluZFBhdHRlcm4odGhpcy5TVE9QX1BBVFRFUk4pO1xyXG4gICAgICAgIHRoaXMuX3Jvdy5yZXZlcnNlKCk7XHJcblxyXG4gICAgICAgIGlmIChlbmRJbmZvID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gcmV2ZXJzZSBudW1iZXJzXHJcbiAgICAgICAgY29uc3QgdG1wID0gZW5kSW5mby5zdGFydDtcclxuICAgICAgICBlbmRJbmZvLnN0YXJ0ID0gdGhpcy5fcm93Lmxlbmd0aCAtIGVuZEluZm8uZW5kO1xyXG4gICAgICAgIGVuZEluZm8uZW5kID0gdGhpcy5fcm93Lmxlbmd0aCAtIHRtcDtcclxuXHJcbiAgICAgICAgcmV0dXJuIGVuZEluZm8gIT09IG51bGwgPyB0aGlzLl92ZXJpZnlUcmFpbGluZ1doaXRlc3BhY2UoZW5kSW5mbykgOiBudWxsO1xyXG4gICAgfTtcclxuXHJcbiAgICBwcm90ZWN0ZWQgX2RlY29kZVBhaXIoY291bnRlclBhaXI6IEFycmF5PEFycmF5PG51bWJlcj4+KTogQXJyYXk8QmFyY29kZUluZm8+IHwgbnVsbCB7XHJcbiAgICAgICAgY29uc3QgY29kZXM6IEFycmF5PEJhcmNvZGVJbmZvPiA9IFtdO1xyXG5cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50ZXJQYWlyLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvZGUgPSB0aGlzLl9kZWNvZGVDb2RlKGNvdW50ZXJQYWlyW2ldKTtcclxuICAgICAgICAgICAgaWYgKCFjb2RlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb2Rlcy5wdXNoKGNvZGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY29kZXM7XHJcbiAgICB9O1xyXG5cclxuICAgIHByb3RlY3RlZCBfZGVjb2RlQ29kZShjb3VudGVyOiBBcnJheTxudW1iZXI+KTogQmFyY29kZUluZm8gfCBudWxsIHtcclxuICAgICAgICBjb25zdCBlcHNpbG9uID0gdGhpcy5BVkdfQ09ERV9FUlJPUjtcclxuXHJcbiAgICAgICAgY29uc3QgYmVzdE1hdGNoOiBCYXJjb2RlSW5mbyA9IHtcclxuICAgICAgICAgICAgZXJyb3I6IE51bWJlci5NQVhfVkFMVUUsXHJcbiAgICAgICAgICAgIGNvZGU6IC0xLFxyXG4gICAgICAgICAgICBzdGFydDogMCxcclxuICAgICAgICAgICAgZW5kOiAwLFxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGZvciAobGV0IGNvZGUgPSAwOyBjb2RlIDwgdGhpcy5DT0RFX1BBVFRFUk4ubGVuZ3RoOyBjb2RlKyspIHtcclxuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLl9tYXRjaFBhdHRlcm4oY291bnRlciwgdGhpcy5DT0RFX1BBVFRFUk5bY29kZV0pO1xyXG4gICAgICAgICAgICBpZiAoZXJyb3IgPCBiZXN0TWF0Y2guZXJyb3IhKSB7XHJcbiAgICAgICAgICAgICAgICBiZXN0TWF0Y2guY29kZSA9IGNvZGU7XHJcbiAgICAgICAgICAgICAgICBiZXN0TWF0Y2guZXJyb3IgPSBlcnJvcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYmVzdE1hdGNoLmVycm9yISA8IGVwc2lsb24pIHtcclxuICAgICAgICAgICAgcmV0dXJuIGJlc3RNYXRjaDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9O1xyXG5cclxuICAgIHByb3RlY3RlZCBfZGVjb2RlUGF5bG9hZChjb3VudGVyczogUmVhZG9ubHlBcnJheTxudW1iZXI+LCByZXN1bHQ6IEFycmF5PHN0cmluZz4sIGRlY29kZWRDb2RlczogQXJyYXk8QmFyY29kZUluZm8gfCBCYXJjb2RlUG9zaXRpb24+KTogQXJyYXk8QmFyY29kZUluZm8+IHwgbnVsbCB7XHJcbiAgICAgICAgbGV0IHBvcyA9IDA7XHJcbiAgICAgICAgY29uc3QgY291bnRlckxlbmd0aCA9IGNvdW50ZXJzLmxlbmd0aDtcclxuICAgICAgICBjb25zdCBjb3VudGVyUGFpciA9IFtbMCwgMCwgMCwgMCwgMF0sIFswLCAwLCAwLCAwLCAwXV07XHJcbiAgICAgICAgbGV0IGNvZGVzOiBCYXJjb2RlSW5mb1tdIHwgbnVsbCA9IG51bGw7XHJcblxyXG4gICAgICAgIHdoaWxlIChwb3MgPCBjb3VudGVyTGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNTsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBjb3VudGVyUGFpclswXVtpXSA9IGNvdW50ZXJzW3Bvc10gKiB0aGlzLmJhclNwYWNlUmF0aW9bMF07XHJcbiAgICAgICAgICAgICAgICBjb3VudGVyUGFpclsxXVtpXSA9IGNvdW50ZXJzW3BvcyArIDFdICogdGhpcy5iYXJTcGFjZVJhdGlvWzFdO1xyXG4gICAgICAgICAgICAgICAgcG9zICs9IDI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29kZXMgPSB0aGlzLl9kZWNvZGVQYWlyKGNvdW50ZXJQYWlyKTtcclxuICAgICAgICAgICAgaWYgKCFjb2Rlcykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2Rlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goY29kZXNbaV0uY29kZSArICcnKTtcclxuICAgICAgICAgICAgICAgIGRlY29kZWRDb2Rlcy5wdXNoKGNvZGVzW2ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY29kZXM7XHJcbiAgICB9O1xyXG5cclxuICAgIHByb3RlY3RlZCBfdmVyaWZ5Q291bnRlckxlbmd0aChjb3VudGVyczogQXJyYXk8bnVtYmVyPikge1xyXG4gICAgICAgIHJldHVybiAoY291bnRlcnMubGVuZ3RoICUgMTAgPT09IDApO1xyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgZGVjb2RlKHJvdz86IEFycmF5PG51bWJlcj4sIHN0YXJ0PzogQmFyY29kZVBvc2l0aW9uIHwgbnVtYmVyKTogQmFyY29kZSB8IG51bGwge1xyXG4gICAgICAgIHZhciByZXN1bHQgPSBuZXcgQXJyYXk8c3RyaW5nPigpO1xyXG4gICAgICAgIHZhciBkZWNvZGVkQ29kZXMgPSBuZXcgQXJyYXk8QmFyY29kZVBvc2l0aW9uPigpO1xyXG5cclxuICAgICAgICBjb25zdCBzdGFydEluZm8gPSB0aGlzLl9maW5kU3RhcnQoKTtcclxuICAgICAgICBpZiAoIXN0YXJ0SW5mbykge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZGVjb2RlZENvZGVzLnB1c2goc3RhcnRJbmZvKTtcclxuXHJcbiAgICAgICAgY29uc3QgZW5kSW5mbyA9IHRoaXMuX2ZpbmRFbmQoKTtcclxuICAgICAgICBpZiAoIWVuZEluZm8pIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBjb3VudGVycyA9IHRoaXMuX2ZpbGxDb3VudGVycyhzdGFydEluZm8uZW5kLCBlbmRJbmZvLnN0YXJ0LCBmYWxzZSk7XHJcbiAgICAgICAgaWYgKCF0aGlzLl92ZXJpZnlDb3VudGVyTGVuZ3RoKGNvdW50ZXJzKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgY29kZSA9IHRoaXMuX2RlY29kZVBheWxvYWQoY291bnRlcnMsIHJlc3VsdCwgZGVjb2RlZENvZGVzKTtcclxuICAgICAgICBpZiAoIWNvZGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChyZXN1bHQubGVuZ3RoICUgMiAhPT0gMCB8fFxyXG4gICAgICAgICAgICAgICAgcmVzdWx0Lmxlbmd0aCA8IDYpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBkZWNvZGVkQ29kZXMucHVzaChlbmRJbmZvKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBjb2RlOiByZXN1bHQuam9pbignJyksXHJcbiAgICAgICAgICAgIHN0YXJ0OiBzdGFydEluZm8uc3RhcnQsXHJcbiAgICAgICAgICAgIGVuZDogZW5kSW5mby5lbmQsXHJcbiAgICAgICAgICAgIHN0YXJ0SW5mbzogc3RhcnRJbmZvLFxyXG4gICAgICAgICAgICBkZWNvZGVkQ29kZXM6IGRlY29kZWRDb2RlcyxcclxuICAgICAgICAgICAgZm9ybWF0OiB0aGlzLkZPUk1BVCxcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgSTJvZjVSZWFkZXI7XHJcbiIsImltcG9ydCBCYXJjb2RlUmVhZGVyLCB7IEJhcmNvZGUsIEJhcmNvZGVJbmZvLCBCYXJjb2RlUG9zaXRpb24gfSBmcm9tICcuL2JhcmNvZGVfcmVhZGVyJztcclxuXHJcbmNvbnN0IE4gPSAxO1xyXG5jb25zdCBXID0gMztcclxuY29uc3QgU1RBUlRfUEFUVEVSTiA9IFtXLCBOLCBXLCBOLCBOLCBOXTtcclxuY29uc3QgU1RPUF9QQVRURVJOID0gW1csIE4sIE4sIE4sIFddO1xyXG5jb25zdCBDT0RFX1BBVFRFUk4gPSBbXHJcbiAgICBbTiwgTiwgVywgVywgTl0sXHJcbiAgICBbVywgTiwgTiwgTiwgV10sXHJcbiAgICBbTiwgVywgTiwgTiwgV10sXHJcbiAgICBbVywgVywgTiwgTiwgTl0sXHJcbiAgICBbTiwgTiwgVywgTiwgV10sXHJcbiAgICBbVywgTiwgVywgTiwgTl0sXHJcbiAgICBbTiwgVywgVywgTiwgTl0sXHJcbiAgICBbTiwgTiwgTiwgVywgV10sXHJcbiAgICBbVywgTiwgTiwgVywgTl0sXHJcbiAgICBbTiwgVywgTiwgVywgTl0sXHJcbl07XHJcbmNvbnN0IFNUQVJUX1BBVFRFUk5fTEVOR1RIID0gU1RBUlRfUEFUVEVSTi5yZWR1Y2UoKHN1bSwgdmFsKSA9PiBzdW0gKyB2YWwsIDApO1xyXG5cclxuY2xhc3MgVHdvT2ZGaXZlUmVhZGVyIGV4dGVuZHMgQmFyY29kZVJlYWRlciB7XHJcbiAgICBiYXJTcGFjZVJhdGlvID0gWzEsIDFdO1xyXG5cclxuICAgIEZPUk1BVCA9ICcyb2Y1JztcclxuXHJcbiAgICBTSU5HTEVfQ09ERV9FUlJPUiA9IDAuNzg7XHJcblxyXG4gICAgQVZHX0NPREVfRVJST1IgPSAwLjMwO1xyXG5cclxuICAgIHByb3RlY3RlZCBfZmluZFBhdHRlcm4ocGF0dGVybjogUmVhZG9ubHlBcnJheTxudW1iZXI+LCBvZmZzZXQ6IG51bWJlciwgaXNXaGl0ZSA9IGZhbHNlLCB0cnlIYXJkZXIgPSBmYWxzZSk6IEJhcmNvZGVJbmZvIHwgbnVsbCB7XHJcbiAgICAgICAgY29uc3QgY291bnRlciA9IFtdO1xyXG4gICAgICAgIGxldCBjb3VudGVyUG9zID0gMDtcclxuICAgICAgICBjb25zdCBiZXN0TWF0Y2ggPSB7XHJcbiAgICAgICAgICAgIGVycm9yOiBOdW1iZXIuTUFYX1ZBTFVFLFxyXG4gICAgICAgICAgICBjb2RlOiAtMSxcclxuICAgICAgICAgICAgc3RhcnQ6IDAsXHJcbiAgICAgICAgICAgIGVuZDogMCxcclxuICAgICAgICB9O1xyXG4gICAgICAgIGxldCBzdW0gPSAwO1xyXG4gICAgICAgIGxldCBlcnJvciA9IDA7XHJcbiAgICAgICAgY29uc3QgZXBzaWxvbiA9IHRoaXMuQVZHX0NPREVfRVJST1I7XHJcblxyXG4gICAgICAgIGlmICghb2Zmc2V0KSB7XHJcbiAgICAgICAgICAgIG9mZnNldCA9IHRoaXMuX25leHRTZXQodGhpcy5fcm93KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGF0dGVybi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb3VudGVyW2ldID0gMDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvciAobGV0IGkgPSBvZmZzZXQ7IGkgPCB0aGlzLl9yb3cubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX3Jvd1tpXSBeIChpc1doaXRlID8gMSA6IDApKSB7XHJcbiAgICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXJQb3NdKys7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY291bnRlclBvcyA9PT0gY291bnRlci5sZW5ndGggLSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3VtID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNvdW50ZXIubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3VtICs9IGNvdW50ZXJbal07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVycm9yID0gdGhpcy5fbWF0Y2hQYXR0ZXJuKGNvdW50ZXIsIHBhdHRlcm4pO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvciA8IGVwc2lsb24pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLmVycm9yID0gZXJyb3I7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5zdGFydCA9IGkgLSBzdW07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5lbmQgPSBpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmVzdE1hdGNoO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodHJ5SGFyZGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgY291bnRlci5sZW5ndGggLSAyOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJbal0gPSBjb3VudGVyW2ogKyAyXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXIubGVuZ3RoIC0gMl0gPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXIubGVuZ3RoIC0gMV0gPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyUG9zLS07XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjb3VudGVyUG9zKys7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXJQb3NdID0gMTtcclxuICAgICAgICAgICAgICAgIGlzV2hpdGUgPSAhaXNXaGl0ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgX2ZpbmRTdGFydCgpOiBCYXJjb2RlUG9zaXRpb24gfCBudWxsIHtcclxuICAgICAgICBsZXQgc3RhcnRJbmZvID0gbnVsbDtcclxuICAgICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5fbmV4dFNldCh0aGlzLl9yb3cpO1xyXG4gICAgICAgIGxldCBuYXJyb3dCYXJXaWR0aCA9IDE7XHJcbiAgICAgICAgbGV0IGxlYWRpbmdXaGl0ZXNwYWNlU3RhcnQgPSAwO1xyXG5cclxuICAgICAgICB3aGlsZSAoIXN0YXJ0SW5mbykge1xyXG4gICAgICAgICAgICBzdGFydEluZm8gPSB0aGlzLl9maW5kUGF0dGVybihTVEFSVF9QQVRURVJOLCBvZmZzZXQsIGZhbHNlLCB0cnVlKTtcclxuICAgICAgICAgICAgaWYgKCFzdGFydEluZm8pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG5hcnJvd0JhcldpZHRoID0gTWF0aC5mbG9vcigoc3RhcnRJbmZvLmVuZCAtIHN0YXJ0SW5mby5zdGFydCkgLyBTVEFSVF9QQVRURVJOX0xFTkdUSCk7XHJcbiAgICAgICAgICAgIGxlYWRpbmdXaGl0ZXNwYWNlU3RhcnQgPSBzdGFydEluZm8uc3RhcnQgLSBuYXJyb3dCYXJXaWR0aCAqIDU7XHJcbiAgICAgICAgICAgIGlmIChsZWFkaW5nV2hpdGVzcGFjZVN0YXJ0ID49IDApIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9tYXRjaFJhbmdlKGxlYWRpbmdXaGl0ZXNwYWNlU3RhcnQsIHN0YXJ0SW5mby5zdGFydCwgMCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RhcnRJbmZvO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG9mZnNldCA9IHN0YXJ0SW5mby5lbmQ7XHJcbiAgICAgICAgICAgIHN0YXJ0SW5mbyA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzdGFydEluZm87XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIF92ZXJpZnlUcmFpbGluZ1doaXRlc3BhY2UoZW5kSW5mbzogQmFyY29kZUluZm8pOiBCYXJjb2RlUG9zaXRpb24gfCBudWxsIHtcclxuICAgICAgICBjb25zdCB0cmFpbGluZ1doaXRlc3BhY2VFbmQgPSBlbmRJbmZvLmVuZCArICgoZW5kSW5mby5lbmQgLSBlbmRJbmZvLnN0YXJ0KSAvIDIpO1xyXG4gICAgICAgIGlmICh0cmFpbGluZ1doaXRlc3BhY2VFbmQgPCB0aGlzLl9yb3cubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9tYXRjaFJhbmdlKGVuZEluZm8uZW5kLCB0cmFpbGluZ1doaXRlc3BhY2VFbmQsIDApKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZW5kSW5mbztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgX2ZpbmRFbmQoKTogQmFyY29kZVBvc2l0aW9uIHwgbnVsbCB7XHJcbiAgICAgICAgLy8gVE9ETzogcmV2ZXJzZSwgZm9sbG93ZWQgYnkgc29tZSBjYWxjcywgZm9sbG93ZWQgYnkgYW5vdGhlciByZXZlcnNlPyByZWFsbHk/XHJcbiAgICAgICAgdGhpcy5fcm93LnJldmVyc2UoKTtcclxuICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLl9uZXh0U2V0KHRoaXMuX3Jvdyk7XHJcbiAgICAgICAgY29uc3QgZW5kSW5mbyA9IHRoaXMuX2ZpbmRQYXR0ZXJuKFNUT1BfUEFUVEVSTiwgb2Zmc2V0LCBmYWxzZSwgdHJ1ZSk7XHJcbiAgICAgICAgdGhpcy5fcm93LnJldmVyc2UoKTtcclxuXHJcbiAgICAgICAgaWYgKGVuZEluZm8gPT09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyByZXZlcnNlIG51bWJlcnNcclxuICAgICAgICBjb25zdCB0bXAgPSBlbmRJbmZvLnN0YXJ0O1xyXG4gICAgICAgIGVuZEluZm8uc3RhcnQgPSB0aGlzLl9yb3cubGVuZ3RoIC0gZW5kSW5mby5lbmQ7XHJcbiAgICAgICAgZW5kSW5mby5lbmQgPSB0aGlzLl9yb3cubGVuZ3RoIC0gdG1wO1xyXG5cclxuICAgICAgICByZXR1cm4gZW5kSW5mbyAhPT0gbnVsbCA/IHRoaXMuX3ZlcmlmeVRyYWlsaW5nV2hpdGVzcGFjZShlbmRJbmZvKSA6IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIF92ZXJpZnlDb3VudGVyTGVuZ3RoKGNvdW50ZXJzOiBBcnJheTxudW1iZXI+KSB7XHJcbiAgICAgICAgcmV0dXJuIChjb3VudGVycy5sZW5ndGggJSAxMCA9PT0gMCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIF9kZWNvZGVDb2RlKGNvdW50ZXI6IFJlYWRvbmx5QXJyYXk8bnVtYmVyPik6IEJhcmNvZGVJbmZvIHwgbnVsbCB7XHJcbiAgICAgICAgY29uc3QgZXBzaWxvbiA9IHRoaXMuQVZHX0NPREVfRVJST1I7XHJcbiAgICAgICAgY29uc3QgYmVzdE1hdGNoID0ge1xyXG4gICAgICAgICAgICBlcnJvcjogTnVtYmVyLk1BWF9WQUxVRSxcclxuICAgICAgICAgICAgY29kZTogLTEsXHJcbiAgICAgICAgICAgIHN0YXJ0OiAwLFxyXG4gICAgICAgICAgICBlbmQ6IDAsXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgZm9yIChsZXQgY29kZSA9IDA7IGNvZGUgPCBDT0RFX1BBVFRFUk4ubGVuZ3RoOyBjb2RlKyspIHtcclxuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLl9tYXRjaFBhdHRlcm4oY291bnRlciwgQ09ERV9QQVRURVJOW2NvZGVdKTtcclxuICAgICAgICAgICAgaWYgKGVycm9yIDwgYmVzdE1hdGNoLmVycm9yISkge1xyXG4gICAgICAgICAgICAgICAgYmVzdE1hdGNoLmNvZGUgPSBjb2RlO1xyXG4gICAgICAgICAgICAgICAgYmVzdE1hdGNoLmVycm9yID0gZXJyb3I7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGJlc3RNYXRjaC5lcnJvciEgPCBlcHNpbG9uKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBiZXN0TWF0Y2g7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBfZGVjb2RlUGF5bG9hZChjb3VudGVyczogUmVhZG9ubHlBcnJheTxudW1iZXI+LCByZXN1bHQ6IEFycmF5PHN0cmluZz4sIGRlY29kZWRDb2RlczogQXJyYXk8QmFyY29kZUluZm8gfCBCYXJjb2RlUG9zaXRpb24+KTogQmFyY29kZUluZm8gfCBudWxsIHtcclxuICAgICAgICBsZXQgcG9zID0gMDtcclxuICAgICAgICBjb25zdCBjb3VudGVyTGVuZ3RoID0gY291bnRlcnMubGVuZ3RoO1xyXG4gICAgICAgIGNvbnN0IGNvdW50ZXIgPSBbMCwgMCwgMCwgMCwgMF07XHJcbiAgICAgICAgbGV0IGNvZGU6IEJhcmNvZGVJbmZvIHwgbnVsbCA9IG51bGw7XHJcblxyXG4gICAgICAgIHdoaWxlIChwb3MgPCBjb3VudGVyTGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNTsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBjb3VudGVyW2ldID0gY291bnRlcnNbcG9zXSAqIHRoaXMuYmFyU3BhY2VSYXRpb1swXTtcclxuICAgICAgICAgICAgICAgIHBvcyArPSAyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvZGUgPSB0aGlzLl9kZWNvZGVDb2RlKGNvdW50ZXIpO1xyXG4gICAgICAgICAgICBpZiAoIWNvZGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGAke2NvZGUuY29kZX1gKTtcclxuICAgICAgICAgICAgZGVjb2RlZENvZGVzLnB1c2goY29kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjb2RlO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBwdWJsaWMgZGVjb2RlKHJvdz86IEFycmF5PG51bWJlcj4sIHN0YXJ0PzogQmFyY29kZVBvc2l0aW9uKTogQmFyY29kZSB8IG51bGwge1xyXG4gICAgICAgIGNvbnN0IHN0YXJ0SW5mbyA9IHRoaXMuX2ZpbmRTdGFydCgpO1xyXG4gICAgICAgIGlmICghc3RhcnRJbmZvKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgZW5kSW5mbyA9IHRoaXMuX2ZpbmRFbmQoKTtcclxuICAgICAgICBpZiAoIWVuZEluZm8pIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBjb3VudGVycyA9IHRoaXMuX2ZpbGxDb3VudGVycyhzdGFydEluZm8uZW5kLCBlbmRJbmZvLnN0YXJ0LCBmYWxzZSk7XHJcbiAgICAgICAgaWYgKCF0aGlzLl92ZXJpZnlDb3VudGVyTGVuZ3RoKGNvdW50ZXJzKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgZGVjb2RlZENvZGVzID0gW107XHJcbiAgICAgICAgZGVjb2RlZENvZGVzLnB1c2goc3RhcnRJbmZvKTtcclxuXHJcbiAgICAgICAgY29uc3QgcmVzdWx0OiBBcnJheTxzdHJpbmc+ID0gW107XHJcbiAgICAgICAgY29uc3QgY29kZSA9IHRoaXMuX2RlY29kZVBheWxvYWQoY291bnRlcnMsIHJlc3VsdCwgZGVjb2RlZENvZGVzKTtcclxuICAgICAgICBpZiAoIWNvZGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChyZXN1bHQubGVuZ3RoIDwgNSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGRlY29kZWRDb2Rlcy5wdXNoKGVuZEluZm8pO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGNvZGU6IHJlc3VsdC5qb2luKCcnKSxcclxuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0SW5mby5zdGFydCxcclxuICAgICAgICAgICAgZW5kOiBlbmRJbmZvLmVuZCxcclxuICAgICAgICAgICAgc3RhcnRJbmZvLFxyXG4gICAgICAgICAgICBkZWNvZGVkQ29kZXMsXHJcbiAgICAgICAgICAgIGZvcm1hdDogdGhpcy5GT1JNQVQsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgVHdvT2ZGaXZlUmVhZGVyO1xyXG4iLCJpbXBvcnQgQmFyY29kZVJlYWRlciwgeyBCYXJjb2RlUG9zaXRpb24sIEJhcmNvZGUgfSBmcm9tICcuL2JhcmNvZGVfcmVhZGVyJztcclxuaW1wb3J0IEFycmF5SGVscGVyIGZyb20gJy4uL2NvbW1vbi9hcnJheV9oZWxwZXInO1xyXG5cclxuY29uc3QgQUxQSEFCRVRIX1NUUklORyA9ICcwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVotLiAkLyslYWJjZConO1xyXG5jb25zdCBBTFBIQUJFVCA9IG5ldyBVaW50MTZBcnJheShbLi4uQUxQSEFCRVRIX1NUUklOR10ubWFwKGNoYXIgPT4gY2hhci5jaGFyQ29kZUF0KDApKSk7XHJcbmNvbnN0IENIQVJBQ1RFUl9FTkNPRElOR1MgPSBuZXcgVWludDE2QXJyYXkoW1xyXG4gICAgMHgxMTQsIDB4MTQ4LCAweDE0NCwgMHgxNDIsIDB4MTI4LCAweDEyNCwgMHgxMjIsIDB4MTUwLCAweDExMiwgMHgxMEEsXHJcbiAgICAweDFBOCwgMHgxQTQsIDB4MUEyLCAweDE5NCwgMHgxOTIsIDB4MThBLCAweDE2OCwgMHgxNjQsIDB4MTYyLCAweDEzNCxcclxuICAgIDB4MTFBLCAweDE1OCwgMHgxNEMsIDB4MTQ2LCAweDEyQywgMHgxMTYsIDB4MUI0LCAweDFCMiwgMHgxQUMsIDB4MUE2LFxyXG4gICAgMHgxOTYsIDB4MTlBLCAweDE2QywgMHgxNjYsIDB4MTM2LCAweDEzQSwgMHgxMkUsIDB4MUQ0LCAweDFEMiwgMHgxQ0EsXHJcbiAgICAweDE2RSwgMHgxNzYsIDB4MUFFLCAweDEyNiwgMHgxREEsIDB4MUQ2LCAweDEzMiwgMHgxNUUsXHJcbl0pO1xyXG5jb25zdCBBU1RFUklTSyA9IDB4MTVFO1xyXG5cclxuY2xhc3MgQ29kZTkzUmVhZGVyIGV4dGVuZHMgQmFyY29kZVJlYWRlciB7XHJcbiAgICBGT1JNQVQgPSAnY29kZV85Myc7XHJcbiAgICBwcm90ZWN0ZWQgX3BhdHRlcm5Ub0NoYXIocGF0dGVybjogbnVtYmVyKTogc3RyaW5nIHwgbnVsbCB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBDSEFSQUNURVJfRU5DT0RJTkdTLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChDSEFSQUNURVJfRU5DT0RJTkdTW2ldID09PSBwYXR0ZXJuKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShBTFBIQUJFVFtpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9O1xyXG5cclxuICAgIHByb3RlY3RlZCBfdG9QYXR0ZXJuKGNvdW50ZXJzOiBVaW50MTZBcnJheSk6IG51bWJlciB7XHJcbiAgICAgICAgY29uc3QgbnVtQ291bnRlcnMgPSBjb3VudGVycy5sZW5ndGg7XHJcbiAgICAgICAgY29uc3Qgc3VtID0gY291bnRlcnMucmVkdWNlKChwcmV2LCBuZXh0KSA9PiBwcmV2ICsgbmV4dCwgMCk7XHJcbiAgICAgICAgbGV0IHBhdHRlcm4gPSAwO1xyXG5cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUNvdW50ZXJzOyBpKyspIHtcclxuICAgICAgICAgICAgbGV0IG5vcm1hbGl6ZWQgPSBNYXRoLnJvdW5kKGNvdW50ZXJzW2ldICogOSAvIHN1bSk7XHJcbiAgICAgICAgICAgIGlmIChub3JtYWxpemVkIDwgMSB8fCBub3JtYWxpemVkID4gNCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICgoaSAmIDEpID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG5vcm1hbGl6ZWQ7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhdHRlcm4gPSAocGF0dGVybiA8PCAxKSB8IDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBwYXR0ZXJuIDw8PSBub3JtYWxpemVkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwYXR0ZXJuO1xyXG4gICAgfTtcclxuXHJcbiAgICBwcm90ZWN0ZWQgX2ZpbmRTdGFydCgpOiBCYXJjb2RlUG9zaXRpb24gfCBudWxsIHtcclxuICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLl9uZXh0U2V0KHRoaXMuX3Jvdyk7XHJcbiAgICAgICAgbGV0IHBhdHRlcm5TdGFydCA9IG9mZnNldDtcclxuICAgICAgICBjb25zdCBjb3VudGVyID0gbmV3IFVpbnQxNkFycmF5KFswLCAwLCAwLCAwLCAwLCAwXSk7XHJcbiAgICAgICAgbGV0IGNvdW50ZXJQb3MgPSAwO1xyXG4gICAgICAgIGxldCBpc1doaXRlID0gZmFsc2U7XHJcblxyXG4gICAgICAgIGZvciAobGV0IGkgPSBvZmZzZXQ7IGkgPCB0aGlzLl9yb3cubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX3Jvd1tpXSBeIChpc1doaXRlID8gMSA6IDApKSB7XHJcbiAgICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXJQb3NdKys7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY291bnRlclBvcyA9PT0gY291bnRlci5sZW5ndGggLSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZmluZCBzdGFydCBwYXR0ZXJuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3RvUGF0dGVybihjb3VudGVyKSA9PT0gQVNURVJJU0spIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgd2hpdGVTcGFjZU11c3RTdGFydCA9IE1hdGguZmxvb3IoTWF0aC5tYXgoMCwgcGF0dGVyblN0YXJ0IC0gKChpIC0gcGF0dGVyblN0YXJ0KSAvIDQpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9tYXRjaFJhbmdlKHdoaXRlU3BhY2VNdXN0U3RhcnQsIHBhdHRlcm5TdGFydCwgMCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHBhdHRlcm5TdGFydCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IGksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuU3RhcnQgKz0gY291bnRlclswXSArIGNvdW50ZXJbMV07XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCA0OyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlcltqXSA9IGNvdW50ZXJbaiArIDJdO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjb3VudGVyWzRdID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBjb3VudGVyWzVdID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBjb3VudGVyUG9zLS07XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJQb3MrKztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvdW50ZXJbY291bnRlclBvc10gPSAxO1xyXG4gICAgICAgICAgICAgICAgaXNXaGl0ZSA9ICFpc1doaXRlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfTtcclxuXHJcbiAgICBwcm90ZWN0ZWQgX3ZlcmlmeUVuZChsYXN0U3RhcnQ6IG51bWJlciwgbmV4dFN0YXJ0OiBudW1iZXIpOiBib29sZWFuIHtcclxuICAgICAgICBpZiAobGFzdFN0YXJ0ID09PSBuZXh0U3RhcnQgfHwgIXRoaXMuX3Jvd1tuZXh0U3RhcnRdKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9O1xyXG5cclxuICAgIHByb3RlY3RlZCBfZGVjb2RlRXh0ZW5kZWQoY2hhckFycmF5OiBBcnJheTxzdHJpbmc+KTogc3RyaW5nW10gfCBudWxsIHtcclxuICAgICAgICBjb25zdCBsZW5ndGggPSBjaGFyQXJyYXkubGVuZ3RoO1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdDogQXJyYXk8c3RyaW5nPiA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgY2hhciA9IGNoYXJBcnJheVtpXTtcclxuICAgICAgICAgICAgaWYgKGNoYXIgPj0gJ2EnICYmIGNoYXIgPD0gJ2QnKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaSA+IChsZW5ndGggLSAyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dENoYXIgPSBjaGFyQXJyYXlbKytpXTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRDaGFyQ29kZSA9IG5leHRDaGFyLmNoYXJDb2RlQXQoMCk7XHJcbiAgICAgICAgICAgICAgICBsZXQgZGVjb2RlZENoYXI7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGNoYXIpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdhJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRDaGFyID49ICdBJyAmJiBuZXh0Q2hhciA8PSAnWicpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY29kZWRDaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZShuZXh0Q2hhckNvZGUgLSA2NCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdiJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRDaGFyID49ICdBJyAmJiBuZXh0Q2hhciA8PSAnRScpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY29kZWRDaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZShuZXh0Q2hhckNvZGUgLSAzOCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobmV4dENoYXIgPj0gJ0YnICYmIG5leHRDaGFyIDw9ICdKJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjb2RlZENoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG5leHRDaGFyQ29kZSAtIDExKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChuZXh0Q2hhciA+PSAnSycgJiYgbmV4dENoYXIgPD0gJ08nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNvZGVkQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUobmV4dENoYXJDb2RlICsgMTYpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG5leHRDaGFyID49ICdQJyAmJiBuZXh0Q2hhciA8PSAnUycpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY29kZWRDaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZShuZXh0Q2hhckNvZGUgKyA0Myk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobmV4dENoYXIgPj0gJ1QnICYmIG5leHRDaGFyIDw9ICdaJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjb2RlZENoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDEyNyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdjJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRDaGFyID49ICdBJyAmJiBuZXh0Q2hhciA8PSAnTycpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY29kZWRDaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZShuZXh0Q2hhckNvZGUgLSAzMik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobmV4dENoYXIgPT09ICdaJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjb2RlZENoYXIgPSAnOic7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdkJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRDaGFyID49ICdBJyAmJiBuZXh0Q2hhciA8PSAnWicpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY29kZWRDaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZShuZXh0Q2hhckNvZGUgKyAzMik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJyogY29kZV85M19yZWFkZXIgX2RlY29kZUV4dGVuZGVkIGhpdCBkZWZhdWx0IGNhc2UsIHRoaXMgbWF5IGJlIGFuIGVycm9yJywgZGVjb2RlZENoYXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGRlY29kZWRDaGFyKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGNoYXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG5cclxuICAgIHByb3RlY3RlZCBfbWF0Y2hDaGVja0NoYXIoY2hhckFycmF5OiBBcnJheTxzdHJpbmc+LCBpbmRleDogbnVtYmVyLCBtYXhXZWlnaHQ6IG51bWJlcik6IGJvb2xlYW4ge1xyXG4gICAgICAgIGNvbnN0IGFycmF5VG9DaGVjayA9IGNoYXJBcnJheS5zbGljZSgwLCBpbmRleCk7XHJcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gYXJyYXlUb0NoZWNrLmxlbmd0aDtcclxuICAgICAgICBjb25zdCB3ZWlnaHRlZFN1bXMgPSBhcnJheVRvQ2hlY2sucmVkdWNlKChzdW0sIGNoYXIsIGkpID0+IHtcclxuICAgICAgICAgICAgY29uc3Qgd2VpZ2h0ID0gKCgoaSAqIC0xKSArIChsZW5ndGggLSAxKSkgJSBtYXhXZWlnaHQpICsgMTtcclxuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBBTFBIQUJFVC5pbmRleE9mKGNoYXIuY2hhckNvZGVBdCgwKSk7XHJcbiAgICAgICAgICAgIHJldHVybiBzdW0gKyAod2VpZ2h0ICogdmFsdWUpO1xyXG4gICAgICAgIH0sIDApO1xyXG5cclxuICAgICAgICBjb25zdCBjaGVja0NoYXIgPSBBTFBIQUJFVFsod2VpZ2h0ZWRTdW1zICUgNDcpXTtcclxuICAgICAgICByZXR1cm4gY2hlY2tDaGFyID09PSBjaGFyQXJyYXlbaW5kZXhdLmNoYXJDb2RlQXQoMCk7XHJcbiAgICB9O1xyXG5cclxuICAgIHByb3RlY3RlZCBfdmVyaWZ5Q2hlY2tzdW1zKGNoYXJBcnJheTogQXJyYXk8c3RyaW5nPik6IGJvb2xlYW4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9tYXRjaENoZWNrQ2hhcihjaGFyQXJyYXksIGNoYXJBcnJheS5sZW5ndGggLSAyLCAyMClcclxuICAgICAgICAgICAgJiYgdGhpcy5fbWF0Y2hDaGVja0NoYXIoY2hhckFycmF5LCBjaGFyQXJyYXkubGVuZ3RoIC0gMSwgMTUpO1xyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgZGVjb2RlKHJvdz86IEFycmF5PG51bWJlcj4sIHN0YXJ0PzogQmFyY29kZVBvc2l0aW9uIHwgbnVtYmVyIHwgbnVsbCk6IEJhcmNvZGUgfCBudWxsIHtcclxuICAgICAgICBzdGFydCA9IHRoaXMuX2ZpbmRTdGFydCgpO1xyXG4gICAgICAgIGlmICghc3RhcnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgY291bnRlcnMgPSBuZXcgVWludDE2QXJyYXkoWzAsIDAsIDAsIDAsIDAsIDBdKTtcclxuICAgICAgICBsZXQgcmVzdWx0OiBBcnJheTxzdHJpbmc+IHwgbnVsbCA9IFtdO1xyXG4gICAgICAgIGxldCBuZXh0U3RhcnQgPSB0aGlzLl9uZXh0U2V0KHRoaXMuX3Jvdywgc3RhcnQuZW5kKTtcclxuICAgICAgICBsZXQgbGFzdFN0YXJ0O1xyXG4gICAgICAgIGxldCBkZWNvZGVkQ2hhcjogc3RyaW5nIHwgbnVsbDtcclxuICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgIGNvdW50ZXJzID0gdGhpcy5fdG9Db3VudGVycyhuZXh0U3RhcnQsIGNvdW50ZXJzKSBhcyBVaW50MTZBcnJheTtcclxuICAgICAgICAgICAgY29uc3QgcGF0dGVybiA9IHRoaXMuX3RvUGF0dGVybihjb3VudGVycyk7XHJcbiAgICAgICAgICAgIGlmIChwYXR0ZXJuIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZGVjb2RlZENoYXIgPSB0aGlzLl9wYXR0ZXJuVG9DaGFyKHBhdHRlcm4pO1xyXG4gICAgICAgICAgICBpZiAoZGVjb2RlZENoYXIgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGRlY29kZWRDaGFyKTtcclxuICAgICAgICAgICAgbGFzdFN0YXJ0ID0gbmV4dFN0YXJ0O1xyXG4gICAgICAgICAgICBuZXh0U3RhcnQgKz0gQXJyYXlIZWxwZXIuc3VtKGNvdW50ZXJzKTtcclxuICAgICAgICAgICAgbmV4dFN0YXJ0ID0gdGhpcy5fbmV4dFNldCh0aGlzLl9yb3csIG5leHRTdGFydCk7XHJcbiAgICAgICAgfSB3aGlsZSAoZGVjb2RlZENoYXIgIT09ICcqJyk7XHJcbiAgICAgICAgcmVzdWx0LnBvcCgpO1xyXG5cclxuICAgICAgICBpZiAoIXJlc3VsdC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIXRoaXMuX3ZlcmlmeUVuZChsYXN0U3RhcnQsIG5leHRTdGFydCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIXRoaXMuX3ZlcmlmeUNoZWNrc3VtcyhyZXN1bHQpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnNsaWNlKDAsIHJlc3VsdC5sZW5ndGggLSAyKTtcclxuICAgICAgICAvLyB5ZXMsIHRoaXMgaXMgYW4gYXNzaWduIGluc2lkZSBhbiBpZi5cclxuICAgICAgICBpZiAoKHJlc3VsdCA9IHRoaXMuX2RlY29kZUV4dGVuZGVkKHJlc3VsdCkpID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgY29kZTogcmVzdWx0LmpvaW4oJycpLFxyXG4gICAgICAgICAgICBzdGFydDogc3RhcnQuc3RhcnQsXHJcbiAgICAgICAgICAgIGVuZDogbmV4dFN0YXJ0LFxyXG4gICAgICAgICAgICBzdGFydEluZm86IHN0YXJ0LFxyXG4gICAgICAgICAgICBkZWNvZGVkQ29kZXM6IHJlc3VsdCxcclxuICAgICAgICAgICAgZm9ybWF0OiB0aGlzLkZPUk1BVCxcclxuICAgICAgICB9O1xyXG5cclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgQ29kZTkzUmVhZGVyO1xyXG4iLCJpbXBvcnQgQ29kZTM5UmVhZGVyIGZyb20gJy4vY29kZV8zOV9yZWFkZXInO1xyXG5pbXBvcnQgeyBCYXJjb2RlUG9zaXRpb24sIEJhcmNvZGUgfSBmcm9tICcuL2JhcmNvZGVfcmVhZGVyJztcclxuXHJcbmNvbnN0IHBhdHRlcm5zID0ge1xyXG4gICAgQUVJTzogL1tBRUlPXS9nLFxyXG4gICAgQVowOTogL1tBLVowLTldLyxcclxufTtcclxuXHJcbmNvbnN0IGNvZGUzMnNldCA9ICcwMTIzNDU2Nzg5QkNERkdISktMTU5QUVJTVFVWV1hZWic7XHJcblxyXG5jbGFzcyBDb2RlMzJSZWFkZXIgZXh0ZW5kcyBDb2RlMzlSZWFkZXIge1xyXG4gICAgRk9STUFUID0gJ2NvZGVfMzJfcmVhZGVyJztcclxuXHJcbiAgICBwcm90ZWN0ZWQgX2RlY29kZUNvZGUzMihjb2RlOiBzdHJpbmcpIHtcclxuICAgICAgICBpZiAoL1teMC05QkNERkdISktMTU5QUVJTVFVWV1hZWl0vLnRlc3QoY29kZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCByZXMgPSAwO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29kZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICByZXMgPSByZXMgKiAzMiArIGNvZGUzMnNldC5pbmRleE9mKGNvZGVbaV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgY29kZTMyID0gJycgKyByZXM7XHJcbiAgICAgICAgaWYgKGNvZGUzMi5sZW5ndGggPCA5KSB7XHJcbiAgICAgICAgICAgIGNvZGUzMiA9ICgnMDAwMDAwMDAwJyArIGNvZGUzMikuc2xpY2UoLTkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gJ0EnICsgY29kZTMyO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFRPRE8gKHRoaXMgd2FzIHRvZG8gaW4gb3JpZ2luYWwgcmVwbywgbm8gdGV4dCB3YXMgdGhlcmUuIHNvcnJ5LilcclxuICAgIHByb3RlY3RlZCBfY2hlY2tDaGVja3N1bShjb2RlOiBzdHJpbmcpOiBib29sZWFuIHtcclxuICAgICAgICByZXR1cm4gISFjb2RlO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBkZWNvZGUocm93PzogQXJyYXk8bnVtYmVyPiwgc3RhcnQ/OiBCYXJjb2RlUG9zaXRpb24pOiBCYXJjb2RlIHwgbnVsbCB7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gc3VwZXIuZGVjb2RlKHJvdywgc3RhcnQpO1xyXG4gICAgICAgIGlmICghcmVzdWx0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGNvZGUgPSByZXN1bHQuY29kZTtcclxuXHJcbiAgICAgICAgaWYgKCFjb2RlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29kZSA9IGNvZGUucmVwbGFjZShwYXR0ZXJucy5BRUlPLCAnJyk7XHJcblxyXG4gICAgICAgIGlmICghdGhpcy5fY2hlY2tDaGVja3N1bShjb2RlKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBjb2RlMzIgPSB0aGlzLl9kZWNvZGVDb2RlMzIoY29kZSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKCFjb2RlMzIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHJlc3VsdC5jb2RlID0gY29kZTMyO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcblxyXG4gICAgfTtcclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgQ29kZTMyUmVhZGVyO1xyXG4iLCJpbXBvcnQgQnJlc2VuaGFtIGZyb20gJy4vYnJlc2VuaGFtJztcclxuaW1wb3J0IEltYWdlRGVidWcgZnJvbSAnLi4vY29tbW9uL2ltYWdlX2RlYnVnJztcclxuaW1wb3J0IENvZGUxMjhSZWFkZXIgZnJvbSAnLi4vcmVhZGVyL2NvZGVfMTI4X3JlYWRlcic7XHJcbmltcG9ydCBFQU5SZWFkZXIgZnJvbSAnLi4vcmVhZGVyL2Vhbl9yZWFkZXInO1xyXG5pbXBvcnQgQ29kZTM5UmVhZGVyIGZyb20gJy4uL3JlYWRlci9jb2RlXzM5X3JlYWRlcic7XHJcbmltcG9ydCBDb2RlMzlWSU5SZWFkZXIgZnJvbSAnLi4vcmVhZGVyL2NvZGVfMzlfdmluX3JlYWRlcic7XHJcbmltcG9ydCBDb2RhYmFyUmVhZGVyIGZyb20gJy4uL3JlYWRlci9jb2RhYmFyX3JlYWRlcic7XHJcbmltcG9ydCBVUENSZWFkZXIgZnJvbSAnLi4vcmVhZGVyL3VwY19yZWFkZXInO1xyXG5pbXBvcnQgRUFOOFJlYWRlciBmcm9tICcuLi9yZWFkZXIvZWFuXzhfcmVhZGVyJztcclxuaW1wb3J0IEVBTjJSZWFkZXIgZnJvbSAnLi4vcmVhZGVyL2Vhbl8yX3JlYWRlcic7XHJcbmltcG9ydCBFQU41UmVhZGVyIGZyb20gJy4uL3JlYWRlci9lYW5fNV9yZWFkZXInO1xyXG5pbXBvcnQgVVBDRVJlYWRlciBmcm9tICcuLi9yZWFkZXIvdXBjX2VfcmVhZGVyJztcclxuaW1wb3J0IEkyb2Y1UmVhZGVyIGZyb20gJy4uL3JlYWRlci9pMm9mNV9yZWFkZXInO1xyXG5pbXBvcnQgVHdvT2ZGaXZlUmVhZGVyIGZyb20gJy4uL3JlYWRlci8yb2Y1X3JlYWRlcic7XHJcbmltcG9ydCBDb2RlOTNSZWFkZXIgZnJvbSAnLi4vcmVhZGVyL2NvZGVfOTNfcmVhZGVyJztcclxuaW1wb3J0IENvZGUzMlJlYWRlciBmcm9tICcuLi9yZWFkZXIvY29kZV8zMl9yZWFkZXInO1xyXG5cclxuY29uc3QgUkVBREVSUyA9IHtcclxuICAgIGNvZGVfMTI4X3JlYWRlcjogQ29kZTEyOFJlYWRlcixcclxuICAgIGVhbl9yZWFkZXI6IEVBTlJlYWRlcixcclxuICAgIGVhbl81X3JlYWRlcjogRUFONVJlYWRlcixcclxuICAgIGVhbl8yX3JlYWRlcjogRUFOMlJlYWRlcixcclxuICAgIGVhbl84X3JlYWRlcjogRUFOOFJlYWRlcixcclxuICAgIGNvZGVfMzlfcmVhZGVyOiBDb2RlMzlSZWFkZXIsXHJcbiAgICBjb2RlXzM5X3Zpbl9yZWFkZXI6IENvZGUzOVZJTlJlYWRlcixcclxuICAgIGNvZGFiYXJfcmVhZGVyOiBDb2RhYmFyUmVhZGVyLFxyXG4gICAgdXBjX3JlYWRlcjogVVBDUmVhZGVyLFxyXG4gICAgdXBjX2VfcmVhZGVyOiBVUENFUmVhZGVyLFxyXG4gICAgaTJvZjVfcmVhZGVyOiBJMm9mNVJlYWRlcixcclxuICAgICcyb2Y1X3JlYWRlcic6IFR3b09mRml2ZVJlYWRlcixcclxuICAgIGNvZGVfOTNfcmVhZGVyOiBDb2RlOTNSZWFkZXIsXHJcbiAgICBjb2RlXzMyX3JlYWRlcjogQ29kZTMyUmVhZGVyLFxyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gICAgcmVnaXN0ZXJSZWFkZXI6IChuYW1lLCByZWFkZXIpID0+IHtcclxuICAgICAgICBSRUFERVJTW25hbWVdID0gcmVhZGVyO1xyXG4gICAgfSxcclxuICAgIGNyZWF0ZShjb25maWcsIGlucHV0SW1hZ2VXcmFwcGVyKSB7XHJcbiAgICAgICAgY29uc3QgX2NhbnZhcyA9IHtcclxuICAgICAgICAgICAgY3R4OiB7XHJcbiAgICAgICAgICAgICAgICBmcmVxdWVuY3k6IG51bGwsXHJcbiAgICAgICAgICAgICAgICBwYXR0ZXJuOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgb3ZlcmxheTogbnVsbCxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZG9tOiB7XHJcbiAgICAgICAgICAgICAgICBmcmVxdWVuY3k6IG51bGwsXHJcbiAgICAgICAgICAgICAgICBwYXR0ZXJuOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgb3ZlcmxheTogbnVsbCxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNvbnN0IF9iYXJjb2RlUmVhZGVycyA9IFtdO1xyXG5cclxuICAgICAgICBpbml0Q2FudmFzKCk7XHJcbiAgICAgICAgaW5pdFJlYWRlcnMoKTtcclxuICAgICAgICBpbml0Q29uZmlnKCk7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGluaXRDYW52YXMoKSB7XHJcbiAgICAgICAgICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgJGRlYnVnID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI2RlYnVnLmRldGVjdGlvbicpO1xyXG4gICAgICAgICAgICAgICAgX2NhbnZhcy5kb20uZnJlcXVlbmN5ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignY2FudmFzLmZyZXF1ZW5jeScpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFfY2FudmFzLmRvbS5mcmVxdWVuY3kpIHtcclxuICAgICAgICAgICAgICAgICAgICBfY2FudmFzLmRvbS5mcmVxdWVuY3kgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcclxuICAgICAgICAgICAgICAgICAgICBfY2FudmFzLmRvbS5mcmVxdWVuY3kuY2xhc3NOYW1lID0gJ2ZyZXF1ZW5jeSc7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCRkZWJ1Zykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAkZGVidWcuYXBwZW5kQ2hpbGQoX2NhbnZhcy5kb20uZnJlcXVlbmN5KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBfY2FudmFzLmN0eC5mcmVxdWVuY3kgPSBfY2FudmFzLmRvbS5mcmVxdWVuY3kuZ2V0Q29udGV4dCgnMmQnKTtcclxuXHJcbiAgICAgICAgICAgICAgICBfY2FudmFzLmRvbS5wYXR0ZXJuID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignY2FudmFzLnBhdHRlcm5CdWZmZXInKTtcclxuICAgICAgICAgICAgICAgIGlmICghX2NhbnZhcy5kb20ucGF0dGVybikge1xyXG4gICAgICAgICAgICAgICAgICAgIF9jYW52YXMuZG9tLnBhdHRlcm4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcclxuICAgICAgICAgICAgICAgICAgICBfY2FudmFzLmRvbS5wYXR0ZXJuLmNsYXNzTmFtZSA9ICdwYXR0ZXJuQnVmZmVyJztcclxuICAgICAgICAgICAgICAgICAgICBpZiAoJGRlYnVnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICRkZWJ1Zy5hcHBlbmRDaGlsZChfY2FudmFzLmRvbS5wYXR0ZXJuKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBfY2FudmFzLmN0eC5wYXR0ZXJuID0gX2NhbnZhcy5kb20ucGF0dGVybi5nZXRDb250ZXh0KCcyZCcpO1xyXG5cclxuICAgICAgICAgICAgICAgIF9jYW52YXMuZG9tLm92ZXJsYXkgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdjYW52YXMuZHJhd2luZ0J1ZmZlcicpO1xyXG4gICAgICAgICAgICAgICAgaWYgKF9jYW52YXMuZG9tLm92ZXJsYXkpIHtcclxuICAgICAgICAgICAgICAgICAgICBfY2FudmFzLmN0eC5vdmVybGF5ID0gX2NhbnZhcy5kb20ub3ZlcmxheS5nZXRDb250ZXh0KCcyZCcpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBpbml0UmVhZGVycygpIHtcclxuICAgICAgICAgICAgY29uZmlnLnJlYWRlcnMuZm9yRWFjaCgocmVhZGVyQ29uZmlnKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBsZXQgcmVhZGVyO1xyXG4gICAgICAgICAgICAgICAgbGV0IGNvbmZpZ3VyYXRpb24gPSB7fTtcclxuICAgICAgICAgICAgICAgIGxldCBzdXBwbGVtZW50cyA9IFtdO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcmVhZGVyQ29uZmlnID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlYWRlciA9IHJlYWRlckNvbmZpZy5mb3JtYXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhdGlvbiA9IHJlYWRlckNvbmZpZy5jb25maWc7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiByZWFkZXJDb25maWcgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyID0gcmVhZGVyQ29uZmlnO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKEVOVi5kZXZlbG9wbWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdCZWZvcmUgcmVnaXN0ZXJpbmcgcmVhZGVyOiAnLCByZWFkZXIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24uc3VwcGxlbWVudHMpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdXBwbGVtZW50cyA9IGNvbmZpZ3VyYXRpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgLnN1cHBsZW1lbnRzLm1hcCgoc3VwcGxlbWVudCkgPT4gbmV3IFJFQURFUlNbc3VwcGxlbWVudF0oKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlYWRlck9iaiA9IG5ldyBSRUFERVJTW3JlYWRlcl0oY29uZmlndXJhdGlvbiwgc3VwcGxlbWVudHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIF9iYXJjb2RlUmVhZGVycy5wdXNoKHJlYWRlck9iaik7XHJcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCcqIEVycm9yIGNvbnN0cnVjdGluZyByZWFkZXIgJywgcmVhZGVyLCBlcnIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBSZWdpc3RlcmVkIFJlYWRlcnM6ICR7X2JhcmNvZGVSZWFkZXJzXHJcbiAgICAgICAgICAgICAgICAgICAgLm1hcCgocmVhZGVyKSA9PiBKU09OLnN0cmluZ2lmeSh7IGZvcm1hdDogcmVhZGVyLkZPUk1BVCwgY29uZmlnOiByZWFkZXIuY29uZmlnIH0pKVxyXG4gICAgICAgICAgICAgICAgICAgIC5qb2luKCcsICcpfWApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBpbml0Q29uZmlnKCkge1xyXG4gICAgICAgICAgICBpZiAoRU5WLmRldmVsb3BtZW50ICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgICAgIGxldCBpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdmlzID0gW3tcclxuICAgICAgICAgICAgICAgICAgICBub2RlOiBfY2FudmFzLmRvbS5mcmVxdWVuY3ksXHJcbiAgICAgICAgICAgICAgICAgICAgcHJvcDogY29uZmlnLmRlYnVnLnNob3dGcmVxdWVuY3ksXHJcbiAgICAgICAgICAgICAgICB9LCB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZTogX2NhbnZhcy5kb20ucGF0dGVybixcclxuICAgICAgICAgICAgICAgICAgICBwcm9wOiBjb25maWcuZGVidWcuc2hvd1BhdHRlcm4sXHJcbiAgICAgICAgICAgICAgICB9XTtcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdmlzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZpc1tpXS5wcm9wID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpc1tpXS5ub2RlLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpc1tpXS5ub2RlLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBleHRlbmQgdGhlIGxpbmUgb24gYm90aCBlbmRzXHJcbiAgICAgICAgICogQHBhcmFtIHtBcnJheX0gbGluZVxyXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhbmdsZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIGdldEV4dGVuZGVkTGluZShsaW5lLCBhbmdsZSwgZXh0KSB7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGV4dGVuZExpbmUoYW1vdW50KSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBleHRlbnNpb24gPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeTogYW1vdW50ICogTWF0aC5zaW4oYW5nbGUpLFxyXG4gICAgICAgICAgICAgICAgICAgIHg6IGFtb3VudCAqIE1hdGguY29zKGFuZ2xlKSxcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1wYXJhbS1yZWFzc2lnbiAqL1xyXG4gICAgICAgICAgICAgICAgbGluZVswXS55IC09IGV4dGVuc2lvbi55O1xyXG4gICAgICAgICAgICAgICAgbGluZVswXS54IC09IGV4dGVuc2lvbi54O1xyXG4gICAgICAgICAgICAgICAgbGluZVsxXS55ICs9IGV4dGVuc2lvbi55O1xyXG4gICAgICAgICAgICAgICAgbGluZVsxXS54ICs9IGV4dGVuc2lvbi54O1xyXG4gICAgICAgICAgICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1wYXJhbS1yZWFzc2lnbiAqL1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBjaGVjayBpZiBpbnNpZGUgaW1hZ2VcclxuICAgICAgICAgICAgZXh0ZW5kTGluZShleHQpO1xyXG4gICAgICAgICAgICB3aGlsZSAoZXh0ID4gMSAmJiAoIWlucHV0SW1hZ2VXcmFwcGVyLmluSW1hZ2VXaXRoQm9yZGVyKGxpbmVbMF0pXHJcbiAgICAgICAgICAgICAgICAgICAgfHwgIWlucHV0SW1hZ2VXcmFwcGVyLmluSW1hZ2VXaXRoQm9yZGVyKGxpbmVbMV0pKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXHJcbiAgICAgICAgICAgICAgICBleHQgLT0gTWF0aC5jZWlsKGV4dCAvIDIpO1xyXG4gICAgICAgICAgICAgICAgZXh0ZW5kTGluZSgtZXh0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbGluZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGdldExpbmUoYm94KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbe1xyXG4gICAgICAgICAgICAgICAgeDogKGJveFsxXVswXSAtIGJveFswXVswXSkgLyAyICsgYm94WzBdWzBdLFxyXG4gICAgICAgICAgICAgICAgeTogKGJveFsxXVsxXSAtIGJveFswXVsxXSkgLyAyICsgYm94WzBdWzFdLFxyXG4gICAgICAgICAgICB9LCB7XHJcbiAgICAgICAgICAgICAgICB4OiAoYm94WzNdWzBdIC0gYm94WzJdWzBdKSAvIDIgKyBib3hbMl1bMF0sXHJcbiAgICAgICAgICAgICAgICB5OiAoYm94WzNdWzFdIC0gYm94WzJdWzFdKSAvIDIgKyBib3hbMl1bMV0sXHJcbiAgICAgICAgICAgIH1dO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gdHJ5RGVjb2RlKGxpbmUpIHtcclxuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IG51bGw7XHJcbiAgICAgICAgICAgIGxldCBpO1xyXG4gICAgICAgICAgICBjb25zdCBiYXJjb2RlTGluZSA9IEJyZXNlbmhhbS5nZXRCYXJjb2RlTGluZShpbnB1dEltYWdlV3JhcHBlciwgbGluZVswXSwgbGluZVsxXSk7XHJcblxyXG4gICAgICAgICAgICBpZiAoRU5WLmRldmVsb3BtZW50ICYmIGNvbmZpZy5kZWJ1Zy5zaG93RnJlcXVlbmN5KSB7XHJcbiAgICAgICAgICAgICAgICBJbWFnZURlYnVnLmRyYXdQYXRoKGxpbmUsIHsgeDogJ3gnLCB5OiAneScgfSwgX2NhbnZhcy5jdHgub3ZlcmxheSwgeyBjb2xvcjogJ3JlZCcsIGxpbmVXaWR0aDogMyB9KTtcclxuICAgICAgICAgICAgICAgIEJyZXNlbmhhbS5kZWJ1Zy5wcmludEZyZXF1ZW5jeShiYXJjb2RlTGluZS5saW5lLCBfY2FudmFzLmRvbS5mcmVxdWVuY3kpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBCcmVzZW5oYW0udG9CaW5hcnlMaW5lKGJhcmNvZGVMaW5lKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQgJiYgY29uZmlnLmRlYnVnLnNob3dQYXR0ZXJuKSB7XHJcbiAgICAgICAgICAgICAgICBCcmVzZW5oYW0uZGVidWcucHJpbnRQYXR0ZXJuKGJhcmNvZGVMaW5lLmxpbmUsIF9jYW52YXMuZG9tLnBhdHRlcm4pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgX2JhcmNvZGVSZWFkZXJzLmxlbmd0aCAmJiByZXN1bHQgPT09IG51bGw7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gX2JhcmNvZGVSZWFkZXJzW2ldLmRlY29kZVBhdHRlcm4oYmFyY29kZUxpbmUubGluZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGNvZGVSZXN1bHQ6IHJlc3VsdCxcclxuICAgICAgICAgICAgICAgIGJhcmNvZGVMaW5lLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhpcyBtZXRob2Qgc2xpY2VzIHRoZSBnaXZlbiBhcmVhIGFwYXJ0IGFuZCB0cmllcyB0byBkZXRlY3QgYSBiYXJjb2RlLXBhdHRlcm5cclxuICAgICAgICAgKiBmb3IgZWFjaCBzbGljZS4gSXQgcmV0dXJucyB0aGUgZGVjb2RlZCBiYXJjb2RlLCBvciBudWxsIGlmIG5vdGhpbmcgd2FzIGZvdW5kXHJcbiAgICAgICAgICogQHBhcmFtIHtBcnJheX0gYm94XHJcbiAgICAgICAgICogQHBhcmFtIHtBcnJheX0gbGluZVxyXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lQW5nbGVcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiB0cnlEZWNvZGVCcnV0ZUZvcmNlKGJveCwgbGluZSwgbGluZUFuZ2xlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNpZGVMZW5ndGggPSBNYXRoLnNxcnQoTWF0aC5wb3coYm94WzFdWzBdIC0gYm94WzBdWzBdLCAyKSArIE1hdGgucG93KChib3hbMV1bMV0gLSBib3hbMF1bMV0pLCAyKSk7XHJcbiAgICAgICAgICAgIGxldCBpO1xyXG4gICAgICAgICAgICBjb25zdCBzbGljZXMgPSAxNjtcclxuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IG51bGw7XHJcbiAgICAgICAgICAgIGxldCBkaXI7XHJcbiAgICAgICAgICAgIGxldCBleHRlbnNpb247XHJcbiAgICAgICAgICAgIGNvbnN0IHhkaXIgPSBNYXRoLnNpbihsaW5lQW5nbGUpO1xyXG4gICAgICAgICAgICBjb25zdCB5ZGlyID0gTWF0aC5jb3MobGluZUFuZ2xlKTtcclxuXHJcbiAgICAgICAgICAgIGZvciAoaSA9IDE7IGkgPCBzbGljZXMgJiYgcmVzdWx0ID09PSBudWxsOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIC8vIG1vdmUgbGluZSBwZXJwZW5kaWN1bGFyIHRvIGFuZ2xlXHJcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbWl4ZWQtb3BlcmF0b3JzXHJcbiAgICAgICAgICAgICAgICBkaXIgPSBzaWRlTGVuZ3RoIC8gc2xpY2VzICogaSAqIChpICUgMiA9PT0gMCA/IC0xIDogMSk7XHJcbiAgICAgICAgICAgICAgICBleHRlbnNpb24gPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeTogZGlyICogeGRpcixcclxuICAgICAgICAgICAgICAgICAgICB4OiBkaXIgKiB5ZGlyLFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXBhcmFtLXJlYXNzaWduICovXHJcbiAgICAgICAgICAgICAgICBsaW5lWzBdLnkgKz0gZXh0ZW5zaW9uLng7XHJcbiAgICAgICAgICAgICAgICBsaW5lWzBdLnggLT0gZXh0ZW5zaW9uLnk7XHJcbiAgICAgICAgICAgICAgICBsaW5lWzFdLnkgKz0gZXh0ZW5zaW9uLng7XHJcbiAgICAgICAgICAgICAgICBsaW5lWzFdLnggLT0gZXh0ZW5zaW9uLnk7XHJcbiAgICAgICAgICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXBhcmFtLXJlYXNzaWduICovXHJcblxyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdHJ5RGVjb2RlKGxpbmUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBnZXRMaW5lTGVuZ3RoKGxpbmUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIE1hdGguc3FydChcclxuICAgICAgICAgICAgICAgIE1hdGgucG93KE1hdGguYWJzKGxpbmVbMV0ueSAtIGxpbmVbMF0ueSksIDIpXHJcbiAgICAgICAgICAgICAgICArIE1hdGgucG93KE1hdGguYWJzKGxpbmVbMV0ueCAtIGxpbmVbMF0ueCksIDIpLFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gZGVjb2RlRnJvbUltYWdlKGltYWdlV3JhcHBlcikge1xyXG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gbnVsbDtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBfYmFyY29kZVJlYWRlcnMubGVuZ3RoICYmIHJlc3VsdCA9PT0gbnVsbDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBfYmFyY29kZVJlYWRlcnNbaV0uZGVjb2RlSW1hZ2UgPyBfYmFyY29kZVJlYWRlcnNbaV0uZGVjb2RlSW1hZ2UoaW1hZ2VXcmFwcGVyKSA6IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogV2l0aCB0aGUgaGVscCBvZiB0aGUgY29uZmlndXJlZCByZWFkZXJzIChDb2RlMTI4IG9yIEVBTikgdGhpcyBmdW5jdGlvbiB0cmllcyB0byBkZXRlY3QgYVxyXG4gICAgICAgICAqIHZhbGlkIGJhcmNvZGUgcGF0dGVybiB3aXRoaW4gdGhlIGdpdmVuIGFyZWEuXHJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGJveCBUaGUgYXJlYSB0byBzZWFyY2ggaW5cclxuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSB0aGUgcmVzdWx0IHtjb2RlUmVzdWx0LCBsaW5lLCBhbmdsZSwgcGF0dGVybiwgdGhyZXNob2xkfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIGRlY29kZUZyb21Cb3VuZGluZ0JveChib3gpIHtcclxuICAgICAgICAgICAgbGV0IGxpbmU7XHJcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IF9jYW52YXMuY3R4Lm92ZXJsYXk7XHJcbiAgICAgICAgICAgIGxldCByZXN1bHQ7XHJcblxyXG4gICAgICAgICAgICBpZiAoRU5WLmRldmVsb3BtZW50KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY29uZmlnLmRlYnVnLmRyYXdCb3VuZGluZ0JveCAmJiBjdHgpIHtcclxuICAgICAgICAgICAgICAgICAgICBJbWFnZURlYnVnLmRyYXdQYXRoKGJveCwgeyB4OiAwLCB5OiAxIH0sIGN0eCwgeyBjb2xvcjogJ2JsdWUnLCBsaW5lV2lkdGg6IDIgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGxpbmUgPSBnZXRMaW5lKGJveCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGxpbmVMZW5ndGggPSBnZXRMaW5lTGVuZ3RoKGxpbmUpO1xyXG4gICAgICAgICAgICBjb25zdCBsaW5lQW5nbGUgPSBNYXRoLmF0YW4yKGxpbmVbMV0ueSAtIGxpbmVbMF0ueSwgbGluZVsxXS54IC0gbGluZVswXS54KTtcclxuICAgICAgICAgICAgbGluZSA9IGdldEV4dGVuZGVkTGluZShsaW5lLCBsaW5lQW5nbGUsIE1hdGguZmxvb3IobGluZUxlbmd0aCAqIDAuMSkpO1xyXG4gICAgICAgICAgICBpZiAobGluZSA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJlc3VsdCA9IHRyeURlY29kZShsaW5lKTtcclxuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdHJ5RGVjb2RlQnJ1dGVGb3JjZShib3gsIGxpbmUsIGxpbmVBbmdsZSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoRU5WLmRldmVsb3BtZW50ICYmIHJlc3VsdCAmJiBjb25maWcuZGVidWcuZHJhd1NjYW5saW5lICYmIGN0eCkge1xyXG4gICAgICAgICAgICAgICAgSW1hZ2VEZWJ1Zy5kcmF3UGF0aChsaW5lLCB7IHg6ICd4JywgeTogJ3knIH0sIGN0eCwgeyBjb2xvcjogJ3JlZCcsIGxpbmVXaWR0aDogMyB9KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGNvZGVSZXN1bHQ6IHJlc3VsdC5jb2RlUmVzdWx0LFxyXG4gICAgICAgICAgICAgICAgbGluZSxcclxuICAgICAgICAgICAgICAgIGFuZ2xlOiBsaW5lQW5nbGUsXHJcbiAgICAgICAgICAgICAgICBwYXR0ZXJuOiByZXN1bHQuYmFyY29kZUxpbmUubGluZSxcclxuICAgICAgICAgICAgICAgIHRocmVzaG9sZDogcmVzdWx0LmJhcmNvZGVMaW5lLnRocmVzaG9sZCxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGRlY29kZUZyb21Cb3VuZGluZ0JveChib3gpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBkZWNvZGVGcm9tQm91bmRpbmdCb3goYm94KTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZGVjb2RlRnJvbUJvdW5kaW5nQm94ZXMoYm94ZXMpIHtcclxuICAgICAgICAgICAgICAgIGxldCBpOyBsZXQgcmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYmFyY29kZXMgPSBbXTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHsgbXVsdGlwbGUgfSA9IGNvbmZpZztcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYm94ZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBib3ggPSBib3hlc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBkZWNvZGVGcm9tQm91bmRpbmdCb3goYm94KSB8fCB7fTtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQuYm94ID0gYm94O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAobXVsdGlwbGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYmFyY29kZXMucHVzaChyZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocmVzdWx0LmNvZGVSZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKG11bHRpcGxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYmFyY29kZXMsXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZGVjb2RlRnJvbUltYWdlKGlucHV0SW1hZ2VXcmFwcGVyKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBkZWNvZGVGcm9tSW1hZ2UoaW5wdXRJbWFnZVdyYXBwZXIpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgcmVnaXN0ZXJSZWFkZXIobmFtZSwgcmVhZGVyKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoUkVBREVSU1tuYW1lXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IHJlZ2lzdGVyIGV4aXN0aW5nIHJlYWRlcicsIG5hbWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgUkVBREVSU1tuYW1lXSA9IHJlYWRlcjtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc2V0UmVhZGVycyhyZWFkZXJzKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cclxuICAgICAgICAgICAgICAgIGNvbmZpZy5yZWFkZXJzID0gcmVhZGVycztcclxuICAgICAgICAgICAgICAgIF9iYXJjb2RlUmVhZGVycy5sZW5ndGggPSAwO1xyXG4gICAgICAgICAgICAgICAgaW5pdFJlYWRlcnMoKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9O1xyXG4gICAgfSxcclxufTtcclxuIiwiaW1wb3J0IEJhcmNvZGVSZWFkZXIgZnJvbSAnLi9iYXJjb2RlX3JlYWRlcic7XHJcbmltcG9ydCBUd29PZkZpdmVSZWFkZXIgZnJvbSAnLi8yb2Y1X3JlYWRlcic7XHJcbmltcG9ydCBOZXdDb2RhYmFyUmVhZGVyIGZyb20gJy4vY29kYWJhcl9yZWFkZXInO1xyXG5pbXBvcnQgQ29kZTEyOFJlYWRlciBmcm9tICcuL2NvZGVfMTI4X3JlYWRlcic7XHJcbmltcG9ydCBDb2RlMzJSZWFkZXIgZnJvbSAnLi9jb2RlXzMyX3JlYWRlcic7XHJcbmltcG9ydCBDb2RlMzlSZWFkZXIgZnJvbSAnLi9jb2RlXzM5X3JlYWRlcic7XHJcbmltcG9ydCBDb2RlMzlWSU5SZWFkZXIgZnJvbSAnLi9jb2RlXzM5X3Zpbl9yZWFkZXInO1xyXG5pbXBvcnQgQ29kZTkzUmVhZGVyIGZyb20gJy4vY29kZV85M19yZWFkZXInO1xyXG5pbXBvcnQgRUFOMlJlYWRlciBmcm9tICcuL2Vhbl8yX3JlYWRlcic7XHJcbmltcG9ydCBFQU41UmVhZGVyIGZyb20gJy4vZWFuXzVfcmVhZGVyJztcclxuaW1wb3J0IEVBTjhSZWFkZXIgZnJvbSAnLi9lYW5fOF9yZWFkZXInO1xyXG5pbXBvcnQgRUFOUmVhZGVyIGZyb20gJy4vZWFuX3JlYWRlcic7XHJcbmltcG9ydCBJMm9mNVJlYWRlciBmcm9tICcuL2kyb2Y1X3JlYWRlcic7XHJcbmltcG9ydCBVUENFUmVhZGVyIGZyb20gJy4vdXBjX2VfcmVhZGVyJztcclxuaW1wb3J0IFVQQ1JlYWRlciBmcm9tICcuL3VwY19yZWFkZXInO1xyXG5cclxuZXhwb3J0IHtcclxuICAgIEJhcmNvZGVSZWFkZXIsXHJcbiAgICBUd29PZkZpdmVSZWFkZXIsXHJcbiAgICBOZXdDb2RhYmFyUmVhZGVyLFxyXG4gICAgQ29kZTEyOFJlYWRlcixcclxuICAgIENvZGUzMlJlYWRlcixcclxuICAgIENvZGUzOVJlYWRlcixcclxuICAgIENvZGUzOVZJTlJlYWRlcixcclxuICAgIENvZGU5M1JlYWRlcixcclxuICAgIEVBTjJSZWFkZXIsXHJcbiAgICBFQU41UmVhZGVyLFxyXG4gICAgRUFOOFJlYWRlcixcclxuICAgIEVBTlJlYWRlcixcclxuICAgIEkyb2Y1UmVhZGVyLFxyXG4gICAgVVBDRVJlYWRlcixcclxuICAgIFVQQ1JlYWRlciwgICAgXHJcbn1cclxuIiwidHlwZSBFdmVudE5hbWUgPSBzdHJpbmc7XHJcblxyXG5pbnRlcmZhY2UgU3Vic2NyaXB0aW9uIHtcclxuICAgIGFzeW5jPzogYm9vbGVhbjtcclxuICAgIGNhbGxiYWNrOiBGdW5jdGlvbjtcclxuICAgIG9uY2U/OiBib29sZWFuO1xyXG59XHJcblxyXG5pbnRlcmZhY2UgRXZlbnREYXRhIHtcclxuICAgIHN1YnNjcmliZXJzOiBBcnJheTxTdWJzY3JpcHRpb24+O1xyXG59XHJcblxyXG5pbnRlcmZhY2UgRXZlbnRzIHtcclxuICAgIFtrZXk6IHN0cmluZ106IEV2ZW50RGF0YTtcclxufVxyXG5cclxuaW50ZXJmYWNlIEV2ZW50SW50ZXJmYWNlIHtcclxuICAgIHN1YnNjcmliZShldmVudDogRXZlbnROYW1lLCBjYWxsYmFjazogRnVuY3Rpb24gfCBTdWJzY3JpcHRpb24sIGFzeW5jPzogYm9vbGVhbik6IHZvaWQ7XHJcbiAgICBwdWJsaXNoKGV2ZW50TmFtZTogRXZlbnROYW1lLCBkYXRhPzogbmV2ZXIpOiB2b2lkO1xyXG4gICAgb25jZShldmVudDogRXZlbnROYW1lLCBjYWxsYmFjazogRnVuY3Rpb24sIGFzeW5jPzogYm9vbGVhbik6IHZvaWQ7XHJcbiAgICB1bnN1YnNjcmliZShldmVudE5hbWU/OiBFdmVudE5hbWUsIGNhbGxiYWNrPzogRnVuY3Rpb24gfCBTdWJzY3JpcHRpb24pOiB2b2lkO1xyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCAoZnVuY3Rpb24gRXZlbnRJbnRlcmZhY2UoKTogRXZlbnRJbnRlcmZhY2Uge1xyXG4gICAgbGV0IGV2ZW50czogRXZlbnRzID0ge307XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0RXZlbnQoZXZlbnROYW1lOiBFdmVudE5hbWUpOiBFdmVudERhdGEge1xyXG4gICAgICAgIGlmICghZXZlbnRzW2V2ZW50TmFtZV0pIHtcclxuICAgICAgICAgICAgZXZlbnRzW2V2ZW50TmFtZV0gPSB7XHJcbiAgICAgICAgICAgICAgICBzdWJzY3JpYmVyczogW10sXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBldmVudHNbZXZlbnROYW1lXTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjbGVhckV2ZW50cygpOiB2b2lkIHtcclxuICAgICAgICBldmVudHMgPSB7fTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBwdWJsaXNoU3Vic2NyaXB0aW9uKHN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uLCBkYXRhOiBuZXZlcik6IHZvaWQge1xyXG4gICAgICAgIGlmIChzdWJzY3JpcHRpb24uYXN5bmMpIHtcclxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb24uY2FsbGJhY2soZGF0YSk7XHJcbiAgICAgICAgICAgIH0sIDQpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbi5jYWxsYmFjayhkYXRhKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gX3N1YnNjcmliZShldmVudDogRXZlbnROYW1lLCBjYWxsYmFjazogRnVuY3Rpb24gfCBTdWJzY3JpcHRpb24sIGFzeW5jPzogYm9vbGVhbik6IHZvaWQge1xyXG4gICAgICAgIGxldCBzdWJzY3JpcHRpb247XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgc3Vic2NyaXB0aW9uID0ge1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2ssXHJcbiAgICAgICAgICAgICAgICBhc3luYyxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBzdWJzY3JpcHRpb24gPSBjYWxsYmFjaztcclxuICAgICAgICAgICAgaWYgKCFzdWJzY3JpcHRpb24uY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FsbGJhY2sgd2FzIG5vdCBzcGVjaWZpZWQgb24gb3B0aW9ucycpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBnZXRFdmVudChldmVudCkuc3Vic2NyaWJlcnMucHVzaChzdWJzY3JpcHRpb24pO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgc3Vic2NyaWJlKGV2ZW50OiBFdmVudE5hbWUsIGNhbGxiYWNrOiBGdW5jdGlvbiB8IFN1YnNjcmlwdGlvbiwgYXN5bmM/OiBib29sZWFuKTogdm9pZCB7XHJcbiAgICAgICAgICAgIHJldHVybiBfc3Vic2NyaWJlKGV2ZW50LCBjYWxsYmFjaywgYXN5bmMpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcHVibGlzaChldmVudE5hbWU6IEV2ZW50TmFtZSwgZGF0YT86IG5ldmVyKTogdm9pZCB7XHJcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50ID0gZ2V0RXZlbnQoZXZlbnROYW1lKTtcclxuICAgICAgICAgICAgY29uc3QgeyBzdWJzY3JpYmVycyB9ID0gZXZlbnQ7XHJcblxyXG4gICAgICAgICAgICAvLyBQdWJsaXNoIG9uZS10aW1lIHN1YnNjcmlwdGlvbnNcclxuICAgICAgICAgICAgc3Vic2NyaWJlcnMuZmlsdGVyKChzdWJzY3JpYmVyKSA9PiAhIXN1YnNjcmliZXIub25jZSkuZm9yRWFjaCgoc3Vic2NyaWJlcikgPT4ge1xyXG4gICAgICAgICAgICAgICAgcHVibGlzaFN1YnNjcmlwdGlvbihzdWJzY3JpYmVyLCBkYXRhIGFzIG5ldmVyKTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAvLyByZW1vdmUgdGhlbSBmcm9tIHRoZSBzdWJzY3JpYmVyXHJcbiAgICAgICAgICAgIGV2ZW50LnN1YnNjcmliZXJzID0gc3Vic2NyaWJlcnMuZmlsdGVyKChzdWJzY3JpYmVyKSA9PiAhc3Vic2NyaWJlci5vbmNlKTtcclxuXHJcbiAgICAgICAgICAgIC8vIHB1Ymxpc2ggdGhlIHJlc3RcclxuICAgICAgICAgICAgZXZlbnQuc3Vic2NyaWJlcnMuZm9yRWFjaCgoc3Vic2NyaWJlcikgPT4ge1xyXG4gICAgICAgICAgICAgICAgcHVibGlzaFN1YnNjcmlwdGlvbihzdWJzY3JpYmVyLCBkYXRhIGFzIG5ldmVyKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBvbmNlKGV2ZW50OiBFdmVudE5hbWUsIGNhbGxiYWNrOiBGdW5jdGlvbiwgYXN5bmMgPSBmYWxzZSk6IHZvaWQge1xyXG4gICAgICAgICAgICBfc3Vic2NyaWJlKGV2ZW50LCB7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjayxcclxuICAgICAgICAgICAgICAgIGFzeW5jLFxyXG4gICAgICAgICAgICAgICAgb25jZTogdHJ1ZSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICB1bnN1YnNjcmliZShldmVudE5hbWU/OiBFdmVudE5hbWUsIGNhbGxiYWNrPzogRnVuY3Rpb24gfCBTdWJzY3JpcHRpb24pOiB2b2lkIHtcclxuICAgICAgICAgICAgaWYgKGV2ZW50TmFtZSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZXZlbnQgPSBnZXRFdmVudChldmVudE5hbWUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50ICYmIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQuc3Vic2NyaWJlcnMgPSBldmVudC5zdWJzY3JpYmVycy5maWx0ZXIoKHN1YnNjcmliZXIpID0+IHN1YnNjcmliZXIuY2FsbGJhY2sgIT09IGNhbGxiYWNrKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQuc3Vic2NyaWJlcnMgPSBbXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNsZWFyRXZlbnRzKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgfTtcclxufSgpKTtcclxuIiwiZXhwb3J0IGNsYXNzIEV4Y2VwdGlvbiBleHRlbmRzIEVycm9yIHtcclxuICAgIGNvZGU/OiBudW1iZXI7XHJcbiAgICBjb25zdHJ1Y3RvcihtOiBzdHJpbmcsIGNvZGU/OiBudW1iZXIpIHtcclxuICAgICAgICBzdXBlcihtKTtcclxuICAgICAgICB0aGlzLmNvZGUgPSBjb2RlO1xyXG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBFeGNlcHRpb24ucHJvdG90eXBlKTtcclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgeyBFeGNlcHRpb24gfSBmcm9tICcuLi9xdWFnZ2EvRXhjZXB0aW9uJztcclxuXHJcbmNvbnN0IEVSUk9SX0RFU0MgPSAnVGhpcyBtYXkgbWVhbiB0aGF0IHRoZSB1c2VyIGhhcyBkZWNsaW5lZCBjYW1lcmEgYWNjZXNzLCBvciB0aGUgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IG1lZGlhIEFQSXMuIElmIHlvdSBhcmUgcnVubmluZyBpbiBpT1MsIHlvdSBtdXN0IHVzZSBTYWZhcmkuJztcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBlbnVtZXJhdGVEZXZpY2VzKCk6IFByb21pc2U8QXJyYXk8TWVkaWFEZXZpY2VJbmZvPj4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICByZXR1cm4gbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5lbnVtZXJhdGVEZXZpY2VzKCk7XHJcbiAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICBjb25zdCBlcnJvcjogRXJyb3IgPSBuZXcgRXhjZXB0aW9uKGBlbnVtZXJhdGVEZXZpY2VzIGlzIG5vdCBkZWZpbmVkLiAke0VSUk9SX0RFU0N9YCwgLTEpO1xyXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRVc2VyTWVkaWEoY29uc3RyYWludHM6IE1lZGlhU3RyZWFtQ29uc3RyYWludHMpOiBQcm9taXNlPE1lZGlhU3RyZWFtPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHJldHVybiBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYShjb25zdHJhaW50cyk7XHJcbiAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICBjb25zdCBlcnJvcjogRXJyb3IgPSBuZXcgRXhjZXB0aW9uKGBnZXRVc2VyTWVkaWEgaXMgbm90IGRlZmluZWQuICR7RVJST1JfREVTQ31gLCAtMSk7XHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgcGljayBmcm9tICdsb2Rhc2gvcGljayc7XHJcbmltcG9ydCB7IGdldFVzZXJNZWRpYSwgZW51bWVyYXRlRGV2aWNlcyB9IGZyb20gJy4uL2NvbW1vbi9tZWRpYURldmljZXMnO1xyXG5pbXBvcnQgeyBNZWRpYVRyYWNrQ29uc3RyYWludHNXaXRoRGVwcmVjYXRlZCwgUXVhZ2dhSlNDYW1lcmFBY2Nlc3MgYXMgQ2FtZXJhQWNjZXNzVHlwZSB9IGZyb20gJy4uLy4uL3R5cGUtZGVmaW5pdGlvbnMvcXVhZ2dhLmQnO1xyXG5pbXBvcnQgeyBFeGNlcHRpb24gfSBmcm9tICcuLi9xdWFnZ2EvRXhjZXB0aW9uJztcclxuXHJcbmxldCBzdHJlYW1SZWY6IE1lZGlhU3RyZWFtIHwgbnVsbDtcclxuXHJcbmZ1bmN0aW9uIHdhaXRGb3JWaWRlbyh2aWRlbzogSFRNTFZpZGVvRWxlbWVudCk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICBsZXQgYXR0ZW1wdHMgPSAxMDtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gY2hlY2tWaWRlbygpOiB2b2lkIHtcclxuICAgICAgICAgICAgaWYgKGF0dGVtcHRzID4gMCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHZpZGVvLnZpZGVvV2lkdGggPiAxMCAmJiB2aWRlby52aWRlb0hlaWdodCA+IDEwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKEVOVi5kZXZlbG9wbWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgKiBkZXY6IGNoZWNrVmlkZW8gZm91bmQgJHt2aWRlby52aWRlb1dpZHRofXB4IHggJHt2aWRlby52aWRlb0hlaWdodH1weGApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KGNoZWNrVmlkZW8sIDUwMCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZWplY3QobmV3IEV4Y2VwdGlvbignVW5hYmxlIHRvIHBsYXkgdmlkZW8gc3RyZWFtLiBJcyB3ZWJjYW0gd29ya2luZz8nLCAtMSkpOyAvLyBUT0RPOiBhZGQgZXJyb3IgY29kZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGF0dGVtcHRzLS07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNoZWNrVmlkZW8oKTtcclxuICAgIH0pO1xyXG59XHJcblxyXG4vKipcclxuICogVHJpZXMgdG8gYXR0YWNoIHRoZSBjYW1lcmEtc3RyZWFtIHRvIGEgZ2l2ZW4gdmlkZW8tZWxlbWVudFxyXG4gKiBhbmQgY2FsbHMgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHdoZW4gdGhlIGNvbnRlbnQgaXMgcmVhZHlcclxuICogQHBhcmFtIHtPYmplY3R9IGNvbnN0cmFpbnRzXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSB2aWRlb1xyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gaW5pdENhbWVyYSh2aWRlbzogSFRNTFZpZGVvRWxlbWVudCB8IG51bGwsIGNvbnN0cmFpbnRzOiBNZWRpYVN0cmVhbUNvbnN0cmFpbnRzKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICBjb25zdCBzdHJlYW0gPSBhd2FpdCBnZXRVc2VyTWVkaWEoY29uc3RyYWludHMpO1xyXG4gICAgc3RyZWFtUmVmID0gc3RyZWFtO1xyXG4gICAgaWYgKHZpZGVvKSB7XHJcbiAgICAgICAgdmlkZW8uc2V0QXR0cmlidXRlKCdhdXRvcGxheScsICd0cnVlJyk7XHJcbiAgICAgICAgdmlkZW8uc2V0QXR0cmlidXRlKCdtdXRlZCcsICd0cnVlJyk7XHJcbiAgICAgICAgdmlkZW8uc2V0QXR0cmlidXRlKCdwbGF5c2lubGluZScsICd0cnVlJyk7IC8vIG5vdCBsaXN0ZWQgb24gTUROLi4uXHJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXHJcbiAgICAgICAgdmlkZW8uc3JjT2JqZWN0ID0gc3RyZWFtO1xyXG4gICAgICAgIHZpZGVvLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWRlZG1ldGFkYXRhJywgKCkgPT4ge1xyXG4gICAgICAgICAgICB2aWRlby5wbGF5KCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHdhaXRGb3JWaWRlbyh2aWRlbyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRlcHJlY2F0ZWRDb25zdHJhaW50cyh2aWRlb0NvbnN0cmFpbnRzOiBNZWRpYVRyYWNrQ29uc3RyYWludHNXaXRoRGVwcmVjYXRlZCk6IE1lZGlhVHJhY2tDb25zdHJhaW50cyB7XHJcbiAgICBjb25zdCBub3JtYWxpemVkID0gcGljayh2aWRlb0NvbnN0cmFpbnRzLCBbJ3dpZHRoJywgJ2hlaWdodCcsICdmYWNpbmdNb2RlJyxcclxuICAgICAgICAnYXNwZWN0UmF0aW8nLCAnZGV2aWNlSWQnXSk7XHJcblxyXG4gICAgaWYgKHR5cGVvZiB2aWRlb0NvbnN0cmFpbnRzLm1pbkFzcGVjdFJhdGlvICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICAgICAgICAmJiB2aWRlb0NvbnN0cmFpbnRzLm1pbkFzcGVjdFJhdGlvID4gMCkge1xyXG4gICAgICAgIG5vcm1hbGl6ZWQuYXNwZWN0UmF0aW8gPSB2aWRlb0NvbnN0cmFpbnRzLm1pbkFzcGVjdFJhdGlvO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdXQVJOSU5HOiBDb25zdHJhaW50IFxcJ21pbkFzcGVjdFJhdGlvXFwnIGlzIGRlcHJlY2F0ZWQ7IFVzZSBcXCdhc3BlY3RSYXRpb1xcJyBpbnN0ZWFkJyk7XHJcbiAgICB9XHJcbiAgICBpZiAodHlwZW9mIHZpZGVvQ29uc3RyYWludHMuZmFjaW5nICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIG5vcm1hbGl6ZWQuZmFjaW5nTW9kZSA9IHZpZGVvQ29uc3RyYWludHMuZmFjaW5nO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdXQVJOSU5HOiBDb25zdHJhaW50IFxcJ2ZhY2luZ1xcJyBpcyBkZXByZWNhdGVkLiBVc2UgXFwnZmFjaW5nTW9kZVxcJyBpbnN0ZWFkXFwnJyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbm9ybWFsaXplZDtcclxufVxyXG5cclxuLy8gVE9ETzogIzE5MiBJIGRvbid0IHRoaW5rIHRoZXJlJ3MgYW55IGdvb2QgcmVhc29uIHBpY2tDb25zdHJhaW50cyBzaG91bGQgcmV0dXJuIGEgUHJvbWlzZSxcclxuLy8gSSB0aGluayBpdCB3YXMganVzdCB0aGF0IHdheSBzbyBpdCBjb3VsZCBiZSBjaGFpbmVkIHRvIG90aGVyIGZ1bmN0aW9ucyB0aGF0IGRpZCByZXR1cm4gYSBQcm9taXNlLlxyXG4vLyBUaGF0J3Mgbm90IG5lY2Vzc2FyeSB3aXRoIGFzeW5jIGZ1bmN0aW9ucyBiZWluZyBhIHRoaW5nLCBzbyB0aGF0IHNob3VsZCBiZSBmaXhlZC5cclxuZXhwb3J0IGZ1bmN0aW9uIHBpY2tDb25zdHJhaW50cyh2aWRlb0NvbnN0cmFpbnRzOiBNZWRpYVRyYWNrQ29uc3RyYWludHNXaXRoRGVwcmVjYXRlZCA9IHt9KTogUHJvbWlzZTxNZWRpYVN0cmVhbUNvbnN0cmFpbnRzPiB7XHJcbiAgICBjb25zdCB2aWRlbyA9IGRlcHJlY2F0ZWRDb25zdHJhaW50cyh2aWRlb0NvbnN0cmFpbnRzKTtcclxuXHJcbiAgICBpZiAodmlkZW8gJiYgdmlkZW8uZGV2aWNlSWQgJiYgdmlkZW8uZmFjaW5nTW9kZSkge1xyXG4gICAgICAgIGRlbGV0ZSB2aWRlby5mYWNpbmdNb2RlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7IGF1ZGlvOiBmYWxzZSwgdmlkZW8gfSk7XHJcbn1cclxuXHJcbmFzeW5jIGZ1bmN0aW9uIGVudW1lcmF0ZVZpZGVvRGV2aWNlcygpOiBQcm9taXNlPEFycmF5PE1lZGlhRGV2aWNlSW5mbz4+IHtcclxuICAgIGNvbnN0IGRldmljZXMgPSBhd2FpdCBlbnVtZXJhdGVEZXZpY2VzKCk7XHJcbiAgICByZXR1cm4gZGV2aWNlcy5maWx0ZXIoKGRldmljZTogTWVkaWFEZXZpY2VJbmZvKSA9PiBkZXZpY2Uua2luZCA9PT0gJ3ZpZGVvaW5wdXQnKTtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0QWN0aXZlVHJhY2soKTogTWVkaWFTdHJlYW1UcmFjayB8IG51bGwge1xyXG4gICAgaWYgKCFzdHJlYW1SZWYpIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIGNvbnN0IHRyYWNrcyA9IHN0cmVhbVJlZi5nZXRWaWRlb1RyYWNrcygpO1xyXG4gICAgcmV0dXJuIHRyYWNrcyAmJiB0cmFja3M/Lmxlbmd0aCA/IHRyYWNrc1swXSA6IG51bGw7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBVc2VkIGZvciBhY2Nlc3NpbmcgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGFjdGl2ZSBzdHJlYW0gdHJhY2sgYW5kIGF2YWlsYWJsZSB2aWRlbyBkZXZpY2VzLlxyXG4gKi9cclxuY29uc3QgUXVhZ2dhSlNDYW1lcmFBY2Nlc3M6IENhbWVyYUFjY2Vzc1R5cGUgPSB7XHJcbiAgICByZXF1ZXN0ZWRWaWRlb0VsZW1lbnQ6IG51bGwsXHJcbiAgICBhc3luYyByZXF1ZXN0KHZpZGVvOiBIVE1MVmlkZW9FbGVtZW50IHwgbnVsbCwgdmlkZW9Db25zdHJhaW50cz86IE1lZGlhVHJhY2tDb25zdHJhaW50c1dpdGhEZXByZWNhdGVkKTogUHJvbWlzZTxhbnk+IHtcclxuICAgICAgICBRdWFnZ2FKU0NhbWVyYUFjY2Vzcy5yZXF1ZXN0ZWRWaWRlb0VsZW1lbnQgPSB2aWRlbztcclxuICAgICAgICBjb25zdCBuZXdDb25zdHJhaW50cyA9IGF3YWl0IHBpY2tDb25zdHJhaW50cyh2aWRlb0NvbnN0cmFpbnRzKTtcclxuICAgICAgICByZXR1cm4gaW5pdENhbWVyYSh2aWRlbywgbmV3Q29uc3RyYWludHMpO1xyXG4gICAgfSxcclxuICAgIHJlbGVhc2UoKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgY29uc3QgdHJhY2tzID0gc3RyZWFtUmVmICYmIHN0cmVhbVJlZi5nZXRWaWRlb1RyYWNrcygpO1xyXG4gICAgICAgIGlmIChRdWFnZ2FKU0NhbWVyYUFjY2Vzcy5yZXF1ZXN0ZWRWaWRlb0VsZW1lbnQgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgUXVhZ2dhSlNDYW1lcmFBY2Nlc3MucmVxdWVzdGVkVmlkZW9FbGVtZW50LnBhdXNlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZTx2b2lkPigocmVzb2x2ZSkgPT4ge1xyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICh0cmFja3MgJiYgdHJhY2tzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRyYWNrc1swXS5zdG9wKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBzdHJlYW1SZWYgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgUXVhZ2dhSlNDYW1lcmFBY2Nlc3MucmVxdWVzdGVkVmlkZW9FbGVtZW50ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICAgICAgfSwgMCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9LFxyXG4gICAgZW51bWVyYXRlVmlkZW9EZXZpY2VzLFxyXG4gICAgZ2V0QWN0aXZlU3RyZWFtTGFiZWwoKTogc3RyaW5nIHtcclxuICAgICAgICBjb25zdCB0cmFjayA9IGdldEFjdGl2ZVRyYWNrKCk7XHJcbiAgICAgICAgcmV0dXJuIHRyYWNrID8gdHJhY2subGFiZWwgOiAnJztcclxuICAgIH0sXHJcbiAgICBnZXRBY3RpdmVUcmFjayxcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IFF1YWdnYUpTQ2FtZXJhQWNjZXNzO1xyXG4iLCJpbXBvcnQgSW1hZ2VEZWJ1ZyBmcm9tICcuLi9jb21tb24vaW1hZ2VfZGVidWcnO1xyXG5pbXBvcnQge1xyXG4gICAgUXVhZ2dhSlNDb2RlUmVzdWx0LFxyXG4gICAgUXVhZ2dhSlNSZXN1bHRDb2xsZWN0b3IsXHJcbiAgICBRdWFnZ2FKU1Jlc3VsdENvbGxlY3RvckZpbHRlckZ1bmN0aW9uLFxyXG4gICAgWFlTaXplLFxyXG4gICAgUXVhZ2dhSW1hZ2VEYXRhLFxyXG59IGZyb20gJy4uLy4uL3R5cGUtZGVmaW5pdGlvbnMvcXVhZ2dhLmQnO1xyXG5cclxuZnVuY3Rpb24gY29udGFpbnMoY29kZVJlc3VsdDogUXVhZ2dhSlNDb2RlUmVzdWx0LCBsaXN0OiBBcnJheTxRdWFnZ2FKU0NvZGVSZXN1bHQ+KTogYm9vbGVhbiB7XHJcbiAgICByZXR1cm4gbGlzdCAmJiBsaXN0LnNvbWUoKGl0ZW0pID0+IHtcclxuICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoaXRlbSkgYXMgQXJyYXk8a2V5b2YgUXVhZ2dhSlNDb2RlUmVzdWx0PjtcclxuICAgICAgICByZXR1cm4ga2V5cy5ldmVyeSgoa2V5KSA9PiBpdGVtW2tleV0gPT09IGNvZGVSZXN1bHRba2V5XSk7XHJcbiAgICB9KTtcclxufVxyXG5cclxuZnVuY3Rpb24gcGFzc2VzRmlsdGVyKFxyXG4gICAgY29kZVJlc3VsdDogUXVhZ2dhSlNDb2RlUmVzdWx0LFxyXG4gICAgZmlsdGVyOiBRdWFnZ2FKU1Jlc3VsdENvbGxlY3RvckZpbHRlckZ1bmN0aW9uIHwgdW5kZWZpbmVkLFxyXG4pOiBib29sZWFuIHtcclxuICAgIHJldHVybiB0eXBlb2YgZmlsdGVyID09PSAnZnVuY3Rpb24nID8gZmlsdGVyKGNvZGVSZXN1bHQpIDogdHJ1ZTtcclxufVxyXG5cclxuaW50ZXJmYWNlIFJlc3VsdENvbGxlY3RvciB7XHJcbiAgICBhZGRSZXN1bHQ6IChkYXRhOiBRdWFnZ2FJbWFnZURhdGEsIGltYWdlU2l6ZTogWFlTaXplLCBjb2RlUmVzdWx0OiBRdWFnZ2FKU0NvZGVSZXN1bHQpID0+IHZvaWQ7XHJcbiAgICBnZXRSZXN1bHRzOiAoKSA9PiBBcnJheTxRdWFnZ2FKU0NvZGVSZXN1bHQ+O1xyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgICBjcmVhdGUoY29uZmlnOiBRdWFnZ2FKU1Jlc3VsdENvbGxlY3Rvcik6IFJlc3VsdENvbGxlY3RvciB7XHJcbiAgICAgICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XHJcbiAgICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJykgYXMgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEO1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdHM6IEFycmF5PFF1YWdnYUpTQ29kZVJlc3VsdD4gPSBbXTtcclxuICAgICAgICBsZXQgY2FwYWNpdHkgPSBjb25maWcuY2FwYWNpdHkgPz8gMjA7XHJcbiAgICAgICAgY29uc3QgY2FwdHVyZSA9IGNvbmZpZy5jYXB0dXJlID09PSB0cnVlO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBtYXRjaGVzQ29uc3RyYWludHMoY29kZVJlc3VsdDogUXVhZ2dhSlNDb2RlUmVzdWx0KTogYm9vbGVhbiB7XHJcbiAgICAgICAgICAgIHJldHVybiAhIWNhcGFjaXR5XHJcbiAgICAgICAgICAgICAgICAmJiBjb2RlUmVzdWx0XHJcbiAgICAgICAgICAgICAgICAmJiAhY29udGFpbnMoY29kZVJlc3VsdCwgY29uZmlnLmJsYWNrbGlzdCBhcyBBcnJheTxRdWFnZ2FKU0NvZGVSZXN1bHQ+KVxyXG4gICAgICAgICAgICAgICAgJiYgcGFzc2VzRmlsdGVyKGNvZGVSZXN1bHQsIGNvbmZpZy5maWx0ZXIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgYWRkUmVzdWx0KGRhdGE6IFF1YWdnYUltYWdlRGF0YSwgaW1hZ2VTaXplOiBYWVNpemUsIGNvZGVSZXN1bHQ6IFF1YWdnYUpTQ29kZVJlc3VsdCk6IHZvaWQge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0OiBhbnkgPSB7IH07IC8vIHRoaXMgaXMgJ2FueScgdG8gYXZvaWQgaGF2aW5nIHRvIGNvbnN0cnVjdCBhIHdob2xlIFF1YWdnYUpTQ29kZVJlc3VsdCA6fFxyXG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoZXNDb25zdHJhaW50cyhjb2RlUmVzdWx0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhcGFjaXR5LS07XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmNvZGVSZXN1bHQgPSBjb2RlUmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjYXB0dXJlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IGltYWdlU2l6ZS54O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gaW1hZ2VTaXplLnk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIEltYWdlRGVidWcuZHJhd0ltYWdlKGRhdGEsIGltYWdlU2l6ZSwgY3R4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmZyYW1lID0gY2FudmFzLnRvRGF0YVVSTCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2gocmVzdWx0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZ2V0UmVzdWx0cygpOiBBcnJheTxRdWFnZ2FKU0NvZGVSZXN1bHQ+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH07XHJcbiAgICB9LFxyXG59O1xyXG4iLCJpbXBvcnQgeyBRdWFnZ2FKU0NvbmZpZ09iamVjdCB9IGZyb20gJy4uLy4uL3R5cGUtZGVmaW5pdGlvbnMvcXVhZ2dhLmQnO1xyXG5cclxuY29uc3QgRGV2Q29uZmlnOiBRdWFnZ2FKU0NvbmZpZ09iamVjdCA9IHtcclxuICAgIGlucHV0U3RyZWFtOiB7XHJcbiAgICAgICAgbmFtZTogJ0xpdmUnLFxyXG4gICAgICAgIHR5cGU6ICdMaXZlU3RyZWFtJyxcclxuICAgICAgICBjb25zdHJhaW50czoge1xyXG4gICAgICAgICAgICB3aWR0aDogNjQwLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IDQ4MCxcclxuICAgICAgICAgICAgLy8gYXNwZWN0UmF0aW86IDY0MC80ODAsIC8vIG9wdGlvbmFsXHJcbiAgICAgICAgICAgIGZhY2luZ01vZGU6ICdlbnZpcm9ubWVudCcsIC8vIG9yIHVzZXJcclxuICAgICAgICAgICAgLy8gZGV2aWNlSWQ6IFwiMzg3NDU5ODM0NTczODc1OTgzNzU5ODM3NTk4MzRcIlxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYXJlYToge1xyXG4gICAgICAgICAgICB0b3A6ICcwJScsXHJcbiAgICAgICAgICAgIHJpZ2h0OiAnMCUnLFxyXG4gICAgICAgICAgICBsZWZ0OiAnMCUnLFxyXG4gICAgICAgICAgICBib3R0b206ICcwJScsXHJcbiAgICAgICAgfSxcclxuICAgICAgICBzaW5nbGVDaGFubmVsOiBmYWxzZSwgLy8gdHJ1ZTogb25seSB0aGUgcmVkIGNvbG9yLWNoYW5uZWwgaXMgcmVhZFxyXG4gICAgfSxcclxuICAgIGxvY2F0ZTogdHJ1ZSxcclxuICAgIG51bU9mV29ya2VyczogMCxcclxuICAgIGRlY29kZXI6IHtcclxuICAgICAgICByZWFkZXJzOiBbXHJcbiAgICAgICAgICAgICdjb2RlXzEyOF9yZWFkZXInLFxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgZGVidWc6IHtcclxuICAgICAgICAgICAgZHJhd0JvdW5kaW5nQm94OiBmYWxzZSxcclxuICAgICAgICAgICAgc2hvd0ZyZXF1ZW5jeTogZmFsc2UsXHJcbiAgICAgICAgICAgIGRyYXdTY2FubGluZTogZmFsc2UsXHJcbiAgICAgICAgICAgIHNob3dQYXR0ZXJuOiBmYWxzZSxcclxuICAgICAgICB9LFxyXG4gICAgfSxcclxuICAgIGxvY2F0b3I6IHtcclxuICAgICAgICBoYWxmU2FtcGxlOiB0cnVlLFxyXG4gICAgICAgIHBhdGNoU2l6ZTogJ21lZGl1bScsIC8vIHgtc21hbGwsIHNtYWxsLCBtZWRpdW0sIGxhcmdlLCB4LWxhcmdlXHJcbiAgICAgICAgZGVidWc6IHtcclxuICAgICAgICAgICAgc2hvd0NhbnZhczogZmFsc2UsXHJcbiAgICAgICAgICAgIHNob3dQYXRjaGVzOiBmYWxzZSxcclxuICAgICAgICAgICAgc2hvd0ZvdW5kUGF0Y2hlczogZmFsc2UsXHJcbiAgICAgICAgICAgIHNob3dTa2VsZXRvbjogZmFsc2UsXHJcbiAgICAgICAgICAgIHNob3dMYWJlbHM6IGZhbHNlLFxyXG4gICAgICAgICAgICBzaG93UGF0Y2hMYWJlbHM6IGZhbHNlLFxyXG4gICAgICAgICAgICBzaG93UmVtYWluaW5nUGF0Y2hMYWJlbHM6IGZhbHNlLFxyXG4gICAgICAgICAgICBib3hGcm9tUGF0Y2hlczoge1xyXG4gICAgICAgICAgICAgICAgc2hvd1RyYW5zZm9ybWVkOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIHNob3dUcmFuc2Zvcm1lZEJveDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBzaG93QkI6IGZhbHNlLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH0sXHJcbiAgICB9LFxyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgRGV2Q29uZmlnO1xyXG4iLCJpbXBvcnQgeyBRdWFnZ2FKU0NvbmZpZ09iamVjdCB9IGZyb20gJy4uLy4uL3R5cGUtZGVmaW5pdGlvbnMvcXVhZ2dhLmQnO1xyXG5cclxuY29uc3QgTm9kZUNvbmZpZzogUXVhZ2dhSlNDb25maWdPYmplY3QgPSB7XHJcbiAgICBpbnB1dFN0cmVhbToge1xyXG4gICAgICAgIHR5cGU6ICdJbWFnZVN0cmVhbScsXHJcbiAgICAgICAgc2VxdWVuY2U6IGZhbHNlLFxyXG4gICAgICAgIHNpemU6IDgwMCxcclxuICAgICAgICBhcmVhOiB7XHJcbiAgICAgICAgICAgIHRvcDogJzAlJyxcclxuICAgICAgICAgICAgcmlnaHQ6ICcwJScsXHJcbiAgICAgICAgICAgIGxlZnQ6ICcwJScsXHJcbiAgICAgICAgICAgIGJvdHRvbTogJzAlJyxcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNpbmdsZUNoYW5uZWw6IGZhbHNlLCAvLyB0cnVlOiBvbmx5IHRoZSByZWQgY29sb3ItY2hhbm5lbCBpcyByZWFkXHJcbiAgICB9LFxyXG4gICAgbG9jYXRlOiB0cnVlLFxyXG4gICAgbnVtT2ZXb3JrZXJzOiAwLFxyXG4gICAgZGVjb2Rlcjoge1xyXG4gICAgICAgIHJlYWRlcnM6IFtcclxuICAgICAgICAgICAgJ2NvZGVfMTI4X3JlYWRlcicsXHJcbiAgICAgICAgXSxcclxuICAgIH0sXHJcbiAgICBsb2NhdG9yOiB7XHJcbiAgICAgICAgaGFsZlNhbXBsZTogdHJ1ZSxcclxuICAgICAgICBwYXRjaFNpemU6ICdtZWRpdW0nLCAvLyB4LXNtYWxsLCBzbWFsbCwgbWVkaXVtLCBsYXJnZSwgeC1sYXJnZVxyXG4gICAgfSxcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IE5vZGVDb25maWc7XHJcbiIsImltcG9ydCB7IFF1YWdnYUpTQ29uZmlnT2JqZWN0IH0gZnJvbSAnLi4vLi4vdHlwZS1kZWZpbml0aW9ucy9xdWFnZ2EuZCc7XHJcblxyXG5jb25zdCBQcm9kQ29uZmlnOiBRdWFnZ2FKU0NvbmZpZ09iamVjdCA9IHtcclxuICAgIGlucHV0U3RyZWFtOiB7XHJcbiAgICAgICAgbmFtZTogJ0xpdmUnLFxyXG4gICAgICAgIHR5cGU6ICdMaXZlU3RyZWFtJyxcclxuICAgICAgICBjb25zdHJhaW50czoge1xyXG4gICAgICAgICAgICB3aWR0aDogNjQwLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IDQ4MCxcclxuICAgICAgICAgICAgLy8gYXNwZWN0UmF0aW86IDY0MC80ODAsIC8vIG9wdGlvbmFsXHJcbiAgICAgICAgICAgIGZhY2luZ01vZGU6ICdlbnZpcm9ubWVudCcsIC8vIG9yIHVzZXJcclxuICAgICAgICAgICAgLy8gZGV2aWNlSWQ6IFwiMzg3NDU5ODM0NTczODc1OTgzNzU5ODM3NTk4MzRcIlxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYXJlYToge1xyXG4gICAgICAgICAgICB0b3A6ICcwJScsXHJcbiAgICAgICAgICAgIHJpZ2h0OiAnMCUnLFxyXG4gICAgICAgICAgICBsZWZ0OiAnMCUnLFxyXG4gICAgICAgICAgICBib3R0b206ICcwJScsXHJcbiAgICAgICAgfSxcclxuICAgICAgICBzaW5nbGVDaGFubmVsOiBmYWxzZSwgLy8gdHJ1ZTogb25seSB0aGUgcmVkIGNvbG9yLWNoYW5uZWwgaXMgcmVhZFxyXG4gICAgfSxcclxuICAgIGxvY2F0ZTogdHJ1ZSxcclxuICAgIG51bU9mV29ya2VyczogNCxcclxuICAgIGRlY29kZXI6IHtcclxuICAgICAgICByZWFkZXJzOiBbXHJcbiAgICAgICAgICAgICdjb2RlXzEyOF9yZWFkZXInLFxyXG4gICAgICAgIF0sXHJcbiAgICB9LFxyXG4gICAgbG9jYXRvcjoge1xyXG4gICAgICAgIGhhbGZTYW1wbGU6IHRydWUsXHJcbiAgICAgICAgcGF0Y2hTaXplOiAnbWVkaXVtJywgLy8geC1zbWFsbCwgc21hbGwsIG1lZGl1bSwgbGFyZ2UsIHgtbGFyZ2VcclxuICAgIH0sXHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBQcm9kQ29uZmlnO1xyXG4iLCJpbXBvcnQgeyBRdWFnZ2FKU0NvbmZpZ09iamVjdCB9IGZyb20gJy4uLy4uL3R5cGUtZGVmaW5pdGlvbnMvcXVhZ2dhLmQnO1xyXG5pbXBvcnQgRGV2Q29uZmlnIGZyb20gJy4vY29uZmlnLmRldic7XHJcbmltcG9ydCBOb2RlQ29uZmlnIGZyb20gJy4vY29uZmlnLm5vZGUnO1xyXG5pbXBvcnQgUHJvZENvbmZpZyBmcm9tICcuL2NvbmZpZy5wcm9kJztcclxuXHJcbi8vIEB0cy1pZ25vcmUgLy8gVE9ETzogdGhpcyBwcm9kdWNlcyBhIGJpemFycmUgdHlwZXNjcmlwdCBlcnJvclxyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmVzdGVkLXRlcm5hcnlcclxuY29uc3QgUXVhZ2dhQ29uZmlnOiBRdWFnZ2FKU0NvbmZpZ09iamVjdCA9IEVOVi5kZXZlbG9wbWVudFxyXG4gICAgPyBEZXZDb25maWdcclxuICAgIDogRU5WLm5vZGVcclxuICAgICAgICA/IE5vZGVDb25maWdcclxuICAgICAgICA6IFByb2RDb25maWc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBRdWFnZ2FDb25maWc7XHJcbiIsImltcG9ydCB7IFF1YWdnYUpTQ29uZmlnT2JqZWN0IH0gZnJvbSBcIi4uL3R5cGUtZGVmaW5pdGlvbnMvcXVhZ2dhXCI7XHJcbmltcG9ydCBJbWFnZVdyYXBwZXIgZnJvbSBcImNvbW1vbi9pbWFnZV93cmFwcGVyXCI7XHJcblxyXG5leHBvcnQgY2xhc3MgUXVhZ2dhQ29udGV4dCB7XHJcbiAgICBwdWJsaWMgY29uZmlnPzogUXVhZ2dhSlNDb25maWdPYmplY3Q7XHJcblxyXG4gICAgcHVibGljIGlucHV0U3RyZWFtOiBhbnk7XHJcblxyXG4gICAgcHVibGljIGZyYW1lZ3JhYmJlcjogYW55O1xyXG5cclxuICAgIHB1YmxpYyBpbnB1dEltYWdlV3JhcHBlcj86IEltYWdlV3JhcHBlcjtcclxuXHJcbiAgICBwdWJsaWMgc3RvcHBlZDogYm9vbGVhbiA9IGZhbHNlO1xyXG5cclxuICAgIHB1YmxpYyBib3hTaXplOiBhbnk7XHJcblxyXG4gICAgcHVibGljIHJlc3VsdENvbGxlY3RvcjogYW55O1xyXG5cclxuICAgIHB1YmxpYyBkZWNvZGVyOiBhbnk7XHJcblxyXG4gICAgcHVibGljIHdvcmtlclBvb2w6IGFueVtdID0gW107XHJcblxyXG4gICAgcHVibGljIG9uVUlUaHJlYWQgPSB0cnVlO1xyXG5cclxuICAgIHB1YmxpYyByZWFkb25seSBjYW52YXNDb250YWluZXIgPSBuZXcgQ2FudmFzQ29udGFpbmVyKCk7XHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBDYW52YXNJbmZvIHtcclxuICAgIGltYWdlOiBhbnk7XHJcbiAgICBvdmVybGF5OiBhbnk7XHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBDYW52YXNDb250YWluZXIge1xyXG4gICAgcHVibGljIHJlYWRvbmx5IGN0eDogQ2FudmFzSW5mbztcclxuICAgIHB1YmxpYyByZWFkb25seSBkb206IENhbnZhc0luZm87XHJcblxyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5jdHggPSBuZXcgQ2FudmFzSW5mbygpO1xyXG4gICAgICAgIHRoaXMuZG9tID0gbmV3IENhbnZhc0luZm8oKTtcclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgeyBjbG9uZSB9IGZyb20gJ2dsLXZlYzInO1xyXG5pbXBvcnQgdHlwZSB7IElucHV0U3RyZWFtIH0gZnJvbSAnLi4vaW5wdXQvaW5wdXRfc3RyZWFtL2lucHV0X3N0cmVhbS5kJztcclxuaW1wb3J0IEltYWdlV3JhcHBlciBmcm9tICcuLi9jb21tb24vaW1hZ2Vfd3JhcHBlcic7XHJcbmltcG9ydCBCYXJjb2RlTG9jYXRvciBmcm9tICcuLi9sb2NhdG9yL2JhcmNvZGVfbG9jYXRvcic7XHJcblxyXG50eXBlIEJ1ZmZlclJldHVybiA9IHtcclxuICAgIGlucHV0SW1hZ2VXcmFwcGVyOiBJbWFnZVdyYXBwZXI7XHJcbiAgICAvLyBib3hTaXplIHNob3VsZCBiZSBsaWtlIFtbIG51bWJlciwgbnVtYmVyXSwgLi4uXSBidXQgY2xvbmUncyBzaWduYXR1cmUgZG9lc24ndCBzZWVtIHRvIGFsbG93IHRoYXRcclxuICAgIGJveFNpemU6IEFycmF5PEFycmF5PG51bWJlcj4+O1xyXG59O1xyXG5cclxuLy8gVE9ETzogbmVlZCB0eXBlc2NyaXB0IGRlZiBmb3IgQmFyY29kZUxvY2F0b3JcclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaW5pdEJ1ZmZlcnMoXHJcbiAgICBpbnB1dFN0cmVhbTogSW5wdXRTdHJlYW0sXHJcbiAgICBpbWFnZVdyYXBwZXI6IEltYWdlV3JhcHBlciB8IHVuZGVmaW5lZCxcclxuICAgIGxvY2F0b3I6IGFueSxcclxuKTogQnVmZmVyUmV0dXJuIHtcclxuICAgIGNvbnN0IGlucHV0SW1hZ2VXcmFwcGVyID0gaW1hZ2VXcmFwcGVyIHx8IG5ldyBJbWFnZVdyYXBwZXIoe1xyXG4gICAgICAgIHg6IGlucHV0U3RyZWFtLmdldFdpZHRoKCksXHJcbiAgICAgICAgeTogaW5wdXRTdHJlYW0uZ2V0SGVpZ2h0KCksXHJcbiAgICAgICAgdHlwZTogJ1hZU2l6ZScsXHJcbiAgICB9KTtcclxuXHJcbiAgICBpZiAoRU5WLmRldmVsb3BtZW50KSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coYGltYWdlIHdyYXBwZXIgc2l6ZSAke2lucHV0SW1hZ2VXcmFwcGVyLnNpemV9YCk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBib3hTaXplID0gW1xyXG4gICAgICAgIGNsb25lKFswLCAwXSksXHJcbiAgICAgICAgY2xvbmUoWzAsIGlucHV0SW1hZ2VXcmFwcGVyLnNpemUueV0pLFxyXG4gICAgICAgIGNsb25lKFtpbnB1dEltYWdlV3JhcHBlci5zaXplLngsIGlucHV0SW1hZ2VXcmFwcGVyLnNpemUueV0pLFxyXG4gICAgICAgIGNsb25lKFtpbnB1dEltYWdlV3JhcHBlci5zaXplLngsIDBdKSxcclxuICAgIF07XHJcbiAgICBCYXJjb2RlTG9jYXRvci5pbml0KGlucHV0SW1hZ2VXcmFwcGVyLCBsb2NhdG9yKTtcclxuICAgIHJldHVybiB7IGlucHV0SW1hZ2VXcmFwcGVyLCBib3hTaXplIH07XHJcbn1cclxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0Vmlld1BvcnQodGFyZ2V0PzogRWxlbWVudCB8IHN0cmluZyk6IEVsZW1lbnQgfCBudWxsIHtcclxuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ2hlY2sgaWYgdGFyZ2V0IGlzIGFscmVhZHkgYSBET00gZWxlbWVudFxyXG4gICAgaWYgKHRhcmdldCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50ICYmIHRhcmdldC5ub2RlTmFtZSAmJiB0YXJnZXQubm9kZVR5cGUgPT09IDEpIHtcclxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xyXG4gICAgfVxyXG4gICAgLy8gVXNlICcjaW50ZXJhY3RpdmUudmlld3BvcnQnIGFzIGEgZmFsbGJhY2sgc2VsZWN0b3IgKGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5KVxyXG4gICAgY29uc3Qgc2VsZWN0b3IgPSB0eXBlb2YgdGFyZ2V0ID09PSAnc3RyaW5nJyA/IHRhcmdldCA6ICcjaW50ZXJhY3RpdmUudmlld3BvcnQnO1xyXG4gICAgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpO1xyXG59XHJcbiIsImltcG9ydCB7IFF1YWdnYUNvbnRleHQsIENhbnZhc0NvbnRhaW5lciB9IGZyb20gJ1F1YWdnYUNvbnRleHQnO1xyXG5pbXBvcnQgeyBYWVNpemUgfSBmcm9tICcuLi8uLi90eXBlLWRlZmluaXRpb25zL3F1YWdnYS5kJztcclxuaW1wb3J0IGdldFZpZXdQb3J0IGZyb20gJy4vZ2V0Vmlld1BvcnQnO1xyXG5cclxuZnVuY3Rpb24gZmluZE9yQ3JlYXRlQ2FudmFzKHNlbGVjdG9yOiBzdHJpbmcsIGNsYXNzTmFtZTogc3RyaW5nKSB7XHJcbiAgICBsZXQgY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCB8IG51bGwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTtcclxuICAgIGlmICghY2FudmFzKSB7XHJcbiAgICAgICAgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XHJcbiAgICAgICAgY2FudmFzLmNsYXNzTmFtZSA9IGNsYXNzTmFtZTtcclxuICAgIH1cclxuICAgIHJldHVybiBjYW52YXM7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldENhbnZhc0FuZENvbnRleHQoc2VsZWN0b3I6IHN0cmluZywgY2xhc3NOYW1lOiBzdHJpbmcpIHtcclxuICAgIGNvbnN0IGNhbnZhcyA9IGZpbmRPckNyZWF0ZUNhbnZhcyhzZWxlY3RvciwgY2xhc3NOYW1lKTtcclxuICAgIGNvbnN0IGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcclxuICAgIHJldHVybiB7IGNhbnZhcywgY29udGV4dCB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBpbml0Q2FudmFzZXMoY2FudmFzU2l6ZTogWFlTaXplKTogQ2FudmFzQ29udGFpbmVyIHwgbnVsbCB7XHJcbiAgICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIGNvbnN0IGltYWdlID0gZ2V0Q2FudmFzQW5kQ29udGV4dCgnY2FudmFzLmltZ0J1ZmZlcicsICdpbWdCdWZmZXInKTtcclxuICAgICAgICBjb25zdCBvdmVybGF5ID0gZ2V0Q2FudmFzQW5kQ29udGV4dCgnY2FudmFzLmRyYXdpbmdCdWZmZXInLCAnZHJhd2luZ0J1ZmZlcicpO1xyXG5cclxuICAgICAgICBpbWFnZS5jYW52YXMud2lkdGggPSBvdmVybGF5LmNhbnZhcy53aWR0aCA9IGNhbnZhc1NpemUueDtcclxuICAgICAgICBpbWFnZS5jYW52YXMuaGVpZ2h0ID0gb3ZlcmxheS5jYW52YXMuaGVpZ2h0ID0gY2FudmFzU2l6ZS55O1xyXG5cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBkb206IHtcclxuICAgICAgICAgICAgICAgIGltYWdlOiBpbWFnZS5jYW52YXMsXHJcbiAgICAgICAgICAgICAgICBvdmVybGF5OiBvdmVybGF5LmNhbnZhcyxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgY3R4OiB7XHJcbiAgICAgICAgICAgICAgICBpbWFnZTogaW1hZ2UuY29udGV4dCxcclxuICAgICAgICAgICAgICAgIG92ZXJsYXk6IG92ZXJsYXkuY29udGV4dCxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGluaXRDYW52YXMoY29udGV4dDogUXVhZ2dhQ29udGV4dCk6IENhbnZhc0NvbnRhaW5lciB8IG51bGwge1xyXG4gICAgY29uc3Qgdmlld3BvcnQgPSBnZXRWaWV3UG9ydChjb250ZXh0Py5jb25maWc/LmlucHV0U3RyZWFtPy50YXJnZXQpO1xyXG4gICAgY29uc3QgdHlwZSA9IGNvbnRleHQ/LmNvbmZpZz8uaW5wdXRTdHJlYW0/LnR5cGU7XHJcbiAgICBpZiAoIXR5cGUpIHJldHVybiBudWxsO1xyXG4gICAgY29uc3QgY29udGFpbmVyID0gaW5pdENhbnZhc2VzKGNvbnRleHQuaW5wdXRTdHJlYW0uZ2V0Q2FudmFzU2l6ZSgpKTtcclxuICAgIGlmICghY29udGFpbmVyKSByZXR1cm4geyBkb206IHsgaW1hZ2U6IG51bGwsIG92ZXJsYXk6IG51bGwgfSwgY3R4OiB7IGltYWdlOiBudWxsLCBvdmVybGF5OiBudWxsIH0gfTtcclxuXHJcbiAgICBjb25zdCB7IGRvbSB9ID0gY29udGFpbmVyO1xyXG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICBpZiAodmlld3BvcnQpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdJbWFnZVN0cmVhbScgJiYgIXZpZXdwb3J0LmNvbnRhaW5zKGRvbS5pbWFnZSkpIHtcclxuICAgICAgICAgICAgICAgIHZpZXdwb3J0LmFwcGVuZENoaWxkKGRvbS5pbWFnZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCF2aWV3cG9ydC5jb250YWlucyhkb20ub3ZlcmxheSkpIHtcclxuICAgICAgICAgICAgICAgIHZpZXdwb3J0LmFwcGVuZENoaWxkKGRvbS5vdmVybGF5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBjb250YWluZXI7XHJcbn1cclxuIiwiLy8gVE9ETzogSXQncyBwcmV0dHkgbGlrZWx5IHRoYXQgdGhpcyBzaGFyZXMgY29kZSB3aXRoIHRoZSBicm93c2VyIHZlcnNpb24sIGludmVzdGlnYXRlIHRoYXRcclxuLy8gRk9SIEFOWU9ORSBJTiBIRVJFIElOIFRIRSBGVVRVUkU6IFRoaXMgaXMgdGhlIGRlZmF1bHQgaW5wdXRfc3RyZWFtIG1vZHVsZSB1c2VkIGZvciB0aGUgTm9kZSBidW5kbGUuXHJcbi8vIHdlYnBhY2suY29uZmlnLmpzICpyZXBsYWNlcyogdGhpcyB3aXRoIGlucHV0X3N0cmVhbV9icm93c2VyLnRzIHdoZW4gdGhlIGJ1bmRsZSBpcyBiZWluZyBidWlsdCBmb3IgYnJvd3Nlci5cclxuXHJcbmltcG9ydCBHZXRQaXhlbHMgZnJvbSAnZ2V0LXBpeGVscyc7XHJcbmltcG9ydCB7IElucHV0U3RyZWFtRmFjdG9yeSwgSW5wdXRTdHJlYW0sIEV2ZW50SGFuZGxlckxpc3QgfSBmcm9tICcuL2lucHV0X3N0cmVhbS5kJztcclxuaW1wb3J0IHsgUG9pbnQsIFhZU2l6ZSB9IGZyb20gJy4uLy4uLy4uL3R5cGUtZGVmaW5pdGlvbnMvcXVhZ2dhLmQnO1xyXG5cclxuY29uc3QgaW5wdXRTdHJlYW1GYWN0b3J5OiBJbnB1dFN0cmVhbUZhY3RvcnkgPSB7XHJcbiAgICBjcmVhdGVWaWRlb1N0cmVhbSgpOiBuZXZlciB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjcmVhdGVWaWRlb1N0cmVhbSBub3QgYXZhaWxhYmxlJyk7XHJcbiAgICB9LFxyXG4gICAgY3JlYXRlTGl2ZVN0cmVhbSgpOiBuZXZlciB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjcmVhdGVMaXZlU3RyZWFtIG5vdCBhdmFpbGFibGUnKTtcclxuICAgIH0sXHJcbiAgICBjcmVhdGVJbWFnZVN0cmVhbSgpOiBJbnB1dFN0cmVhbSB7XHJcbiAgICAgICAgbGV0IF9jb25maWc6IHsgbWltZTogc3RyaW5nOyBzaXplOiBudW1iZXI7IHNyYzogYW55IH0gfCBudWxsID0gbnVsbDtcclxuXHJcbiAgICAgICAgbGV0IHdpZHRoID0gMDtcclxuICAgICAgICBsZXQgaGVpZ2h0ID0gMDtcclxuICAgICAgICBsZXQgbG9hZGVkID0gZmFsc2U7XHJcbiAgICAgICAgLy8gVE9ETzogZnJhbWUgc2hvdWxkIGJlIGEgdHlwZSBOZEFycmF5LCBidXQgTmRBcnJheSBkb2Vzbid0IGhhdmUgdHMgZGVmaW5pdGlvbnNcclxuICAgICAgICAvLyBUT0RPOiB0aGVyZSBpcyBhIHRzLW5kYXJyYXkgdGhhdCBtaWdodCB3b3JrLCB0aG91Z2hcclxuICAgICAgICBsZXQgZnJhbWU6IGFueSA9IG51bGw7XHJcbiAgICAgICAgbGV0IGJhc2VVcmw6IHN0cmluZztcclxuICAgICAgICBjb25zdCBlbmRlZCA9IGZhbHNlO1xyXG4gICAgICAgIGxldCBjYWxjdWxhdGVkV2lkdGg6IG51bWJlcjtcclxuICAgICAgICBsZXQgY2FsY3VsYXRlZEhlaWdodDogbnVtYmVyO1xyXG4gICAgICAgIGNvbnN0IF9ldmVudE5hbWVzID0gWydjYW5yZWNvcmQnLCAnZW5kZWQnXTtcclxuICAgICAgICBjb25zdCBfZXZlbnRIYW5kbGVyczogRXZlbnRIYW5kbGVyTGlzdCA9IHt9O1xyXG4gICAgICAgIGNvbnN0IF90b3BSaWdodDogUG9pbnQgPSB7IHg6IDAsIHk6IDAsIHR5cGU6ICdQb2ludCcgfTtcclxuICAgICAgICBjb25zdCBfY2FudmFzU2l6ZTogWFlTaXplID0geyB4OiAwLCB5OiAwLCB0eXBlOiAnWFlTaXplJyB9O1xyXG4gICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovIC8vIGZhbHNlIGVzbGludCBlcnJvcnM/IHdlaXJkLlxyXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcclxuICAgICAgICBsZXQgc2l6ZSA9IDA7XHJcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxyXG4gICAgICAgIGxldCBmcmFtZUlkeCA9IDA7XHJcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxyXG4gICAgICAgIGxldCBwYXVzZWQgPSBmYWxzZTtcclxuICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC12YXJzICovXHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGxvYWRJbWFnZXMoKTogdm9pZCB7XHJcbiAgICAgICAgICAgIGxvYWRlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuZXctY2FwICovXHJcbiAgICAgICAgICAgIEdldFBpeGVscyhiYXNlVXJsLCBfY29uZmlnPy5taW1lLCAoZXJyLCBwaXhlbHMpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCcqKioqIHF1YWdnYSBsb2FkSW1hZ2VzIGVycm9yOicsIGVycik7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdlcnJvciBkZWNvZGluZyBwaXhlbHMgaW4gbG9hZEltYWdlcycpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbG9hZGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnKiBJbnB1dFN0cmVhbU5vZGUgcGl4ZWxzLnNoYXBlJywgcGl4ZWxzLnNoYXBlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnRcclxuICAgICAgICAgICAgICAgIGZyYW1lID0gcGl4ZWxzO1xyXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudCxAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLW1lbWJlci1hY2Nlc3NcclxuICAgICAgICAgICAgICAgIFt3aWR0aCwgaGVpZ2h0XSA9IHBpeGVscy5zaGFwZTtcclxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXN0ZWQtdGVybmFyeVxyXG4gICAgICAgICAgICAgICAgY2FsY3VsYXRlZFdpZHRoID0gX2NvbmZpZz8uc2l6ZVxyXG4gICAgICAgICAgICAgICAgICAgID8gd2lkdGggLyBoZWlnaHQgPiAxXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gX2NvbmZpZy5zaXplXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogTWF0aC5mbG9vcigod2lkdGggLyBoZWlnaHQpICogX2NvbmZpZy5zaXplKVxyXG4gICAgICAgICAgICAgICAgICAgIDogd2lkdGg7XHJcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmVzdGVkLXRlcm5hcnlcclxuICAgICAgICAgICAgICAgIGNhbGN1bGF0ZWRIZWlnaHQgPSBfY29uZmlnPy5zaXplXHJcbiAgICAgICAgICAgICAgICAgICAgPyB3aWR0aCAvIGhlaWdodCA+IDFcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyBNYXRoLmZsb29yKChoZWlnaHQgLyB3aWR0aCkgKiBfY29uZmlnLnNpemUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogX2NvbmZpZy5zaXplXHJcbiAgICAgICAgICAgICAgICAgICAgOiBoZWlnaHQ7XHJcblxyXG4gICAgICAgICAgICAgICAgX2NhbnZhc1NpemUueCA9IGNhbGN1bGF0ZWRXaWR0aDtcclxuICAgICAgICAgICAgICAgIF9jYW52YXNTaXplLnkgPSBjYWxjdWxhdGVkSGVpZ2h0O1xyXG5cclxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdXNlLWJlZm9yZS1kZWZpbmVcclxuICAgICAgICAgICAgICAgICAgICBwdWJsaXNoRXZlbnQoJ2NhbnJlY29yZCcsIFtdKTtcclxuICAgICAgICAgICAgICAgIH0sIDApO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHB1Ymxpc2hFdmVudChldmVudE5hbWU6IHN0cmluZywgYXJnczogQXJyYXk8YW55Pik6IHZvaWQge1xyXG4gICAgICAgICAgICBjb25zdCBoYW5kbGVycyA9IF9ldmVudEhhbmRsZXJzW2V2ZW50TmFtZV07XHJcblxyXG4gICAgICAgICAgICBpZiAoaGFuZGxlcnMgJiYgaGFuZGxlcnMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBoYW5kbGVycy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdXNlLWJlZm9yZS1kZWZpbmVcclxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVyc1tqXS5hcHBseShpbnB1dFN0cmVhbSwgYXJncyBhcyBhbnkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdmFyLHZhcnMtb24tdG9wXHJcbiAgICAgICAgdmFyIGlucHV0U3RyZWFtOiBJbnB1dFN0cmVhbSA9IHtcclxuICAgICAgICAgICAgdHJpZ2dlcjogcHVibGlzaEV2ZW50LFxyXG5cclxuICAgICAgICAgICAgZ2V0V2lkdGgoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsY3VsYXRlZFdpZHRoO1xyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgZ2V0SGVpZ2h0KCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGN1bGF0ZWRIZWlnaHQ7XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICBzZXRXaWR0aCh3KSB7XHJcbiAgICAgICAgICAgICAgICBjYWxjdWxhdGVkV2lkdGggPSB3O1xyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgc2V0SGVpZ2h0KGgpIHtcclxuICAgICAgICAgICAgICAgIGNhbGN1bGF0ZWRIZWlnaHQgPSBoO1xyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgZ2V0UmVhbFdpZHRoKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHdpZHRoO1xyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgZ2V0UmVhbEhlaWdodCgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBoZWlnaHQ7XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICBzZXRJbnB1dFN0cmVhbShzdHJlYW0pIHtcclxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnRcclxuICAgICAgICAgICAgICAgIF9jb25maWcgPSBzdHJlYW07XHJcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hc3NpZ25tZW50LEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2Vzc1xyXG4gICAgICAgICAgICAgICAgYmFzZVVybCA9IF9jb25maWc/LnNyYztcclxuICAgICAgICAgICAgICAgIHNpemUgPSAxO1xyXG4gICAgICAgICAgICAgICAgbG9hZEltYWdlcygpO1xyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgZW5kZWQoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZW5kZWQ7XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICBzZXRBdHRyaWJ1dGUoKSB7fSxcclxuXHJcbiAgICAgICAgICAgIGdldENvbmZpZygpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfY29uZmlnO1xyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgcGF1c2UoKSB7XHJcbiAgICAgICAgICAgICAgICBwYXVzZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgcGxheSgpIHtcclxuICAgICAgICAgICAgICAgIHBhdXNlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgc2V0Q3VycmVudFRpbWUodGltZSkge1xyXG4gICAgICAgICAgICAgICAgZnJhbWVJZHggPSB0aW1lO1xyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgZikge1xyXG4gICAgICAgICAgICAgICAgaWYgKF9ldmVudE5hbWVzLmluZGV4T2YoZXZlbnQpICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghX2V2ZW50SGFuZGxlcnNbZXZlbnRdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9ldmVudEhhbmRsZXJzW2V2ZW50XSA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBfZXZlbnRIYW5kbGVyc1tldmVudF0ucHVzaChmKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIGNsZWFyRXZlbnRIYW5kbGVycygpIHtcclxuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKF9ldmVudEhhbmRsZXJzKS5mb3JFYWNoKChpbmQpID0+IGRlbGV0ZSBfZXZlbnRIYW5kbGVyc1tpbmRdKTtcclxuICAgICAgICAgICAgfSxcclxuXHJcblxyXG4gICAgICAgICAgICBzZXRUb3BSaWdodCh0b3BSaWdodCkge1xyXG4gICAgICAgICAgICAgICAgX3RvcFJpZ2h0LnggPSB0b3BSaWdodC54O1xyXG4gICAgICAgICAgICAgICAgX3RvcFJpZ2h0LnkgPSB0b3BSaWdodC55O1xyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgZ2V0VG9wUmlnaHQoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RvcFJpZ2h0O1xyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgc2V0Q2FudmFzU2l6ZShzeikge1xyXG4gICAgICAgICAgICAgICAgX2NhbnZhc1NpemUueCA9IHN6Lng7XHJcbiAgICAgICAgICAgICAgICBfY2FudmFzU2l6ZS55ID0gc3oueTtcclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIGdldENhbnZhc1NpemUoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NhbnZhc1NpemU7XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICBnZXRGcmFtZSgpIHtcclxuICAgICAgICAgICAgICAgIGlmICghbG9hZGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1yZXR1cm5cclxuICAgICAgICAgICAgICAgIHJldHVybiBmcmFtZTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBpbnB1dFN0cmVhbTtcclxuICAgIH0sXHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBpbnB1dFN0cmVhbUZhY3Rvcnk7XHJcbiIsIi8qIFdvcmtlciBmdW5jdGlvbnMuIFRoZXNlIGFyZSBzdHJhaWdodCBmcm9tIHRoZSBvcmlnaW5hbCBxdWFnZ2EuanMgZmlsZS5cclxuICogTm90IHByZXNlbnRseSB1c2VkLCBhcyB3b3JrZXIgc3VwcG9ydCBpcyBub24tZnVuY3Rpb25hbC4gIEtlZXBpbmcgdGhlbSBhcm91bmQgdGVtcG9yYXJpbHlcclxuICogdG8gcmVmZXIgdG8gdW50aWwgaXQgaXMgcmUtaW1wbGVtZW50ZWQuIFdlIG1heSBiZSBhYmxlIHRvIGZpeC91c2Ugc29tZSBvZiB0aGlzLlxyXG4gKi9cclxuXHJcbmltcG9ydCB7IFF1YWdnYUpTQ29uZmlnT2JqZWN0LCBRdWFnZ2FKU1JlYWRlckNvbmZpZyB9IGZyb20gXCIuLi8uLi90eXBlLWRlZmluaXRpb25zL3F1YWdnYVwiO1xyXG5cclxuLy8gVE9ETzogbmVlZCBhIHR5cGVzY3JpcHQgaW50ZXJmYWNlIGZvciBGcmFtZUdyYWJiZXJcclxuXHJcbmludGVyZmFjZSBRV29ya2VyVGhyZWFkIHtcclxuICAgIGltYWdlRGF0YTogVWludDhBcnJheTtcclxuICAgIGJ1c3k6IGJvb2xlYW47XHJcbiAgICB3b3JrZXI6IFdvcmtlcjtcclxufVxyXG5cclxubGV0IHdvcmtlclBvb2w6IEFycmF5PFFXb3JrZXJUaHJlYWQ+ID0gW107XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlV29ya2VycyhmcmFtZUdyYWJiZXI6IGFueSkge1xyXG4gICAgbGV0IGF2YWlsYWJsZVdvcmtlcjogUVdvcmtlclRocmVhZDtcclxuICAgIGlmICh3b3JrZXJQb29sLmxlbmd0aCkge1xyXG4gICAgICAgIGF2YWlsYWJsZVdvcmtlciA9IHdvcmtlclBvb2wuZmlsdGVyKCh3b3JrZXJUaHJlYWQpID0+ICF3b3JrZXJUaHJlYWQuYnVzeSlbMF07XHJcbiAgICAgICAgaWYgKGF2YWlsYWJsZVdvcmtlcikge1xyXG4gICAgICAgICAgICBmcmFtZUdyYWJiZXIuYXR0YWNoRGF0YShhdmFpbGFibGVXb3JrZXIuaW1hZ2VEYXRhKTtcclxuICAgICAgICAgICAgaWYgKGZyYW1lR3JhYmJlci5ncmFiKCkpIHtcclxuICAgICAgICAgICAgICAgIGF2YWlsYWJsZVdvcmtlci5idXN5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGF2YWlsYWJsZVdvcmtlci53b3JrZXIucG9zdE1lc3NhZ2Uoe1xyXG4gICAgICAgICAgICAgICAgICAgIGNtZDogJ3Byb2Nlc3MnLFxyXG4gICAgICAgICAgICAgICAgICAgIGltYWdlRGF0YTogYXZhaWxhYmxlV29ya2VyLmltYWdlRGF0YSxcclxuICAgICAgICAgICAgICAgIH0sIFthdmFpbGFibGVXb3JrZXIuaW1hZ2VEYXRhLmJ1ZmZlcl0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxufVxyXG5cclxuZnVuY3Rpb24gY29uZmlnRm9yV29ya2VyKGNvbmZpZzogUXVhZ2dhSlNDb25maWdPYmplY3QpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgLi4uY29uZmlnLFxyXG4gICAgICAgIGlucHV0U3RyZWFtOiB7XHJcbiAgICAgICAgICAgIC4uLmNvbmZpZy5pbnB1dFN0cmVhbSxcclxuICAgICAgICAgICAgdGFyZ2V0OiBudWxsLFxyXG4gICAgICAgIH0sXHJcbiAgICB9O1xyXG59XHJcblxyXG4vLyBAdHMtaWdub3JlXHJcbmZ1bmN0aW9uIHdvcmtlckludGVyZmFjZShmYWN0b3J5KSB7XHJcbiAgICBpZiAoZmFjdG9yeSkge1xyXG4gICAgICAgIHZhciBRdWFnZ2EgPSBmYWN0b3J5KCkuZGVmYXVsdDtcclxuICAgICAgICBpZiAoIVF1YWdnYSkge1xyXG4vLyBAdHMtaWdub3JlXHJcbiAgICAgICAgICAgIHNlbGYucG9zdE1lc3NhZ2UoeyAnZXZlbnQnOiAnZXJyb3InLCBtZXNzYWdlOiAnUXVhZ2dhIGNvdWxkIG5vdCBiZSBjcmVhdGVkJyB9KTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuLy8gQHRzLWlnbm9yZVxyXG4gICAgdmFyIGltYWdlV3JhcHBlcjtcclxuXHJcbi8vIEB0cy1pZ25vcmVcclxuICAgIGZ1bmN0aW9uIG9uUHJvY2Vzc2VkKHJlc3VsdCkge1xyXG4gICAgICAgIHNlbGYucG9zdE1lc3NhZ2Uoe1xyXG4gICAgICAgICAgICAnZXZlbnQnOiAncHJvY2Vzc2VkJyxcclxuLy8gQHRzLWlnbm9yZVxyXG4gICAgICAgICAgICBpbWFnZURhdGE6IGltYWdlV3JhcHBlci5kYXRhLFxyXG4gICAgICAgICAgICByZXN1bHQ6IHJlc3VsdCxcclxuLy8gQHRzLWlnbm9yZVxyXG4gICAgICAgIH0sIFtpbWFnZVdyYXBwZXIuZGF0YS5idWZmZXJdKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB3b3JrZXJJbnRlcmZhY2VSZWFkeSgpIHtcclxuICAgICAgICBzZWxmLnBvc3RNZXNzYWdlKHtcclxuICAgICAgICAgICAgJ2V2ZW50JzogJ2luaXRpYWxpemVkJyxcclxuLy8gQHRzLWlnbm9yZVxyXG4gICAgICAgICAgICBpbWFnZURhdGE6IGltYWdlV3JhcHBlci5kYXRhLFxyXG4vLyBAdHMtaWdub3JlXHJcbiAgICAgICAgfSwgW2ltYWdlV3JhcHBlci5kYXRhLmJ1ZmZlcl0pO1xyXG4gICAgfVxyXG5cclxuLy8gQHRzLWlnbm9yZVxyXG4gICAgc2VsZi5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgIGlmIChlLmRhdGEuY21kID09PSAnaW5pdCcpIHtcclxuICAgICAgICAgICAgdmFyIGNvbmZpZyA9IGUuZGF0YS5jb25maWc7XHJcbiAgICAgICAgICAgIGNvbmZpZy5udW1PZldvcmtlcnMgPSAwO1xyXG4gICAgICAgICAgICBpbWFnZVdyYXBwZXIgPSBuZXcgUXVhZ2dhLkltYWdlV3JhcHBlcih7XHJcbiAgICAgICAgICAgICAgICB4OiBlLmRhdGEuc2l6ZS54LFxyXG4gICAgICAgICAgICAgICAgeTogZS5kYXRhLnNpemUueSxcclxuICAgICAgICAgICAgfSwgbmV3IFVpbnQ4QXJyYXkoZS5kYXRhLmltYWdlRGF0YSkpO1xyXG4gICAgICAgICAgICBRdWFnZ2EuaW5pdChjb25maWcsIHdvcmtlckludGVyZmFjZVJlYWR5LCBpbWFnZVdyYXBwZXIpO1xyXG4gICAgICAgICAgICBRdWFnZ2Eub25Qcm9jZXNzZWQob25Qcm9jZXNzZWQpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZS5kYXRhLmNtZCA9PT0gJ3Byb2Nlc3MnKSB7XHJcbi8vIEB0cy1pZ25vcmVcclxuICAgICAgICAgICAgaW1hZ2VXcmFwcGVyLmRhdGEgPSBuZXcgVWludDhBcnJheShlLmRhdGEuaW1hZ2VEYXRhKTtcclxuICAgICAgICAgICAgUXVhZ2dhLnN0YXJ0KCk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChlLmRhdGEuY21kID09PSAnc2V0UmVhZGVycycpIHtcclxuICAgICAgICAgICAgUXVhZ2dhLnNldFJlYWRlcnMoZS5kYXRhLnJlYWRlcnMpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZS5kYXRhLmNtZCA9PT0gJ3JlZ2lzdGVyUmVhZGVyJykge1xyXG4gICAgICAgICAgICBRdWFnZ2EucmVnaXN0ZXJSZWFkZXIoZS5kYXRhLm5hbWUsIGUuZGF0YS5yZWFkZXIpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdlbmVyYXRlV29ya2VyQmxvYigpIHtcclxuICAgIHZhciBibG9iLFxyXG4gICAgICAgIGZhY3RvcnlTb3VyY2U7XHJcblxyXG4gICAgLyoganNoaW50IGlnbm9yZTpzdGFydCAqL1xyXG4gICAgLy8gQHRzLWlnbm9yZVxyXG4gICAgaWYgKHR5cGVvZiBfX2ZhY3RvcnlTb3VyY2VfXyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAvLyBAdHMtaWdub3JlXHJcbiAgICAgICAgZmFjdG9yeVNvdXJjZSA9IF9fZmFjdG9yeVNvdXJjZV9fOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXHJcbiAgICB9XHJcbiAgICAvKiBqc2hpbnQgaWdub3JlOmVuZCAqL1xyXG5cclxuICAgIGJsb2IgPSBuZXcgQmxvYihbJygnICsgd29ya2VySW50ZXJmYWNlLnRvU3RyaW5nKCkgKyAnKSgnICsgZmFjdG9yeVNvdXJjZSArICcpOyddLFxyXG4gICAgICAgIHsgdHlwZTogJ3RleHQvamF2YXNjcmlwdCcgfSk7XHJcblxyXG4gICAgcmV0dXJuIHdpbmRvdy5VUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gaW5pdFdvcmtlcihjb25maWc6IFF1YWdnYUpTQ29uZmlnT2JqZWN0LCBpbnB1dFN0cmVhbTogYW55LCBjYjogRnVuY3Rpb24pIHtcclxuICAgIGNvbnN0IGJsb2JVUkwgPSBnZW5lcmF0ZVdvcmtlckJsb2IoKTtcclxuICAgIGNvbnN0IHdvcmtlciA9IG5ldyBXb3JrZXIoYmxvYlVSTCk7XHJcblxyXG4gICAgY29uc3Qgd29ya2VyVGhyZWFkOiBRV29ya2VyVGhyZWFkID0ge1xyXG4gICAgICAgIHdvcmtlcixcclxuICAgICAgICBpbWFnZURhdGE6IG5ldyBVaW50OEFycmF5KGlucHV0U3RyZWFtLmdldFdpZHRoKCkgKiBpbnB1dFN0cmVhbS5nZXRIZWlnaHQoKSksXHJcbiAgICAgICAgYnVzeTogdHJ1ZSxcclxuICAgIH07XHJcblxyXG4gICAgd29ya2VyVGhyZWFkLndvcmtlci5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgIGlmIChlLmRhdGEuZXZlbnQgPT09ICdpbml0aWFsaXplZCcpIHtcclxuICAgICAgICAgICAgVVJMLnJldm9rZU9iamVjdFVSTChibG9iVVJMKTtcclxuICAgICAgICAgICAgd29ya2VyVGhyZWFkLmJ1c3kgPSBmYWxzZTtcclxuICAgICAgICAgICAgd29ya2VyVGhyZWFkLmltYWdlRGF0YSA9IG5ldyBVaW50OEFycmF5KGUuZGF0YS5pbWFnZURhdGEpO1xyXG4gICAgICAgICAgICBpZiAoRU5WLmRldmVsb3BtZW50KSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnV29ya2VyIGluaXRpYWxpemVkJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2Iod29ya2VyVGhyZWFkKTtcclxuICAgICAgICB9IGVsc2UgaWYgKGUuZGF0YS5ldmVudCA9PT0gJ3Byb2Nlc3NlZCcpIHtcclxuICAgICAgICAgICAgd29ya2VyVGhyZWFkLmltYWdlRGF0YSA9IG5ldyBVaW50OEFycmF5KGUuZGF0YS5pbWFnZURhdGEpO1xyXG4gICAgICAgICAgICB3b3JrZXJUaHJlYWQuYnVzeSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAvLyBUT0RPOiBob3cgdG8gdGhyZWFkIHB1Ymxpc2hSZXN1bHQgaW50byBoZXJlP1xyXG4gICAgICAgICAgICAvLyBwdWJsaXNoUmVzdWx0KGUuZGF0YS5yZXN1bHQsIHdvcmtlclRocmVhZC5pbWFnZURhdGEpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZS5kYXRhLmV2ZW50ID09PSAnZXJyb3InKSB7XHJcbiAgICAgICAgICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdXb3JrZXIgZXJyb3I6ICcgKyBlLmRhdGEubWVzc2FnZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHdvcmtlclRocmVhZC53b3JrZXIucG9zdE1lc3NhZ2Uoe1xyXG4gICAgICAgIGNtZDogJ2luaXQnLFxyXG4gICAgICAgIHNpemU6IHsgeDogaW5wdXRTdHJlYW0uZ2V0V2lkdGgoKSwgeTogaW5wdXRTdHJlYW0uZ2V0SGVpZ2h0KCkgfSxcclxuICAgICAgICBpbWFnZURhdGE6IHdvcmtlclRocmVhZC5pbWFnZURhdGEsXHJcbiAgICAgICAgY29uZmlnOiBjb25maWdGb3JXb3JrZXIoY29uZmlnKSxcclxuICAgIH0sIFt3b3JrZXJUaHJlYWQuaW1hZ2VEYXRhLmJ1ZmZlcl0pO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gYWRqdXN0V29ya2VyUG9vbChjYXBhY2l0eTogbnVtYmVyLCBjb25maWc/OiBRdWFnZ2FKU0NvbmZpZ09iamVjdCwgaW5wdXRTdHJlYW0/OiBhbnksIGNiPzogRnVuY3Rpb24pIHtcclxuICAgIGNvbnN0IGluY3JlYXNlQnkgPSBjYXBhY2l0eSAtIHdvcmtlclBvb2wubGVuZ3RoO1xyXG4gICAgaWYgKGluY3JlYXNlQnkgPT09IDAgJiYgY2IpIHtcclxuICAgICAgICBjYigpO1xyXG4gICAgfSBlbHNlIGlmIChpbmNyZWFzZUJ5IDwgMCkge1xyXG4gICAgICAgIGNvbnN0IHdvcmtlcnNUb1Rlcm1pbmF0ZSA9IHdvcmtlclBvb2wuc2xpY2UoaW5jcmVhc2VCeSk7XHJcbiAgICAgICAgd29ya2Vyc1RvVGVybWluYXRlLmZvckVhY2goZnVuY3Rpb24gKHdvcmtlclRocmVhZCkge1xyXG4gICAgICAgICAgICB3b3JrZXJUaHJlYWQud29ya2VyLnRlcm1pbmF0ZSgpO1xyXG4gICAgICAgICAgICBpZiAoRU5WLmRldmVsb3BtZW50KSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnV29ya2VyIHRlcm1pbmF0ZWQhJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICB3b3JrZXJQb29sID0gd29ya2VyUG9vbC5zbGljZSgwLCBpbmNyZWFzZUJ5KTtcclxuICAgICAgICBpZiAoY2IpIHtcclxuICAgICAgICAgICAgY2IoKTtcclxuICAgICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNvbnN0IHdvcmtlckluaXRpYWxpemVkID0gKHdvcmtlclRocmVhZDogUVdvcmtlclRocmVhZCkgPT4ge1xyXG4gICAgICAgICAgICB3b3JrZXJQb29sLnB1c2god29ya2VyVGhyZWFkKTtcclxuICAgICAgICAgICAgaWYgKHdvcmtlclBvb2wubGVuZ3RoID49IGNhcGFjaXR5ICYmIGNiKSB7XHJcbiAgICAgICAgICAgICAgICBjYigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgaWYgKGNvbmZpZykge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluY3JlYXNlQnk7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaW5pdFdvcmtlcihjb25maWcsIGlucHV0U3RyZWFtLCB3b3JrZXJJbml0aWFsaXplZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBzZXRSZWFkZXJzKHJlYWRlcnM6IEFycmF5PFF1YWdnYUpTUmVhZGVyQ29uZmlnPikge1xyXG4gICAgd29ya2VyUG9vbC5mb3JFYWNoKCh3b3JrZXJUaHJlYWQpID0+IHdvcmtlclRocmVhZC53b3JrZXIucG9zdE1lc3NhZ2UoeyBjbWQ6ICdzZXRSZWFkZXJzJywgcmVhZGVycyB9KSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiByZWdpc3RlclJlYWRlcihuYW1lOiBzdHJpbmcsIHJlYWRlcjogYW55KSB7XHJcbiAgICB3b3JrZXJQb29sLmZvckVhY2goKHdvcmtlclRocmVhZCkgPT4gd29ya2VyVGhyZWFkLndvcmtlci5wb3N0TWVzc2FnZSh7IGNtZDogJ3JlZ2lzdGVyUmVhZGVyJywgbmFtZSwgcmVhZGVyIH0pKTtcclxufVxyXG4iLCJpbXBvcnQgeyBJbnB1dFN0cmVhbVR5cGUgfSBmcm9tICcuLi8uLi90eXBlLWRlZmluaXRpb25zL3F1YWdnYS5kJztcclxuXHJcbi8vIFRPRE86IG5lZWQgdG8gY3JlYXRlIGFuIElucHV0U3RyZWFtIHR5cGVzY3JpcHQgaW50ZXJmYWNlLCBzbyB3ZSBkb24ndCBoYXZlIGFuIFwiYW55XCIgaW4gdGhlIG5leHQgbGluZVxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBzZXR1cElucHV0U3RyZWFtKHR5cGU6IElucHV0U3RyZWFtVHlwZSA9ICdMaXZlU3RyZWFtJywgdmlld3BvcnQ6IEVsZW1lbnQgfCBudWxsLCBJbnB1dFN0cmVhbTogYW55KSB7XHJcbiAgICBzd2l0Y2ggKHR5cGUpIHtcclxuICAgICAgICBjYXNlICdWaWRlb1N0cmVhbSc6IHtcclxuICAgICAgICAgICAgY29uc3QgdmlkZW8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd2aWRlbycpO1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgdmlkZW8sXHJcbiAgICAgICAgICAgICAgICBpbnB1dFN0cmVhbTogSW5wdXRTdHJlYW0uY3JlYXRlVmlkZW9TdHJlYW0odmlkZW8pLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXNlICdJbWFnZVN0cmVhbSc6XHJcbiAgICAgICAgICAgIHJldHVybiB7IGlucHV0U3RyZWFtOiBJbnB1dFN0cmVhbS5jcmVhdGVJbWFnZVN0cmVhbSgpIH07XHJcbiAgICAgICAgY2FzZSAnTGl2ZVN0cmVhbSc6IHtcclxuICAgICAgICAgICAgbGV0IHZpZGVvOiBIVE1MVmlkZW9FbGVtZW50IHwgbnVsbCA9IG51bGw7XHJcbiAgICAgICAgICAgIGlmICh2aWV3cG9ydCkge1xyXG4gICAgICAgICAgICAgICAgdmlkZW8gPSB2aWV3cG9ydC5xdWVyeVNlbGVjdG9yKCd2aWRlbycpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCF2aWRlbykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZpZGVvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndmlkZW8nKTtcclxuICAgICAgICAgICAgICAgICAgICB2aWV3cG9ydC5hcHBlbmRDaGlsZCh2aWRlbyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHZpZGVvLFxyXG4gICAgICAgICAgICAgICAgaW5wdXRTdHJlYW06IElucHV0U3RyZWFtLmNyZWF0ZUxpdmVTdHJlYW0odmlkZW8pLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGAqIHNldHVwSW5wdXRTdHJlYW0gaW52YWxpZCB0eXBlICR7dHlwZX1gKTtcclxuICAgICAgICAgICAgcmV0dXJuIHsgdmlkZW86IG51bGwsIGlucHV0U3RyZWFtOiBudWxsIH07XHJcbiAgICB9XHJcbn1cclxuIiwiLyogZXNsaW50LWRpc2FibGUgbm8tcGFyYW0tcmVhc3NpZ24gKi9cclxuaW1wb3J0IHsgUG9pbnQgfSBmcm9tICcuLi8uLi90eXBlLWRlZmluaXRpb25zL3F1YWdnYS5kJztcclxuXHJcbmV4cG9ydCB0eXBlIEJveCA9IEFycmF5PFsgbnVtYmVyLCBudW1iZXIgXT47XHJcblxyXG5leHBvcnQgdHlwZSBMaW5lID0gWyBQb2ludCwgUG9pbnQgXTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBtb3ZlQm94KGJveDogQm94LCB4T2Zmc2V0OiBudW1iZXIsIHlPZmZzZXQ6IG51bWJlcik6IHZvaWQge1xyXG4gICAgbGV0IGNvcm5lciA9IGJveC5sZW5ndGg7XHJcbiAgICB3aGlsZSAoY29ybmVyLS0pIHtcclxuICAgICAgICBib3hbY29ybmVyXVswXSArPSB4T2Zmc2V0O1xyXG4gICAgICAgIGJveFtjb3JuZXJdWzFdICs9IHlPZmZzZXQ7XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBtb3ZlTGluZShsaW5lOiBMaW5lLCB4T2Zmc2V0OiBudW1iZXIsIHlPZmZzZXQ6IG51bWJlcik6IHZvaWQge1xyXG4gICAgbGluZVswXS54ICs9IHhPZmZzZXQ7XHJcbiAgICBsaW5lWzBdLnkgKz0geU9mZnNldDtcclxuICAgIGxpbmVbMV0ueCArPSB4T2Zmc2V0O1xyXG4gICAgbGluZVsxXS55ICs9IHlPZmZzZXQ7XHJcbn1cclxuIiwiaW1wb3J0IHsgY2xvbmUgfSBmcm9tICdnbC12ZWMyJztcclxuaW1wb3J0IHsgUXVhZ2dhQ29udGV4dCB9IGZyb20gJy4uL1F1YWdnYUNvbnRleHQnO1xyXG5pbXBvcnQgX2luaXRCdWZmZXJzIGZyb20gJy4vaW5pdEJ1ZmZlcnMnO1xyXG5pbXBvcnQgX2dldFZpZXdQb3J0IGZyb20gJy4vZ2V0Vmlld1BvcnQnO1xyXG5pbXBvcnQgSW1hZ2VXcmFwcGVyIGZyb20gJy4uL2NvbW1vbi9pbWFnZV93cmFwcGVyJztcclxuaW1wb3J0IEJhcmNvZGVEZWNvZGVyIGZyb20gJy4uL2RlY29kZXIvYmFyY29kZV9kZWNvZGVyJztcclxuaW1wb3J0IF9pbml0Q2FudmFzIGZyb20gJy4vaW5pdENhbnZhcyc7XHJcbmltcG9ydCBCYXJjb2RlTG9jYXRvciBmcm9tICcuLi9sb2NhdG9yL2JhcmNvZGVfbG9jYXRvcic7XHJcbmltcG9ydCBJbnB1dFN0cmVhbSBmcm9tICcuLi9pbnB1dC9pbnB1dF9zdHJlYW0vaW5wdXRfc3RyZWFtJztcclxuaW1wb3J0IEZyYW1lR3JhYmJlciBmcm9tICcuLi9pbnB1dC9mcmFtZV9ncmFiYmVyLmpzJztcclxuaW1wb3J0ICogYXMgUVdvcmtlcnMgZnJvbSAnLi9xd29ya2VyJztcclxuaW1wb3J0IHNldHVwSW5wdXRTdHJlYW0gZnJvbSAnLi9zZXR1cElucHV0U3RyZWFtJztcclxuaW1wb3J0IENhbWVyYUFjY2VzcyBmcm9tICcuLi9pbnB1dC9jYW1lcmFfYWNjZXNzJztcclxuaW1wb3J0IHsgQmFyY29kZUluZm8gfSBmcm9tICcuLi9yZWFkZXIvYmFyY29kZV9yZWFkZXInO1xyXG5pbXBvcnQgeyBtb3ZlTGluZSwgbW92ZUJveCB9IGZyb20gJy4vdHJhbnNmb3JtJztcclxuaW1wb3J0IHsgUXVhZ2dhSlNSZXN1bHRPYmplY3QsIFF1YWdnYUpTUmVhZGVyQ29uZmlnIH0gZnJvbSAnLi4vLi4vdHlwZS1kZWZpbml0aW9ucy9xdWFnZ2EuZCc7XHJcbmltcG9ydCBFdmVudHMgZnJvbSAnLi4vY29tbW9uL2V2ZW50cyc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBRdWFnZ2Ege1xyXG4gICAgY29udGV4dDogUXVhZ2dhQ29udGV4dCA9IG5ldyBRdWFnZ2FDb250ZXh0KCk7XHJcblxyXG4gICAgaW5pdEJ1ZmZlcnMoaW1hZ2VXcmFwcGVyPzogSW1hZ2VXcmFwcGVyKTogdm9pZCB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmNvbnRleHQuY29uZmlnKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgeyBpbnB1dEltYWdlV3JhcHBlciwgYm94U2l6ZSB9ID0gX2luaXRCdWZmZXJzKFxyXG4gICAgICAgICAgICB0aGlzLmNvbnRleHQuaW5wdXRTdHJlYW0sXHJcbiAgICAgICAgICAgIGltYWdlV3JhcHBlcixcclxuICAgICAgICAgICAgdGhpcy5jb250ZXh0LmNvbmZpZy5sb2NhdG9yLFxyXG4gICAgICAgICk7XHJcbiAgICAgICAgdGhpcy5jb250ZXh0LmlucHV0SW1hZ2VXcmFwcGVyID0gaW5wdXRJbWFnZVdyYXBwZXI7XHJcbiAgICAgICAgdGhpcy5jb250ZXh0LmJveFNpemUgPSBib3hTaXplO1xyXG4gICAgfVxyXG5cclxuICAgIGluaXRpYWxpemVEYXRhKGltYWdlV3JhcHBlcj86IEltYWdlV3JhcHBlcik6IHZvaWQge1xyXG4gICAgICAgIGlmICghdGhpcy5jb250ZXh0LmNvbmZpZykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuaW5pdEJ1ZmZlcnMoaW1hZ2VXcmFwcGVyKTtcclxuICAgICAgICB0aGlzLmNvbnRleHQuZGVjb2RlciA9IEJhcmNvZGVEZWNvZGVyLmNyZWF0ZSh0aGlzLmNvbnRleHQuY29uZmlnLmRlY29kZXIsIHRoaXMuY29udGV4dC5pbnB1dEltYWdlV3JhcHBlcik7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0Vmlld1BvcnQoKTogRWxlbWVudCB8IG51bGwge1xyXG4gICAgICAgIGlmICghdGhpcy5jb250ZXh0LmNvbmZpZyB8fCAhdGhpcy5jb250ZXh0LmNvbmZpZy5pbnB1dFN0cmVhbSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgeyB0YXJnZXQgfSA9IHRoaXMuY29udGV4dC5jb25maWcuaW5wdXRTdHJlYW07XHJcbiAgICAgICAgcmV0dXJuIF9nZXRWaWV3UG9ydCh0YXJnZXQpO1xyXG4gICAgfVxyXG5cclxuICAgIHJlYWR5KGNhbGxiYWNrOiAoKSA9PiB2b2lkKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5jb250ZXh0LmlucHV0U3RyZWFtLnBsYXkoKTtcclxuICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgfVxyXG5cclxuICAgIGluaXRDYW52YXMoKTogdm9pZCB7XHJcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gX2luaXRDYW52YXModGhpcy5jb250ZXh0KTtcclxuICAgICAgICBpZiAoIWNvbnRhaW5lcikge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHsgY3R4LCBkb20gfSA9IGNvbnRhaW5lcjtcclxuICAgICAgICB0aGlzLmNvbnRleHQuY2FudmFzQ29udGFpbmVyLmRvbS5pbWFnZSA9IGRvbS5pbWFnZTtcclxuICAgICAgICB0aGlzLmNvbnRleHQuY2FudmFzQ29udGFpbmVyLmRvbS5vdmVybGF5ID0gZG9tLm92ZXJsYXk7XHJcbiAgICAgICAgdGhpcy5jb250ZXh0LmNhbnZhc0NvbnRhaW5lci5jdHguaW1hZ2UgPSBjdHguaW1hZ2U7XHJcbiAgICAgICAgdGhpcy5jb250ZXh0LmNhbnZhc0NvbnRhaW5lci5jdHgub3ZlcmxheSA9IGN0eC5vdmVybGF5O1xyXG4gICAgfVxyXG5cclxuICAgIGNhblJlY29yZCA9IChjYWxsYmFjazogKCkgPT4gdm9pZCk6IHZvaWQgPT4ge1xyXG4gICAgICAgIGlmICghdGhpcy5jb250ZXh0LmNvbmZpZykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIEJhcmNvZGVMb2NhdG9yLmNoZWNrSW1hZ2VDb25zdHJhaW50cyh0aGlzLmNvbnRleHQuaW5wdXRTdHJlYW0sIHRoaXMuY29udGV4dC5jb25maWc/LmxvY2F0b3IpO1xyXG4gICAgICAgIHRoaXMuaW5pdENhbnZhcygpO1xyXG4gICAgICAgIHRoaXMuY29udGV4dC5mcmFtZWdyYWJiZXIgPSBGcmFtZUdyYWJiZXIuY3JlYXRlKFxyXG4gICAgICAgICAgICB0aGlzLmNvbnRleHQuaW5wdXRTdHJlYW0sXHJcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5jYW52YXNDb250YWluZXIuZG9tLmltYWdlLFxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmNvbnRleHQuY29uZmlnLm51bU9mV29ya2VycyA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5jb25maWcubnVtT2ZXb3JrZXJzID0gMDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIFFXb3JrZXJzLmFkanVzdFdvcmtlclBvb2wodGhpcy5jb250ZXh0LmNvbmZpZy5udW1PZldvcmtlcnMsXHJcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5jb25maWcsXHJcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5pbnB1dFN0cmVhbSxcclxuICAgICAgICAgICAgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY29udGV4dC5jb25maWc/Lm51bU9mV29ya2VycyA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5pdGlhbGl6ZURhdGEoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMucmVhZHkoY2FsbGJhY2spO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgaW5pdElucHV0U3RyZWFtKGNhbGxiYWNrOiAoZXJyPzogRXJyb3IpID0+IHZvaWQpOiB2b2lkIHtcclxuICAgICAgICBpZiAoIXRoaXMuY29udGV4dC5jb25maWcgfHwgIXRoaXMuY29udGV4dC5jb25maWcuaW5wdXRTdHJlYW0pIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB7IHR5cGU6IGlucHV0VHlwZSwgY29uc3RyYWludHMgfSA9IHRoaXMuY29udGV4dC5jb25maWcuaW5wdXRTdHJlYW07XHJcbiAgICAgICAgY29uc3QgeyB2aWRlbywgaW5wdXRTdHJlYW0gfSA9IHNldHVwSW5wdXRTdHJlYW0oaW5wdXRUeXBlLCB0aGlzLmdldFZpZXdQb3J0KCksIElucHV0U3RyZWFtKTtcclxuXHJcbiAgICAgICAgaWYgKGlucHV0VHlwZSA9PT0gJ0xpdmVTdHJlYW0nICYmIHZpZGVvKSB7XHJcbiAgICAgICAgICAgIENhbWVyYUFjY2Vzcy5yZXF1ZXN0KHZpZGVvLCBjb25zdHJhaW50cylcclxuICAgICAgICAgICAgICAgIC50aGVuKCgpID0+IGlucHV0U3RyZWFtLnRyaWdnZXIoJ2NhbnJlY29yZCcpKVxyXG4gICAgICAgICAgICAgICAgLmNhdGNoKChlcnIpID0+IGNhbGxiYWNrKGVycikpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaW5wdXRTdHJlYW0uc2V0QXR0cmlidXRlKCdwcmVsb2FkJywgJ2F1dG8nKTtcclxuICAgICAgICBpbnB1dFN0cmVhbS5zZXRJbnB1dFN0cmVhbSh0aGlzLmNvbnRleHQuY29uZmlnLmlucHV0U3RyZWFtKTtcclxuICAgICAgICBpbnB1dFN0cmVhbS5hZGRFdmVudExpc3RlbmVyKCdjYW5yZWNvcmQnLCB0aGlzLmNhblJlY29yZC5iaW5kKHVuZGVmaW5lZCwgY2FsbGJhY2spKTtcclxuXHJcbiAgICAgICAgdGhpcy5jb250ZXh0LmlucHV0U3RyZWFtID0gaW5wdXRTdHJlYW07XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0Qm91bmRpbmdCb3hlcygpOiBBcnJheTxBcnJheTxudW1iZXI+PiB8IG51bGwge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRleHQuY29uZmlnPy5sb2NhdGUgPyBCYXJjb2RlTG9jYXRvci5sb2NhdGUoKVxyXG4gICAgICAgICAgICA6IFtbXHJcbiAgICAgICAgICAgICAgICBjbG9uZSh0aGlzLmNvbnRleHQuYm94U2l6ZVswXSksXHJcbiAgICAgICAgICAgICAgICBjbG9uZSh0aGlzLmNvbnRleHQuYm94U2l6ZVsxXSksXHJcbiAgICAgICAgICAgICAgICBjbG9uZSh0aGlzLmNvbnRleHQuYm94U2l6ZVsyXSksXHJcbiAgICAgICAgICAgICAgICBjbG9uZSh0aGlzLmNvbnRleHQuYm94U2l6ZVszXSksXHJcbiAgICAgICAgICAgIF1dO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFRPRE86IG5lZWQgYSB0eXBlc2NyaXB0IHR5cGUgZm9yIHJlc3VsdCBoZXJlLlxyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9leHBsaWNpdC1tb2R1bGUtYm91bmRhcnktdHlwZXNcclxuICAgIHRyYW5zZm9ybVJlc3VsdChyZXN1bHQ6IGFueSk6IHZvaWQge1xyXG4gICAgICAgIGNvbnN0IHRvcFJpZ2h0ID0gdGhpcy5jb250ZXh0LmlucHV0U3RyZWFtLmdldFRvcFJpZ2h0KCk7XHJcbiAgICAgICAgY29uc3QgeE9mZnNldCA9IHRvcFJpZ2h0Lng7XHJcbiAgICAgICAgY29uc3QgeU9mZnNldCA9IHRvcFJpZ2h0Lnk7XHJcblxyXG4gICAgICAgIGlmICh4T2Zmc2V0ID09PSAwICYmIHlPZmZzZXQgPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHJlc3VsdC5iYXJjb2Rlcykge1xyXG4gICAgICAgICAgICAvLyBUT0RPOiBCYXJjb2RlSW5mbyBtYXkgbm90IGJlIHRoZSByaWdodCB0eXBlIGhlcmUuXHJcbiAgICAgICAgICAgIHJlc3VsdC5iYXJjb2Rlcy5mb3JFYWNoKChiYXJjb2RlOiBCYXJjb2RlSW5mbykgPT4gdGhpcy50cmFuc2Zvcm1SZXN1bHQoYmFyY29kZSkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHJlc3VsdC5saW5lICYmIHJlc3VsdC5saW5lLmxlbmd0aCA9PT0gMikge1xyXG4gICAgICAgICAgICBtb3ZlTGluZShyZXN1bHQubGluZSwgeE9mZnNldCwgeU9mZnNldCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAocmVzdWx0LmJveCkge1xyXG4gICAgICAgICAgICBtb3ZlQm94KHJlc3VsdC5ib3gsIHhPZmZzZXQsIHlPZmZzZXQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHJlc3VsdC5ib3hlcyAmJiByZXN1bHQuYm94ZXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc3VsdC5ib3hlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgbW92ZUJveChyZXN1bHQuYm94ZXNbaV0sIHhPZmZzZXQsIHlPZmZzZXQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGFkZFJlc3VsdChyZXN1bHQ6IFF1YWdnYUpTUmVzdWx0T2JqZWN0LCBpbWFnZURhdGE6IEFycmF5PG51bWJlcj4pOiB2b2lkIHtcclxuICAgICAgICBpZiAoIWltYWdlRGF0YSB8fCAhdGhpcy5jb250ZXh0LnJlc3VsdENvbGxlY3Rvcikge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBUT0RPOiBGaWd1cmUgb3V0IHdoYXQgZGF0YSBzdHJ1Y3R1cmUgaG9sZHMgYSBcImJhcmNvZGVzXCIgcmVzdWx0LCBpZiBhbnkuLi5cclxuICAgICAgICBpZiAocmVzdWx0LmJhcmNvZGVzKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5iYXJjb2Rlcy5maWx0ZXIoKGJhcmNvZGU6IFF1YWdnYUpTUmVzdWx0T2JqZWN0KSA9PiBiYXJjb2RlLmNvZGVSZXN1bHQpXHJcbiAgICAgICAgICAgICAgICAuZm9yRWFjaCgoYmFyY29kZTogUXVhZ2dhSlNSZXN1bHRPYmplY3QpID0+IHRoaXMuYWRkUmVzdWx0KGJhcmNvZGUsIGltYWdlRGF0YSkpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAocmVzdWx0LmNvZGVSZXN1bHQpIHtcclxuICAgICAgICAgICAgdGhpcy5jb250ZXh0LnJlc3VsdENvbGxlY3Rvci5hZGRSZXN1bHQoXHJcbiAgICAgICAgICAgICAgICBpbWFnZURhdGEsXHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuaW5wdXRTdHJlYW0uZ2V0Q2FudmFzU2l6ZSgpLFxyXG4gICAgICAgICAgICAgICAgcmVzdWx0LmNvZGVSZXN1bHQsXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjbGFzcy1tZXRob2RzLXVzZS10aGlzXHJcbiAgICBoYXNDb2RlUmVzdWx0KHJlc3VsdDogUXVhZ2dhSlNSZXN1bHRPYmplY3QpOiBib29sZWFuIHtcclxuICAgICAgICByZXR1cm4gISEocmVzdWx0ICYmIChyZXN1bHQuYmFyY29kZXNcclxuICAgICAgICAgICAgPyByZXN1bHQuYmFyY29kZXMuc29tZSgoYmFyY29kZSkgPT4gYmFyY29kZS5jb2RlUmVzdWx0KVxyXG4gICAgICAgICAgICA6IHJlc3VsdC5jb2RlUmVzdWx0KSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9leHBsaWNpdC1tb2R1bGUtYm91bmRhcnktdHlwZXNcclxuICAgIHB1Ymxpc2hSZXN1bHQocmVzdWx0OiBRdWFnZ2FKU1Jlc3VsdE9iamVjdCB8IG51bGwgPSBudWxsLCBpbWFnZURhdGE/OiBhbnkpOiB2b2lkIHtcclxuICAgICAgICBsZXQgcmVzdWx0VG9QdWJsaXNoOiBBcnJheTxRdWFnZ2FKU1Jlc3VsdE9iamVjdD4gfCBRdWFnZ2FKU1Jlc3VsdE9iamVjdCB8IG51bGwgPSByZXN1bHQ7XHJcblxyXG4gICAgICAgIGlmIChyZXN1bHQgJiYgdGhpcy5jb250ZXh0Lm9uVUlUaHJlYWQpIHtcclxuICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm1SZXN1bHQocmVzdWx0KTtcclxuICAgICAgICAgICAgdGhpcy5hZGRSZXN1bHQocmVzdWx0LCBpbWFnZURhdGEpO1xyXG4gICAgICAgICAgICByZXN1bHRUb1B1Ymxpc2ggPSByZXN1bHQuYmFyY29kZXMgfHwgcmVzdWx0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgRXZlbnRzLnB1Ymxpc2goJ3Byb2Nlc3NlZCcsIHJlc3VsdFRvUHVibGlzaCBhcyBuZXZlcik7XHJcbiAgICAgICAgaWYgKHRoaXMuaGFzQ29kZVJlc3VsdChyZXN1bHQgYXMgUXVhZ2dhSlNSZXN1bHRPYmplY3QpKSB7XHJcbiAgICAgICAgICAgIEV2ZW50cy5wdWJsaXNoKCdkZXRlY3RlZCcsIHJlc3VsdFRvUHVibGlzaCBhcyBuZXZlcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGxvY2F0ZUFuZERlY29kZSgpOiB2b2lkIHtcclxuICAgICAgICBjb25zdCBib3hlcyA9IHRoaXMuZ2V0Qm91bmRpbmdCb3hlcygpO1xyXG4gICAgICAgIGlmIChib3hlcykge1xyXG4gICAgICAgICAgICBjb25zdCBkZWNvZGVSZXN1bHQgPSB0aGlzLmNvbnRleHQuZGVjb2Rlci5kZWNvZGVGcm9tQm91bmRpbmdCb3hlcyhib3hlcykgfHwge307XHJcbiAgICAgICAgICAgIGRlY29kZVJlc3VsdC5ib3hlcyA9IGJveGVzO1xyXG4gICAgICAgICAgICB0aGlzLnB1Ymxpc2hSZXN1bHQoZGVjb2RlUmVzdWx0LCB0aGlzLmNvbnRleHQuaW5wdXRJbWFnZVdyYXBwZXI/LmRhdGEpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGltYWdlUmVzdWx0ID0gdGhpcy5jb250ZXh0LmRlY29kZXIuZGVjb2RlRnJvbUltYWdlKHRoaXMuY29udGV4dC5pbnB1dEltYWdlV3JhcHBlcik7XHJcbiAgICAgICAgICAgIGlmIChpbWFnZVJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wdWJsaXNoUmVzdWx0KGltYWdlUmVzdWx0LCB0aGlzLmNvbnRleHQuaW5wdXRJbWFnZVdyYXBwZXI/LmRhdGEpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wdWJsaXNoUmVzdWx0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdXBkYXRlID0gKCk6IHZvaWQgPT4ge1xyXG4gICAgICAgIGlmICh0aGlzLmNvbnRleHQub25VSVRocmVhZCkge1xyXG4gICAgICAgICAgICBjb25zdCB3b3JrZXJzVXBkYXRlZCA9IFFXb3JrZXJzLnVwZGF0ZVdvcmtlcnModGhpcy5jb250ZXh0LmZyYW1lZ3JhYmJlcik7XHJcbiAgICAgICAgICAgIGlmICghd29ya2Vyc1VwZGF0ZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5mcmFtZWdyYWJiZXIuYXR0YWNoRGF0YSh0aGlzLmNvbnRleHQuaW5wdXRJbWFnZVdyYXBwZXI/LmRhdGEpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY29udGV4dC5mcmFtZWdyYWJiZXIuZ3JhYigpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF3b3JrZXJzVXBkYXRlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxvY2F0ZUFuZERlY29kZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5mcmFtZWdyYWJiZXIuYXR0YWNoRGF0YSh0aGlzLmNvbnRleHQuaW5wdXRJbWFnZVdyYXBwZXI/LmRhdGEpO1xyXG4gICAgICAgICAgICB0aGlzLmNvbnRleHQuZnJhbWVncmFiYmVyLmdyYWIoKTtcclxuICAgICAgICAgICAgdGhpcy5sb2NhdGVBbmREZWNvZGUoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHN0YXJ0Q29udGludW91c1VwZGF0ZSgpOiB2b2lkIHtcclxuICAgICAgICBsZXQgbmV4dDogbnVtYmVyIHwgbnVsbCA9IG51bGw7XHJcbiAgICAgICAgY29uc3QgZGVsYXkgPSAxMDAwIC8gKHRoaXMuY29udGV4dC5jb25maWc/LmZyZXF1ZW5jeSB8fCA2MCk7XHJcblxyXG4gICAgICAgIHRoaXMuY29udGV4dC5zdG9wcGVkID0gZmFsc2U7XHJcbiAgICAgICAgY29uc3QgeyBjb250ZXh0IH0gPSB0aGlzO1xyXG5cclxuICAgICAgICBjb25zdCBuZXdGcmFtZSA9ICh0aW1lc3RhbXA6IG51bWJlcikgPT4ge1xyXG4gICAgICAgICAgICBuZXh0ID0gbmV4dCB8fCB0aW1lc3RhbXA7XHJcbiAgICAgICAgICAgIGlmICghY29udGV4dC5zdG9wcGVkKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGltZXN0YW1wID49IG5leHQpIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXh0ICs9IGRlbGF5O1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKG5ld0ZyYW1lKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIG5ld0ZyYW1lKHBlcmZvcm1hbmNlLm5vdygpKTtcclxuICAgIH1cclxuXHJcbiAgICBzdGFydCgpOiB2b2lkIHtcclxuICAgICAgICBpZiAodGhpcy5jb250ZXh0Lm9uVUlUaHJlYWQgJiYgdGhpcy5jb250ZXh0LmNvbmZpZz8uaW5wdXRTdHJlYW0/LnR5cGUgPT09ICdMaXZlU3RyZWFtJykge1xyXG4gICAgICAgICAgICB0aGlzLnN0YXJ0Q29udGludW91c1VwZGF0ZSgpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGFzeW5jIHN0b3AoKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgdGhpcy5jb250ZXh0LnN0b3BwZWQgPSB0cnVlO1xyXG4gICAgICAgIFFXb3JrZXJzLmFkanVzdFdvcmtlclBvb2woMCk7XHJcbiAgICAgICAgaWYgKHRoaXMuY29udGV4dC5jb25maWc/LmlucHV0U3RyZWFtICYmIHRoaXMuY29udGV4dC5jb25maWcuaW5wdXRTdHJlYW0udHlwZSA9PT0gJ0xpdmVTdHJlYW0nKSB7XHJcbiAgICAgICAgICAgIGF3YWl0IENhbWVyYUFjY2Vzcy5yZWxlYXNlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5pbnB1dFN0cmVhbS5jbGVhckV2ZW50SGFuZGxlcnMoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgc2V0UmVhZGVycyhyZWFkZXJzOiBBcnJheTxRdWFnZ2FKU1JlYWRlckNvbmZpZz4pOiB2b2lkIHtcclxuICAgICAgICBpZiAodGhpcy5jb250ZXh0LmRlY29kZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5jb250ZXh0LmRlY29kZXIuc2V0UmVhZGVycyhyZWFkZXJzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgUVdvcmtlcnMuc2V0UmVhZGVycyhyZWFkZXJzKTtcclxuICAgIH1cclxuXHJcbiAgICByZWdpc3RlclJlYWRlcihuYW1lOiBzdHJpbmcsIHJlYWRlcjogUXVhZ2dhSlNSZWFkZXJDb25maWcpOiB2b2lkIHtcclxuICAgICAgICBCYXJjb2RlRGVjb2Rlci5yZWdpc3RlclJlYWRlcihuYW1lLCByZWFkZXIpO1xyXG4gICAgICAgIGlmICh0aGlzLmNvbnRleHQuZGVjb2Rlcikge1xyXG4gICAgICAgICAgICB0aGlzLmNvbnRleHQuZGVjb2Rlci5yZWdpc3RlclJlYWRlcihuYW1lLCByZWFkZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBRV29ya2Vycy5yZWdpc3RlclJlYWRlcihuYW1lLCByZWFkZXIpO1xyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCBtZXJnZSBmcm9tICdsb2Rhc2gvbWVyZ2UnO1xyXG5pbXBvcnQgVHlwZURlZnMgZnJvbSAnLi9jb21tb24vdHlwZWRlZnMnOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXHJcbmltcG9ydCBJbWFnZVdyYXBwZXIgZnJvbSAnLi9jb21tb24vaW1hZ2Vfd3JhcHBlcic7XHJcbmltcG9ydCBCYXJjb2RlRGVjb2RlciBmcm9tICcuL2RlY29kZXIvYmFyY29kZV9kZWNvZGVyJztcclxuaW1wb3J0ICogYXMgUmVhZGVycyBmcm9tICcuL3JlYWRlci9pbmRleCc7XHJcbmltcG9ydCBFdmVudHMgZnJvbSAnLi9jb21tb24vZXZlbnRzJztcclxuaW1wb3J0IENhbWVyYUFjY2VzcyBmcm9tICcuL2lucHV0L2NhbWVyYV9hY2Nlc3MnO1xyXG5pbXBvcnQgSW1hZ2VEZWJ1ZyBmcm9tICcuL2NvbW1vbi9pbWFnZV9kZWJ1Zyc7XHJcbmltcG9ydCBSZXN1bHRDb2xsZWN0b3IgZnJvbSAnLi9hbmFseXRpY3MvcmVzdWx0X2NvbGxlY3Rvcic7XHJcbmltcG9ydCBDb25maWcgZnJvbSAnLi9jb25maWcvY29uZmlnJztcclxuXHJcbmltcG9ydCBRdWFnZ2EgZnJvbSAnLi9xdWFnZ2EvcXVhZ2dhJztcclxuXHJcbmNvbnN0IGluc3RhbmNlID0gbmV3IFF1YWdnYSgpO1xyXG5jb25zdCBfY29udGV4dCA9IGluc3RhbmNlLmNvbnRleHQ7XHJcblxyXG5jb25zdCBRdWFnZ2FKU1N0YXRpY0ludGVyZmFjZSA9IHtcclxuICAgIGluaXQ6IGZ1bmN0aW9uIChjb25maWcsIGNiLCBpbWFnZVdyYXBwZXIsIHF1YWdnYUluc3RhbmNlID0gaW5zdGFuY2UpIHtcclxuICAgICAgICBsZXQgcHJvbWlzZTtcclxuICAgICAgICBpZiAoIWNiKSB7XHJcbiAgICAgICAgICAgIHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjYiA9IChlcnIpID0+IHsgZXJyID8gcmVqZWN0KGVycikgOiByZXNvbHZlKCk7IH07XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBxdWFnZ2FJbnN0YW5jZS5jb250ZXh0LmNvbmZpZyA9IG1lcmdlKHt9LCBDb25maWcsIGNvbmZpZyk7XHJcbiAgICAgICAgLy8gVE9ETyAjMTc5OiBwZW5kaW5nIHJlc3RydWN0dXJlIGluIElzc3VlICMxNzksIHdlIGFyZSB0ZW1wIGRpc2FibGluZyB3b3JrZXJzXHJcbiAgICAgICAgaWYgKHF1YWdnYUluc3RhbmNlLmNvbnRleHQuY29uZmlnLm51bU9mV29ya2VycyA+IDApIHtcclxuICAgICAgICAgICAgcXVhZ2dhSW5zdGFuY2UuY29udGV4dC5jb25maWcubnVtT2ZXb3JrZXJzID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGltYWdlV3JhcHBlcikge1xyXG4gICAgICAgICAgICBxdWFnZ2FJbnN0YW5jZS5jb250ZXh0Lm9uVUlUaHJlYWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgcXVhZ2dhSW5zdGFuY2UuaW5pdGlhbGl6ZURhdGEoaW1hZ2VXcmFwcGVyKTtcclxuICAgICAgICAgICAgaWYgKGNiKSB7XHJcbiAgICAgICAgICAgICAgICBjYigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcXVhZ2dhSW5zdGFuY2UuaW5pdElucHV0U3RyZWFtKGNiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHByb21pc2U7XHJcbiAgICB9LFxyXG4gICAgc3RhcnQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gaW5zdGFuY2Uuc3RhcnQoKTtcclxuICAgIH0sXHJcbiAgICBzdG9wOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlLnN0b3AoKTtcclxuICAgIH0sXHJcbiAgICBwYXVzZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIF9jb250ZXh0LnN0b3BwZWQgPSB0cnVlO1xyXG4gICAgfSxcclxuICAgIG9uRGV0ZWN0ZWQ6IGZ1bmN0aW9uIChjYWxsYmFjaykge1xyXG4gICAgICAgIGlmICghY2FsbGJhY2sgfHwgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJyAmJiAodHlwZW9mIGNhbGxiYWNrICE9PSAnb2JqZWN0JyB8fCAhY2FsbGJhY2suY2FsbGJhY2spKSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLnRyYWNlKCcqIHdhcm5pbmc6IFF1YWdnYS5vbkRldGVjdGVkIGNhbGxlZCB3aXRoIGludmFsaWQgY2FsbGJhY2ssIGlnbm9yaW5nJyk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgRXZlbnRzLnN1YnNjcmliZSgnZGV0ZWN0ZWQnLCBjYWxsYmFjayk7XHJcbiAgICB9LFxyXG4gICAgb2ZmRGV0ZWN0ZWQ6IGZ1bmN0aW9uIChjYWxsYmFjaykge1xyXG4gICAgICAgIEV2ZW50cy51bnN1YnNjcmliZSgnZGV0ZWN0ZWQnLCBjYWxsYmFjayk7XHJcbiAgICB9LFxyXG4gICAgb25Qcm9jZXNzZWQ6IGZ1bmN0aW9uIChjYWxsYmFjaykge1xyXG4gICAgICAgIGlmICghY2FsbGJhY2sgfHwgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJyAmJiAodHlwZW9mIGNhbGxiYWNrICE9PSAnb2JqZWN0JyB8fCAhY2FsbGJhY2suY2FsbGJhY2spKSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLnRyYWNlKCcqIHdhcm5pbmc6IFF1YWdnYS5vblByb2Nlc3NlZCBjYWxsZWQgd2l0aCBpbnZhbGlkIGNhbGxiYWNrLCBpZ25vcmluZycpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIEV2ZW50cy5zdWJzY3JpYmUoJ3Byb2Nlc3NlZCcsIGNhbGxiYWNrKTtcclxuICAgIH0sXHJcbiAgICBvZmZQcm9jZXNzZWQ6IGZ1bmN0aW9uIChjYWxsYmFjaykge1xyXG4gICAgICAgIEV2ZW50cy51bnN1YnNjcmliZSgncHJvY2Vzc2VkJywgY2FsbGJhY2spO1xyXG4gICAgfSxcclxuICAgIHNldFJlYWRlcnM6IGZ1bmN0aW9uIChyZWFkZXJzKSB7XHJcbiAgICAgICAgaWYgKCFyZWFkZXJzKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUudHJhY2UoJyogd2FybmluZzogUXVhZ2dhLnNldFJlYWRlcnMgY2FsbGVkIHdpdGggbm8gcmVhZGVycywgaWdub3JpbmcnKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpbnN0YW5jZS5zZXRSZWFkZXJzKHJlYWRlcnMpO1xyXG4gICAgfSxcclxuICAgIHJlZ2lzdGVyUmVhZGVyOiBmdW5jdGlvbiAobmFtZSwgcmVhZGVyKSB7XHJcbiAgICAgICAgaWYgKCFuYW1lKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUudHJhY2UoJyogd2FybmluZzogUXVhZ2dhLnJlZ2lzdGVyUmVhZGVyIGNhbGxlZCB3aXRoIG5vIG5hbWUsIGlnbm9yaW5nJyk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFyZWFkZXIpIHtcclxuICAgICAgICAgICAgY29uc29sZS50cmFjZSgnKiB3YXJuaW5nOiBRdWFnZ2EucmVnaXN0ZXJSZWFkZXIgY2FsbGVkIHdpdGggbm8gcmVhZGVyLCBpZ25vcmluZycpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGluc3RhbmNlLnJlZ2lzdGVyUmVhZGVyKG5hbWUsIHJlYWRlcik7XHJcbiAgICB9LFxyXG4gICAgcmVnaXN0ZXJSZXN1bHRDb2xsZWN0b3I6IGZ1bmN0aW9uIChyZXN1bHRDb2xsZWN0b3IpIHtcclxuICAgICAgICBpZiAocmVzdWx0Q29sbGVjdG9yICYmIHR5cGVvZiByZXN1bHRDb2xsZWN0b3IuYWRkUmVzdWx0ID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIF9jb250ZXh0LnJlc3VsdENvbGxlY3RvciA9IHJlc3VsdENvbGxlY3RvcjtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgZ2V0IGNhbnZhcygpIHtcclxuICAgICAgICByZXR1cm4gX2NvbnRleHQuY2FudmFzQ29udGFpbmVyO1xyXG4gICAgfSxcclxuICAgIGRlY29kZVNpbmdsZTogZnVuY3Rpb24gKGNvbmZpZywgcmVzdWx0Q2FsbGJhY2spIHtcclxuICAgICAgICBjb25zdCBxdWFnZ2FJbnN0YW5jZSA9IG5ldyBRdWFnZ2EoKTtcclxuICAgICAgICBjb25maWcgPSBtZXJnZSh7XHJcbiAgICAgICAgICAgIGlucHV0U3RyZWFtOiB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiAnSW1hZ2VTdHJlYW0nLFxyXG4gICAgICAgICAgICAgICAgc2VxdWVuY2U6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgc2l6ZTogODAwLFxyXG4gICAgICAgICAgICAgICAgc3JjOiBjb25maWcuc3JjLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBudW1PZldvcmtlcnM6IChFTlYuZGV2ZWxvcG1lbnQgJiYgY29uZmlnLmRlYnVnKSA/IDAgOiAxLFxyXG4gICAgICAgICAgICBsb2NhdG9yOiB7XHJcbiAgICAgICAgICAgICAgICBoYWxmU2FtcGxlOiBmYWxzZSxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9LCBjb25maWcpO1xyXG4gICAgICAgIC8vIFRPRE8gIzE3NTogcmVzdHJ1Y3R1cmUgd29ya2VyIHN1cHBvcnQgc28gdGhhdCBpdCB3aWxsIHdvcmsgd2l0aCB0eXBlc2NyaXB0IHVzaW5nIHdvcmtlci1sb2FkZXJcclxuICAgICAgICAvLyBodHRwczovL3dlYnBhY2suanMub3JnL2xvYWRlcnMvd29ya2VyLWxvYWRlci9cclxuICAgICAgICBpZiAoY29uZmlnLm51bU9mV29ya2VycyA+IDApIHtcclxuICAgICAgICAgICAgY29uZmlnLm51bU9mV29ya2VycyA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHdvcmtlcnMgcmVxdWlyZSBXb3JrZXIgYW5kIEJsb2Igc3VwcG9ydCBwcmVzZW50bHksIHNvIGlmIG5vIEJsb2Igb3IgV29ya2VyIHRoZW4gc2V0XHJcbiAgICAgICAgLy8gd29ya2VycyB0byAwLlxyXG4gICAgICAgIGlmIChjb25maWcubnVtT2ZXb3JrZXJzID4gMCAmJiAodHlwZW9mIEJsb2IgPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiBXb3JrZXIgPT09ICd1bmRlZmluZWQnKSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJyogbm8gV29ya2VyIGFuZC9vciBCbG9iIHN1cHBvcnQgLSBmb3JjaW5nIG51bU9mV29ya2VycyB0byAwJyk7XHJcbiAgICAgICAgICAgIGNvbmZpZy5udW1PZldvcmtlcnMgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbml0KGNvbmZpZywgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIEV2ZW50cy5vbmNlKCdwcm9jZXNzZWQnLCAocmVzdWx0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1YWdnYUluc3RhbmNlLnN0b3AoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdENhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRDYWxsYmFjay5jYWxsKG51bGwsIHJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHF1YWdnYUluc3RhbmNlLnN0YXJ0KCk7XHJcbiAgICAgICAgICAgICAgICB9LCBudWxsLCBxdWFnZ2FJbnN0YW5jZSk7XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH0sXHJcbiAgICAvLyBhZGQgdGhlIHVzdWFsbHkgZXhwZWN0ZWQgXCJkZWZhdWx0XCIgZm9yIHVzZSB3aXRoIHJlcXVpcmUsIGJ1aWxkIHN0ZXAgd29uJ3QgYWxsb3cgdXMgdG9cclxuICAgIC8vIHdyaXRlIHRvIG1vZHVsZS5leHBvcnRzIHNvIGRvIGl0IGhlcmUuXHJcbiAgICBnZXQgZGVmYXVsdCgpIHtcclxuICAgICAgICByZXR1cm4gUXVhZ2dhSlNTdGF0aWNJbnRlcmZhY2U7XHJcbiAgICB9LFxyXG4gICAgUmVhZGVycyxcclxuICAgIENhbWVyYUFjY2VzcyxcclxuICAgIEltYWdlRGVidWcsXHJcbiAgICBJbWFnZVdyYXBwZXIsXHJcbiAgICBSZXN1bHRDb2xsZWN0b3IsXHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBRdWFnZ2FKU1N0YXRpY0ludGVyZmFjZTtcclxuLy8gZXhwb3J0IEJhcmNvZGVSZWFkZXIgYW5kIG90aGVyIHV0aWxpdGllcyBmb3IgZXh0ZXJuYWwgcGx1Z2luc1xyXG5leHBvcnQge1xyXG4gICAgQmFyY29kZURlY29kZXIsXHJcbiAgICBSZWFkZXJzLFxyXG4gICAgQ2FtZXJhQWNjZXNzLFxyXG4gICAgSW1hZ2VEZWJ1ZyxcclxuICAgIEltYWdlV3JhcHBlcixcclxuICAgIFJlc3VsdENvbGxlY3RvcixcclxufTtcclxuIl0sInNvdXJjZVJvb3QiOiIifQ==